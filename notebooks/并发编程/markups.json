{"EpubVersion":1,"filepath":"","floatingtheme":[{"date":"2021-12-13 16:32:28","folded":true,"id":991,"linecolor":"ffcccedb","markups":[{"date":"2021-11-27 15:48:34","docid":1,"fillcolor":"ffffed99","folded":true,"id":992,"markups":[{"date":"2021-11-27 21:42:00","docid":1,"fillcolor":"ffffed99","id":993,"originaltext":"即 Guarded Suspension，用在一个线程等待另一个线程的执行结果","page":0,"textblocks":[{"first":[52.35818099975586,191.46047973632812,9.753898620605469,14.5],"last":[334.9024963378906,191.46047973632812,9.75390625,14.5],"length":39,"rects":[[52.35818099975586,191.46047973632812,292.29822158813477,14.5]],"start":21,"text":"即 Guarded Suspension，用在一个线程等待另一个线程的执行结果"}],"type":5}],"originaltext":"同步模式之保护性暂停","page":0,"textblocks":[{"first":[52.35818099975586,125.7861328125,17.069324493408203,19.5],"last":[205.98207092285156,125.7861328125,17.069320678710938,19.5],"length":10,"rects":[[52.35818099975586,125.7861328125,170.69321060180664,19.5]],"start":4,"text":"同步模式之保护性暂停"}],"type":5},{"date":"2021-11-27 20:12:46","docid":1,"fillcolor":"ffffed99","folded":true,"id":994,"markups":[{"date":"2021-11-27 21:41:49","docid":1,"fillcolor":"ffffed99","id":995,"originaltext":"Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回","page":7,"textblocks":[{"first":[52.35818099975586,296.5046691894531,6.320526123046875,14.5],"last":[120.6354751586914,312.6107177734375,9.753898620605469,12.5],"length":62,"rects":[[52.35818099975586,296.5046691894531,474.58823013305664,14.5],[52.35818099975586,312.6107177734375,78.03119277954102,12.5]],"start":26,"text":"Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做\n了，直接结束返回"}],"type":5}],"originaltext":"同步模式之 Balking","page":7,"textblocks":[{"first":[52.35818099975586,229.33038330078125,17.069324493408203,22.5],"last":[196.13311767578125,229.33038330078125,9.6441650390625,22.5],"length":13,"rects":[[52.35818099975586,229.33038330078125,153.4191017150879,22.5]],"start":4,"text":"同步模式之 Balking"}],"type":5},{"date":"2021-11-27 20:12:51","docid":1,"fillcolor":"ffffed99","id":996,"originaltext":"同步模式之顺序控制","page":8,"textblocks":[{"first":[52.35818099975586,434.9164733886719,17.069324493408203,19.5],"last":[188.91275024414062,434.9164733886719,17.069320678710938,19.5],"length":9,"rects":[[52.35818099975586,434.9164733886719,153.6238899230957,19.5]],"start":71,"text":"同步模式之顺序控制"}],"type":5},{"date":"2021-11-27 21:42:40","docid":1,"fillcolor":"ffffed99","id":997,"originaltext":"异步模式之生产者/消费者","page":13,"textblocks":[{"first":[52.35818099975586,245.58740234375,17.069324493408203,20.5],"last":[230.10049438476562,245.58740234375,17.069320678710938,20.5],"length":12,"rects":[[52.35818099975586,245.58740234375,194.8116340637207,20.5]],"start":2,"text":"异步模式之生产者/消费者"}],"type":5},{"date":"2021-11-27 22:38:16","docid":1,"fillcolor":"ffffed99","folded":true,"id":998,"markups":[{"date":"2021-11-28 17:38:33","docid":1,"fillcolor":"ffffed99","folded":true,"id":999,"markups":[{"date":"2021-11-28 17:38:27","docid":1,"fillcolor":"ffffed99","id":1000,"originaltext":"有限的工作线程（Worker Thread）来轮流异步处理无限多的任务","page":15,"textblocks":[{"first":[62.11207962036133,730.2360229492188,9.753902435302734,13.5],"last":[334.5580749511719,730.2360229492188,9.75390625,13.5],"length":35,"rects":[[62.11207962036133,730.2360229492188,282.19990158081055,13.5]],"start":35,"text":"有限的工作线程（Worker Thread）来轮流异步处理无限多的任务"}],"type":5}],"originaltext":"定义","page":15,"textblocks":[{"first":[68.65695190429688,701.0258178710938,14.630851745605469,17.5],"last":[83.28780364990234,701.0258178710938,14.630851745605469,17.5],"length":2,"rects":[[68.65695190429688,701.0258178710938,29.261703491210938,17.5]],"start":30,"text":"定义"}],"type":5},{"content":"有可能会发生饥饿现象，有可能算是保护性暂停的错误运用，两者可以互相转换导致，导致全部变成了消费者，等待生产者，只要让他们不要互相转换即可，不同的任务使用不同的线程池","date":"2021-11-28 20:22:54","docid":1,"fillcolor":"ffffed99","folded":true,"id":1001,"markups":[{"date":"2021-11-28 20:24:50","docid":1,"fillcolor":"ffffed99","id":1002,"originaltext":"不同任务类型应该使用不同的线程池，这样能够避免饥饿","page":16,"textblocks":[{"first":[81.61988067626953,93.97038269042969,9.753898620605469,13.5],"last":[315.7135925292969,93.97038269042969,9.75390625,13.5],"length":25,"rects":[[81.61988067626953,93.97038269042969,243.84761810302734,13.5]],"start":95,"text":"不同任务类型应该使用不同的线程池，这样能够避免饥饿"}],"type":5},{"date":"2021-11-28 20:37:41","docid":1,"id":1003,"linecolor":"ffff8280","linewidth":7,"originaltext":"","page":16,"rect":[318.5999905049803,154.79999538660059,323.199990397692,171.99999490380299],"type":11}],"originaltext":"饥饿","page":16,"textblocks":[{"first":[68.65695190429688,157.79736328125,14.630851745605469,17.5],"last":[83.28780364990234,157.79736328125,14.630851745605469,17.5],"length":2,"rects":[[68.65695190429688,157.79736328125,29.261703491210938,17.5]],"start":218,"text":"饥饿"}],"type":5},{"date":"2021-11-28 20:38:00","docid":1,"fillcolor":"ffffed99","folded":true,"id":1004,"markups":[{"content":"不能小到任务都在一个线程池","date":"2021-11-28 20:38:21","docid":1,"fillcolor":"ffffed99","id":1005,"originaltext":"过小会导致程序不能充分地利用系统资源、容易导致饥饿","page":18,"textblocks":[{"first":[74.86717987060547,382.3915710449219,9.753898620605469,12.5],"last":[308.96087646484375,382.3915710449219,9.75390625,12.5],"length":25,"rects":[[74.86717987060547,382.3915710449219,243.84760284423828,12.5]],"start":352,"text":"过小会导致程序不能充分地利用系统资源、容易导致饥饿"}],"type":5},{"content":"不能大到一直上下问切换","date":"2021-11-28 20:38:24","docid":1,"fillcolor":"ffffed99","id":1006,"originaltext":"过大会导致更多的线程上下文切换，占用更多内存","page":18,"textblocks":[{"first":[74.86717987060547,396.3983459472656,9.753898620605469,13.5],"last":[279.69915771484375,396.3983459472656,9.75390625,13.5],"length":22,"rects":[[74.86717987060547,396.3983459472656,214.58588409423828,13.5]],"start":378,"text":"过大会导致更多的线程上下文切换，占用更多内存"}],"type":5},{"date":"2021-11-28 20:38:29","docid":1,"fillcolor":"ffffed99","folded":false,"id":1007,"markups":[{"content":"数据分析的时候较多使用\n+1防止一个核心因为页缺失等原因暂停，这时使用+1的那个进程顶上去","date":"2021-11-28 20:39:09","docid":1,"fillcolor":"ffffed99","id":1008,"originaltext":"通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费","page":18,"textblocks":[{"first":[52.35818099975586,471.6772766113281,9.753898620605469,12.5],"last":[349.6615905761719,486.685546875,9.75390625,12.5],"length":94,"rects":[[52.35818099975586,471.6772766113281,487.02060317993164,12.5],[52.35818099975586,486.685546875,307.057315826416,12.5]],"start":418,"text":"通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因\n导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费"}],"type":5}],"originaltext":"CPU 密集型运算","page":18,"textblocks":[{"first":[72.92671966552734,445.9181213378906,7.76654052734375,12.5],"last":[149.498046875,445.9181213378906,12.1923828125,12.5],"length":9,"rects":[[72.92671966552734,445.9181213378906,88.76371002197266,12.5]],"start":407,"text":"CPU 密集型运算"}],"type":5},{"content":"WEB应用比较多使用I/O密集型运算","date":"2021-11-28 20:38:33","docid":1,"fillcolor":"ffffed99","id":1009,"markups":[{"date":"2021-11-28 20:39:14","docid":1,"fillcolor":"ffffed99","id":1010,"originaltext":"CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。","page":18,"textblocks":[{"first":[52.35893249511719,559.9149780273438,6.1547088623046875,13.5],"last":[477.5435791015625,574.9209594726562,9.75390625,13.5],"length":107,"rects":[[52.35893249511719,559.9149780273438,484.2368927001953,13.5],[52.35818099975586,574.9209594726562,434.93930435180664,13.5]],"start":530,"text":"CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程\nRPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。"}],"type":5},{"date":"2021-11-28 20:52:45","docid":1,"fillcolor":"ffffed99","id":1011,"markups":[{"date":"2021-11-28 20:52:51","docid":1,"fillcolor":"ffffed99","id":1012,"originaltext":"线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间","page":18,"textblocks":[{"first":[56.10968017578125,621.7696533203125,8.778511047363281,12.15325927734375],"last":[396.91766357421875,621.7696533203125,8.77850341796875,12.15325927734375],"length":52,"rects":[[56.10968017578125,621.7696533203125,349.58648681640625,12.15325927734375]],"start":645,"text":"线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间"}],"type":5}],"originaltext":"经验公式如下","page":18,"textblocks":[{"first":[52.35818099975586,597.7299194335938,9.753898620605469,12.5],"last":[101.12767791748047,597.7299194335938,9.753898620605469,12.5],"length":6,"rects":[[52.35818099975586,597.7299194335938,58.52339553833008,12.5]],"start":638,"text":"经验公式如下"}],"type":5}],"originaltext":"I/O 密集型运算","page":18,"textblocks":[{"first":[72.92671966552734,533.5550537109375,4.035675048828125,15.5],"last":[143.63442993164062,533.5550537109375,12.1923828125,15.5],"length":9,"rects":[[72.92671966552734,533.5550537109375,82.90009307861328,15.5]],"start":519,"text":"I/O 密集型运算"}],"type":5}],"originaltext":" 创建多少线程池合适","page":18,"textblocks":[{"first":[64.88143920898438,352.8783874511719,3.8040237426757812,17.5],"last":[185.70298767089844,352.8783874511719,14.630844116210938,17.5],"length":10,"rects":[[64.88143920898438,352.8783874511719,135.452392578125,17.5]],"start":340,"text":" 创建多少线程池合适"}],"type":5}],"originaltext":"异步模式之工作线程","page":15,"textblocks":[{"first":[52.35818099975586,663.76171875,17.069324493408203,19.5],"last":[188.91275024414062,663.76171875,17.069320678710938,19.5],"length":9,"rects":[[52.35818099975586,663.76171875,153.6238899230957,19.5]],"start":16,"text":"异步模式之工作线程"}],"type":5}],"page":-1,"title":"并发编程_模式","type":7},{"date":"2021-12-13 16:32:28","id":1013,"linecolor":"ffcccedb","page":-1,"title":"并发编程_应用","type":7},{"date":"2021-12-13 16:32:28","folded":false,"id":1014,"linecolor":"ffcccedb","markups":[{"date":"2021-11-30 14:19:46","docid":3,"fillcolor":"ffffed99","folded":true,"id":1015,"markups":[{"content":"是一个抽象父类，是一个抽象的基于队列的同步器，是阻塞式同步器的祖宗\n\n同步器也就是锁，定义很多方法，就是规定了锁的规格，就像是AQS是锁的模板\n\n当要创建锁的话就直接实现Lock，然后创建模板AQS，也可以用创建一个类来继承模板AQS，然后对它进行一些改造，然后在Lock类中使用模板\n\n其中对aqs模板的修改一定要严格根据synchronized同步锁的逻辑进行修改","date":"2021-11-30 14:19:54","docid":3,"fillcolor":"ffffed99","folded":true,"id":1016,"markups":[{"date":"2021-11-30 14:22:32","docid":3,"fillcolor":"ffffed99","folded":false,"id":1017,"markups":[{"content":"其中的共享模式有需要定义上限，不能无限个线程来访问资源\n\n可以理解Java版本的Synchronized，原来的Synchronized是C++版本的\n\n不同的的是多个条件变量，可以分为独占和共享模式","date":"2021-11-30 14:22:42","docid":3,"fillcolor":"ffffed99","id":1018,"originaltext":"用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁getState - 获取 state 状态setState - 设置 state 状态compareAndSetState - cas 机制设置 state 状态独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet","page":35,"textblocks":[{"first":[74.86717987060547,499.8909606933594,9.753898620605469,13.499969482421875],"last":[423.040771484375,619.191650390625,3.443115234375,13.5],"length":266,"rects":[[74.86717987060547,499.8909606933594,466.41223907470703,13.499969482421875],[74.86717987060547,515.1976928710938,48.769493103027344,13.5],[97.3769302368164,534.405517578125,112.1045913696289,13.5],[97.3769302368164,550.2122192382812,111.41356658935547,12.5],[97.3769302368164,566.71826171875,207.2809066772461,9.5],[97.3769302368164,579.7249755859375,341.38668060302734,12.5],[74.86717987060547,599.68310546875,255.2077407836914,13.5],[74.86717987060547,619.191650390625,351.61670684814453,13.5]],"start":200,"text":"用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取\n锁和释放锁\ngetState - 获取 state 状态\nsetState - 设置 state 状态\ncompareAndSetState - cas 机制设置 state 状态\n独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源\n提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList\n条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet"}],"type":5},{"content":"直接调用会抛出异常，需要子类覆盖","date":"2021-11-30 14:29:03","docid":3,"fillcolor":"ffffed99","folded":true,"id":1019,"markups":[{"date":"2021-11-30 14:30:45","docid":3,"fillcolor":"ffffed99","id":1020,"originaltext":"// 入队, 可以选择阻塞当前线程  park unpark","page":36,"textblocks":[{"first":[84.17540740966797,117.82252502441406,4.828178405761719,12.758926391601562],"last":[271.5531311035156,117.82252502441406,4.82818603515625,12.758926391601562],"length":30,"rects":[[84.17540740966797,117.82252502441406,192.2059097290039,12.758926391601562]],"start":79,"text":"// 入队, 可以选择阻塞当前线程  park unpark"}],"type":5},{"content":"尝试加锁","date":"2021-11-30 14:52:47","docid":3,"fillcolor":"ffffed99","id":1021,"originaltext":"tryAcquire","page":35,"textblocks":[{"first":[74.86717987060547,688.2207641601562,3.4431228637695312,13.5],"last":[116.24028778076172,688.2207641601562,5.4719390869140625,13.5],"length":10,"rects":[[74.86717987060547,688.2207641601562,46.84504699707031,13.5]],"start":518,"text":"tryAcquire"}],"type":5},{"date":"2021-11-30 14:52:52","docid":3,"fillcolor":"ffffed99","id":1022,"originaltext":"tryAcquireShared","page":35,"textblocks":[{"first":[74.86717987060547,718.2327270507812,3.4431228637695312,13.5],"last":[147.73533630371094,718.2327270507812,5.9791412353515625,13.5],"length":16,"rects":[[74.86717987060547,718.2327270507812,78.84729766845703,13.5]],"start":540,"text":"tryAcquireShared"}],"type":5},{"content":"尝试解锁，不会唤醒阻塞队列中的线程","date":"2021-11-30 14:52:50","docid":3,"fillcolor":"ffffed99","id":1023,"originaltext":"tryRelease","page":35,"textblocks":[{"first":[74.86717987060547,704.5267333984375,3.4431228637695312,9.5],"last":[116.7211685180664,704.5267333984375,5.4719390869140625,9.5],"length":10,"rects":[[74.86717987060547,704.5267333984375,47.325927734375,9.5]],"start":529,"text":"tryRelease"}],"type":5},{"date":"2021-11-30 14:52:54","docid":3,"fillcolor":"ffffed99","id":1024,"originaltext":"tryReleaseShared","page":35,"textblocks":[{"first":[74.86717987060547,734.5394897460938,3.4431228637695312,9.5],"last":[148.22117614746094,734.5394897460938,5.9791412353515625,9.5],"length":16,"rects":[[74.86717987060547,734.5394897460938,79.33313751220703,9.5]],"start":557,"text":"tryReleaseShared"}],"type":5},{"content":"是否是独占锁","date":"2021-11-30 14:52:56","docid":3,"fillcolor":"ffffed99","id":1025,"originaltext":"isHeldExclusively","page":35,"textblocks":[{"first":[74.86717987060547,748.2454833984375,2.4677352905273438,13.5],"last":[146.48609924316406,748.2454833984375,4.9159698486328125,13.5],"length":17,"rects":[[74.86717987060547,748.2454833984375,76.5348892211914,13.5]],"start":574,"text":"isHeldExclusively"}],"type":5}],"originaltext":"子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）","page":35,"textblocks":[{"first":[52.35818099975586,664.1599731445312,9.753898620605469,14.5],"last":[371.2897033691406,664.1599731445312,9.75390625,14.5],"length":48,"rects":[[52.35818099975586,664.1599731445312,328.68542861938477,14.5]],"start":469,"text":"子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）"}],"type":5}],"originaltext":"特点","page":35,"textblocks":[{"first":[52.3574333190918,476.93011474609375,9.753898620605469,12.5],"last":[62.111331939697266,476.93011474609375,9.753902435302734,12.5],"length":2,"rects":[[52.3574333190918,476.93011474609375,19.507801055908203,12.5]],"start":196,"text":"特点"}],"type":5}],"originaltext":"AbstractQueuedSynchronizer","page":35,"textblocks":[{"first":[84.15589141845703,453.3211364746094,6.174217224121094,14.5],"last":[213.2451629638672,453.3211364746094,3.979583740234375,14.5],"length":26,"rects":[[84.15589141845703,453.3211364746094,133.06885528564453,14.5]],"start":151,"text":"AbstractQueuedSynchronizer"}],"type":5}],"originaltext":"AQS 原理","page":35,"textblocks":[{"first":[52.35818099975586,387.7468566894531,11.777835845947266,20.5],"last":[108.28329467773438,387.7468566894531,17.069320678710938,20.5],"length":6,"rects":[[52.35818099975586,387.7468566894531,72.99443435668945,20.5]],"start":132,"text":"AQS 原理"}],"type":5},{"content":"实现了Lock锁其中有很多实现方法，底层调用了更加规范的实现了AQS模板的Sync，使用AQS模板进行创建锁，有两套实现方式分别是非公平NonfairSync和公平fairSync，\n\n默认为的ReentrantLock调用了非公平NonfairSync","date":"2021-11-30 17:17:44","docid":3,"fillcolor":"ffffed99","folded":false,"id":1026,"markups":[{"date":"2021-11-30 17:22:35","docid":3,"fillcolor":"ffffed99","folded":false,"id":1027,"markups":[{"content":"1、使用cas改变锁的状态变为1\n2、改变owner指向运行线程","date":"2021-11-30 17:22:55","docid":3,"fillcolor":"ffffed99","folded":false,"id":1028,"markups":[{"content":"1、尝试进行加锁，加锁失败\n2、会进入到tryAcquire，再次进行一次加锁，如果还是失败，则创建节点对象\n3、进入acquireQueued方法，加入到阻塞队列中EntryList，会判断前驱节点是否是首节点，是的话进行争夺锁\n（这是双向链表其中锁对象会有一个指向头节点和指向尾节点的head和tail节点对象，首次创建节点会创建两个节点，第一个为哑元或哨兵用来占位并且每个Node都有状态0表示默认正常）\n\n4、不是的情况下，shouldParkAfterFailedAcquire会判断这个争夺锁的线程是否需要park，第一次将前驱节点变成-1表示它有唤醒后继节点的责任，然后返回false进行最后一次争夺锁，失败，则再次进入acquireQueued方法，这次的shouldParkAfterFailedAcquire返回true，将这个线程进行park\n\n4次加锁，第一次加锁失败，再给一次机会加锁，失败进入队列后前驱是哑元的情况下再试一次加锁，失败将前驱状态变为-1，将要park线程的时候再进行一次加锁，失败直接park","date":"2021-11-30 17:28:11","docid":3,"fillcolor":"ffffed99","folded":false,"id":1029,"markups":[{"content":"第一次","date":"2021-11-30 21:30:53","docid":3,"fillcolor":"ffffed99","id":1030,"originaltext":"compareAndSetState(0, 1)","page":46,"textblocks":[{"first":[122.78058624267578,85.49420928955078,4.828178405761719,8.778511047363281],"last":[233.7544708251953,85.49420928955078,4.82818603515625,8.778511047363281],"length":24,"rects":[[122.78058624267578,85.49420928955078,115.80207061767578,8.778511047363281]],"start":95,"text":"compareAndSetState(0, 1)"}],"type":5},{"content":"进行第二次尝试，如果不成，就放入阻塞队列","date":"2021-11-30 21:17:36","docid":3,"fillcolor":"ffffed99","id":1031,"originaltext":"if (            !tryAcquire(arg) &&             // 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)","page":46,"textblocks":[{"first":[103.48662567138672,224.5677490234375,4.828178405761719,2.5],"last":[335.0794677734375,261.06439208984375,4.82818603515625,8.77850341796875],"length":172,"rects":[[103.48662567138672,224.5677490234375,19.304458618164062,2.5],[64.88069152832031,234.0535888671875,154.4080047607422,8.778518676757812],[64.88143920898438,247.5589599609375,413.865478515625,8.77850341796875],[64.88143920898438,261.06439208984375,275.0262145996094,8.77850341796875]],"start":371,"text":"if (\n            !tryAcquire(arg) && \n            // 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)"}],"type":5},{"content":"真正将放入阻塞队列的方法","date":"2021-11-30 21:20:00","docid":3,"fillcolor":"ffffed99","id":1032,"originaltext":"private Node addWaiter(Node mode)","page":46,"textblocks":[{"first":[84.18365478515625,773.519287109375,4.828178405761719,8.77850341796875],"last":[238.5593719482422,773.519287109375,4.82818603515625,8.77850341796875],"length":33,"rects":[[84.18365478515625,773.519287109375,159.2039031982422,8.77850341796875]],"start":1563,"text":"private Node addWaiter(Node mode)"}],"type":5},{"content":"第三次，第四次在同一次","date":"2021-11-30 21:29:54","docid":3,"fillcolor":"ffffed99","id":1033,"originaltext":"p == head && tryAcquire(arg)","page":47,"textblocks":[{"first":[161.41128540039062,666.2256469726562,4.82818603515625,8.77850341796875],"last":[291.6273498535156,666.2256469726562,4.82818603515625,8.77850341796875],"length":28,"rects":[[161.41128540039062,666.2256469726562,135.04425048828125,8.77850341796875]],"start":1385,"text":"p == head && tryAcquire(arg)"}],"type":5},{"content":"第一次将返回false，让它再进入一次加锁","date":"2021-11-30 21:32:06","docid":3,"fillcolor":"ffffed99","id":1034,"originaltext":"shouldParkAfterFailedAcquire(p, node)","page":48,"textblocks":[{"first":[161.39852905273438,99.00263214111328,4.82818603515625,8.778511047363281],"last":[335.1162414550781,99.00263214111328,4.82818603515625,8.778511047363281],"length":37,"rects":[[161.39852905273438,99.00263214111328,178.5458984375,8.778511047363281]],"start":187,"text":"shouldParkAfterFailedAcquire(p, node)"}],"type":5}],"originaltext":"Thread-1 执行了","page":43,"textblocks":[{"first":[52.35818099975586,275.59869384765625,5.3939056396484375,12.5],"last":[115.15829467773438,275.59869384765625,9.753898620605469,12.5],"length":12,"rects":[[52.35818099975586,275.59869384765625,72.55401229858398,12.5]],"start":0,"text":"Thread-1 执行了"}],"title":"4次加锁","type":5},{"content":"1、尝试将中锁状态state变为0，Owner置为null，成功去查看EntryList的head是否为空并且头节点的状态是否为-1（-1要唤醒后面的线程）\n2、true就将，离head（head就是哑元）最近的节点进行唤醒，将其中节点存储的线程置为null，等待该线程再次去争夺锁\n（程这是进入阻塞队列前的尝试获取锁，还有park线程之前的获取锁的机会）\n\n注意：\n非公平锁会有其他线程和阻塞队列的线程争夺锁，失败的话，不会改变队列中的排队顺序；\n阻塞队列中的线程只有获取到锁的情况下，才能出队列，否则还是在原来的位置。\n","date":"2021-11-30 18:02:11","docid":3,"fillcolor":"ffffed99","id":1035,"originaltext":"Thread-0 释放锁，进入 tryRelease 流程","page":44,"textblocks":[{"first":[52.35818099975586,662.660888671875,5.3939056396484375,14.5],"last":[216.28672790527344,662.660888671875,9.75390625,14.5],"length":29,"rects":[[52.35818099975586,662.660888671875,173.68245315551758,14.5]],"start":252,"text":"Thread-0 释放锁，进入 tryRelease 流程"}],"title":"解锁，然后竞争锁","type":5}],"originaltext":"加锁解锁流程","page":42,"textblocks":[{"first":[52.35818099975586,321.6147155761719,12.192371368408203,15.5],"last":[113.32005310058594,321.6147155761719,12.192375183105469,15.5],"length":6,"rects":[[52.35818099975586,321.6147155761719,73.15424728393555,15.5]],"start":13,"text":"加锁解锁流程"}],"type":5}],"originaltext":"非公平锁实现原理","page":42,"textblocks":[{"first":[68.65695190429688,293.60394287109375,14.630851745605469,16.5],"last":[171.07289123535156,293.60394287109375,14.630844116210938,16.5],"length":8,"rects":[[68.65695190429688,293.60394287109375,117.04678344726562,16.5]],"start":3,"text":"非公平锁实现原理"}],"type":5},{"content":"可重入锁加锁\n会判断加锁的线程是否等于owner线程\n开始的时候，判断状态是否为0，0表示没被任何线程获取到锁\n进入普通的加锁\n不为0，就判断加锁的线程是否等于owner线程，是，将state加1，返回true\n\n可重入解锁\n先将状态-1，然后查看这个值是否为0，为0表示不是重入锁，进入正常的解锁过程，\n不为0，重入锁，提交锁状态即可","date":"2021-11-30 18:40:55","docid":3,"fillcolor":"ffffed99","id":1036,"originaltext":"可重入原理","page":50,"textblocks":[{"first":[68.65695190429688,238.583251953125,14.630851745605469,17.5],"last":[127.18035888671875,238.583251953125,14.630844116210938,17.5],"length":5,"rects":[[68.65695190429688,238.583251953125,73.15425109863281,17.5]],"start":3,"text":"可重入原理"}],"type":5},{"content":"在死循环中，park后被打断，用interrupted返回当前打断状态，然后清除。退出循环使用","date":"2021-11-30 21:06:58","docid":3,"fillcolor":"ffffed99","folded":false,"id":1037,"markups":[{"content":"就算打断了也使用返回打断状态的interrupted方法返回打断状态然后清空，它会记录打断状态知道获取锁的清空才会返回打断标志","date":"2021-11-30 21:14:39","docid":3,"fillcolor":"ffffed99","folded":true,"id":1038,"markups":[{"content":"在死循环中，park后被打断，用interrupted返回当前打断状态，然后清除打断标记，所以下一次还能打断。","date":"2021-11-30 21:12:35","docid":3,"fillcolor":"ffffed99","id":1039,"originaltext":"private final boolean parkAndCheckInterrupt() {        // 如果打断标记已经是 true, 则 park 会失效        LockSupport.park(this);        // interrupted 会清除打断标记        return Thread.interrupted();    }","page":51,"textblocks":[{"first":[84.17615509033203,303.08416748046875,4.828178405761719,8.77850341796875],"last":[84.19415283203125,368.2536926269531,4.828178405761719,11.530364990234375],"length":191,"rects":[[84.17615509033203,303.08416748046875,226.7947006225586,8.77850341796875],[64.87994384765625,312.5865783691406,229.83636474609375,13.15325927734375],[64.87994384765625,330.0950012207031,149.57606506347656,8.77850341796875],[64.88069152832031,339.5973815917969,172.3461151123047,13.15325927734375],[64.88069152832031,357.1058044433594,173.7244873046875,8.77850341796875],[64.88143920898438,368.2536926269531,24.140892028808594,11.530364990234375]],"start":201,"text":"private final boolean parkAndCheckInterrupt() {\n        // 如果打断标记已经是 true, 则 park 会失效\n        LockSupport.park(this);\n        // interrupted 会清除打断标记\n        return Thread.interrupted();\n    }"}],"type":5},{"content":"退出循环使用interrupted记录打断，只有获取到锁的情况下才会返回已经记录的打断标志","date":"2021-11-30 21:12:48","docid":3,"fillcolor":"ffffed99","id":1040,"originaltext":"if (                    shouldParkAfterFailedAcquire(p, node) &&                    parkAndCheckInterrupt()                ) {                    // 如果是因为 interrupt 被唤醒, 返回打断状态为 true                    interrupted = true;                }","page":51,"textblocks":[{"first":[141.998779296875,570.834716796875,4.82818603515625,11.53033447265625],"last":[142.1398162841797,651.8671264648438,4.82818603515625,11.53033447265625],"length":244,"rects":[[141.998779296875,570.834716796875,19.416275024414062,11.53033447265625],[64.88819885253906,586.6975708007812,289.54151916503906,8.77850341796875],[64.88819885253906,600.2030029296875,207.5247344970703,8.77850341796875],[64.88819885253906,611.3508911132812,91.73542785644531,11.53033447265625],[64.88819885253906,624.0108032226562,329.44850158691406,12.15325927734375],[64.88819885253906,638.3616943359375,188.18350219726562,11.53033447265625],[64.88894653320312,651.8671264648438,82.07905578613281,11.53033447265625]],"start":892,"text":"if (\n                    shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt()\n                ) {\n                    // 如果是因为 interrupt 被唤醒, 返回打断状态为 true\n                    interrupted = true;\n                }"}],"type":5}],"originaltext":"不可打断模式","page":51,"textblocks":[{"first":[52.35818099975586,183.8062744140625,12.192371368408203,14.5],"last":[113.32005310058594,183.8062744140625,12.192375183105469,14.5],"length":6,"rects":[[52.35818099975586,183.8062744140625,73.15424728393555,14.5]],"start":12,"text":"不可打断模式"}],"type":5},{"date":"2021-11-30 21:24:52","docid":3,"fillcolor":"ffffed99","folded":true,"id":1041,"markups":[{"content":"直接抛出异常","date":"2021-11-30 21:27:02","docid":3,"fillcolor":"ffffed99","id":1042,"originaltext":"if (shouldParkAfterFailedAcquire(p, node) &&                    parkAndCheckInterrupt()) {                    // 在 park 过程中如果被 interrupt 会进入此                    // 这时候抛出异常, 而不会再次进入 for (;;)                    throw new InterruptedException();","page":52,"textblocks":[{"first":[141.99952697753906,601.7058715820312,4.82818603515625,8.77850341796875],"last":[315.8252868652344,655.7274169921875,4.82818603515625,8.77850341796875],"length":246,"rects":[[141.99952697753906,601.7058715820312,212.43019104003906,8.77850341796875],[64.88819885253906,615.2112426757812,222.00929260253906,8.77850341796875],[64.88819885253906,624.713623046875,289.47096252441406,13.15325927734375],[64.88819885253906,639.8645629882812,286.9695281982422,11.53033447265625],[64.88819885253906,655.7274169921875,255.76527404785156,8.77850341796875]],"start":1126,"text":"if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt()) {\n                    // 在 park 过程中如果被 interrupt 会进入此\n                    // 这时候抛出异常, 而不会再次进入 for (;;)\n                    throw new InterruptedException();"}],"type":5}],"originaltext":"可打断模式","page":52,"textblocks":[{"first":[52.35818099975586,264.1921081542969,12.192371368408203,15.5],"last":[101.12767791748047,264.1921081542969,12.192375183105469,15.5],"length":5,"rects":[[52.35818099975586,264.1921081542969,60.96187210083008,15.5]],"start":0,"text":"可打断模式"}],"type":5}],"originaltext":"可打断原理","page":51,"textblocks":[{"first":[68.65695190429688,154.79547119140625,14.630851745605469,16.5],"last":[127.18035888671875,154.79547119140625,14.630844116210938,16.5],"length":5,"rects":[[68.65695190429688,154.79547119140625,73.15425109863281,16.5]],"start":5,"text":"可打断原理"}],"type":5},{"date":"2021-11-30 21:37:32","docid":3,"fillcolor":"ffffed99","folded":true,"id":1043,"markups":[{"content":"公平锁的区别就在于获取锁的流程不一样\n公平锁获取原理开始会进行判断阻塞队列里面有没有任务，没有任务才会进行抢夺，有的话直接判断false。\n\n而非公平锁直接就设置状态进行抢夺锁","date":"2021-11-30 21:39:05","docid":3,"fillcolor":"ffffed99","id":1044,"originaltext":"protected final boolean tryAcquire(int acquires) {","page":53,"textblocks":[{"first":[84.18140411376953,362.3608703613281,4.828178405761719,8.77850341796875],"last":[320.60546875,362.3608703613281,4.82818603515625,8.77850341796875],"length":50,"rects":[[84.18140411376953,362.3608703613281,241.25225067138672,8.77850341796875]],"start":460,"text":"protected final boolean tryAcquire(int acquires) {"}],"type":5}],"originaltext":" 公平锁实现原理","page":53,"textblocks":[{"first":[64.88218688964844,76.012451171875,3.8040237426757812,17.5],"last":[156.44204711914062,76.012451171875,14.630844116210938,17.5],"length":8,"rects":[[64.88218688964844,76.012451171875,106.19070434570312,17.5]],"start":2,"text":" 公平锁实现原理"}],"type":5},{"date":"2021-11-30 22:03:37","docid":3,"fillcolor":"ffffed99","folded":true,"id":1045,"markups":[{"content":"每一个条件变量也就是WaitSet都是ConditionObject\n底层是一个双向链表","date":"2021-11-30 22:04:06","docid":3,"fillcolor":"ffffed99","id":1046,"originaltext":"每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject","page":54,"textblocks":[{"first":[52.35818099975586,173.0518798828125,9.753898620605469,12.5],"last":[359.4206848144531,173.0518798828125,3.443115234375,12.5],"length":40,"rects":[[52.35818099975586,173.0518798828125,310.50561904907227,12.5]],"start":13,"text":"每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject"}],"type":5},{"content":"直接创建一个节点存储当前持有锁的线程，只有持有锁的线程才能进入ConditionObject条件变量，进入EntryList也就是  阻塞队列  并且  需要唤醒后面线程  的线程状态为-1，而进入进入WaitSet也就是ConditionObject条件变量的线程状态是-2\n\n进入条件变量中会将Owner置为null，锁状态state为0","date":"2021-11-30 22:06:38","docid":3,"fillcolor":"ffffed99","folded":true,"id":1047,"markups":[{"content":"首先进入addConditionWaiter加入到ConditionObject\n\n然后是fullyRelease让当前线程放弃锁，注意有可能是重入锁，直接全部放锁\n\n唤醒离head节点最近的一个节点，让它去争夺锁","date":"2021-11-30 23:22:53","docid":3,"fillcolor":"ffffed99","id":1048,"originaltext":"调用 await，进入 ConditionObject 的 addConditionWaiter 流程","page":54,"textblocks":[{"first":[156.70767211914062,223.7722625732422,9.75390625,13.5],"last":[427.0122375488281,223.7722625732422,9.75390625,13.5],"length":51,"rects":[[156.70767211914062,223.7722625732422,280.0584716796875,13.5]],"start":80,"text":"调用 await，进入 ConditionObject 的 addConditionWaiter 流程"}],"type":5},{"date":"2021-11-30 23:23:33","docid":3,"fillcolor":"ffffed99","id":1049,"originaltext":"fullyRelease 流程","page":54,"textblocks":[{"first":[137.41143798828125,457.0718688964844,3.3065643310546875,14.5],"last":[203.82875061035156,457.0718688964844,9.75390625,14.5],"length":15,"rects":[[137.41143798828125,457.0718688964844,76.17121887207031,14.5]],"start":198,"text":"fullyRelease 流程"}],"type":5},{"date":"2021-11-30 23:25:03","docid":3,"fillcolor":"ffffed99","id":1050,"originaltext":"unpark AQS 队列中的下一个节点","page":54,"textblocks":[{"first":[52.35818099975586,670.16162109375,5.988895416259766,14.5],"last":[186.86000061035156,670.16162109375,9.75390625,14.5],"length":20,"rects":[[52.35818099975586,670.16162109375,144.2557258605957,14.5]],"start":223,"text":"unpark AQS 队列中的下一个节点"}],"type":5}],"originaltext":"await 流程","page":54,"textblocks":[{"first":[52.35818099975586,197.41238403320312,7.364192962646484,15.5],"last":[101.87123107910156,197.41238403320312,12.192375183105469,15.5],"length":8,"rects":[[52.35818099975586,197.41238403320312,61.70542526245117,15.5]],"start":54,"text":"await 流程"}],"type":5},{"date":"2021-11-30 23:27:38","docid":3,"fillcolor":"ffffed99","id":1051,"markups":[{"content":"其中doSignal可能失败，也就其中存储的线程有可能被打断或者其他原因导致个线程不再执行，这样doSignal会循环去寻找ConditionObject中下一个线程","date":"2021-11-30 23:31:17","docid":3,"fillcolor":"ffffed99","id":1052,"originaltext":"进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node","page":55,"textblocks":[{"first":[52.35818099975586,751.1992797851562,9.753898620605469,14.5],"last":[465.16119384765625,751.1992797851562,5.471923828125,14.5],"length":67,"rects":[[52.35818099975586,751.1992797851562,418.2749366760254,14.5]],"start":54,"text":"进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node"}],"type":5},{"content":"会将ConditionObject中出来的节点加入到AQS队列的最后中，等待并将状态改为0，将前驱状态改为-1，来唤醒最后的几点","date":"2021-11-30 23:31:23","docid":3,"fillcolor":"ffffed99","id":1053,"originaltext":"执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1","page":56,"textblocks":[{"first":[52.35818099975586,287.5040588378906,9.753898620605469,14.5],"last":[127.25838470458984,303.31005859375,5.579231262207031,13.5],"length":100,"rects":[[52.35818099975586,287.5040588378906,481.4270362854004,14.5],[52.35818099975586,303.31005859375,80.47943496704102,13.5]],"start":0,"text":"执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的\nwaitStatus 改为 -1"}],"type":5}],"originaltext":"signal 流程","page":55,"textblocks":[{"first":[52.35818099975586,462.9793701171875,6.059612274169922,16.5],"last":[103.45586395263672,462.9793701171875,12.192375183105469,16.5],"length":9,"rects":[[52.35818099975586,462.9793701171875,63.29005813598633,16.5]],"start":17,"text":"signal 流程"}],"type":5}],"originaltext":"条件变量实现原理","page":54,"textblocks":[{"first":[68.65695190429688,143.24168395996094,14.630851745605469,18.5],"last":[171.07289123535156,143.24168395996094,14.630844116210938,18.5],"length":8,"rects":[[68.65695190429688,143.24168395996094,117.04678344726562,18.5]],"start":3,"text":"条件变量实现原理"}],"type":5}],"originaltext":"ReentrantLock 原理","page":41,"textblocks":[{"first":[52.35818099975586,673.76416015625,11.265754699707031,13.5],"last":[199.77186584472656,673.76416015625,17.069320678710938,13.5],"length":16,"rects":[[52.35818099975586,673.76416015625,164.48300552368164,13.5]],"start":47,"text":"ReentrantLock 原理"}],"type":5}],"page":-1,"title":"并发编程_原理","type":7}],"folded":false,"markups":[{"date":"2021-11-16 10:56:07","docid":0,"fillcolor":"ffffed99","folded":true,"id":532,"markups":[{"date":"2021-11-16 10:54:51","docid":0,"fillcolor":"ffffed99","id":529,"originaltext":"程序由指令和数据组成","page":5,"textblocks":[{"first":[74.86717987060547,251.837158203125,9.753898620605469,12.5],"last":[162.6522979736328,251.837158203125,9.75390625,12.5],"length":10,"rects":[[74.86717987060547,251.837158203125,97.53902435302734,12.5]],"start":27,"text":"程序由指令和数据组成"}],"title":"程序","type":5},{"date":"2021-11-16 10:54:56","docid":0,"fillcolor":"ffffed99","folded":false,"id":530,"markups":[{"date":"2021-11-16 10:54:58","docid":0,"fillcolor":"ffffed99","id":531,"originaltext":"进程就可以视为程序的一个实例。","page":5,"textblocks":[{"first":[74.86717987060547,296.8558349609375,9.753898620605469,12.5],"last":[211.4218292236328,296.8558349609375,9.75390625,12.5],"length":15,"rects":[[74.86717987060547,296.8558349609375,146.30855560302734,12.5]],"start":159,"text":"进程就可以视为程序的一个实例。"}],"type":5}],"originaltext":"当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。","page":5,"textblocks":[{"first":[74.86717987060547,281.849853515625,9.753898620605469,12.5],"last":[416.25384521484375,281.849853515625,9.75390625,12.5],"length":36,"rects":[[74.86717987060547,281.849853515625,351.1405715942383,12.5]],"start":122,"text":"当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。"}],"title":"进程与程序的关系","type":5},{"date":"2021-11-16 10:54:39","docid":0,"fillcolor":"ffffed99","id":528,"originaltext":"一个进程之内可以分为一到多个线程。一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器","page":5,"textblocks":[{"first":[74.86717987060547,384.3935546875,9.753898620605469,13.5],"last":[123.63667297363281,429.41229248046875,9.75390625,13.5],"length":119,"rects":[[74.86717987060547,384.3935546875,165.81636810302734,13.5],[74.86717987060547,399.3995666503906,346.07288360595703,13.5],[74.86717987060547,415.1062927246094,458.4926223754883,13.5],[74.86717987060547,429.41229248046875,58.523399353027344,13.5]],"start":249,"text":"一个进程之内可以分为一到多个线程。\n一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行\nJava 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作\n为线程的容器"}],"title":"线程","type":5},{"date":"2021-11-16 10:54:23","docid":0,"fillcolor":"ffffed99","id":526,"originaltext":"二者对比 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集进程拥有共享的资源，如内存空间等，供其内部的线程共享进程间通信较为复杂同一台计算机的进程通信称为 IPC（Inter-process communication）不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量线程更轻量，线程上下文切换成本一般上要比进程上下文切换低","page":6,"textblocks":[{"first":[52.35818099975586,195.07501220703125,12.192371368408203,15.5],"last":[338.22259521484375,335.87298583984375,9.75390625,12.5],"length":228,"rects":[[52.35818099975586,195.07501220703125,492.6935157775879,15.5],[74.86717987060547,221.82513427734375,282.8632278442383,12.5],[74.86717987060547,241.33294677734375,253.60150909423828,12.5],[74.86717987060547,260.59173583984375,87.78511810302734,13.5],[97.3769302368164,280.799560546875,296.8216781616211,13.5],[97.3769302368164,296.1063232421875,328.95809173583984,12.5],[74.86717987060547,316.36517333984375,409.6640090942383,12.5],[74.86717987060547,335.87298583984375,273.1093215942383,12.5]],"start":57,"text":"二者对比 \n进程基本上相互独立的，而线程存在于进程内，是进程的一个子集\n进程拥有共享的资源，如内存空间等，供其内部的线程共享\n进程间通信较为复杂\n同一台计算机的进程通信称为 IPC（Inter-process communication）\n不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP\n线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量\n线程更轻量，线程上下文切换成本一般上要比进程上下文切换低"}],"title":"进程和线程的对比","type":5},{"date":"2021-11-16 10:54:18","docid":0,"fillcolor":"ffffed99","id":525,"originaltext":"单核 cpu 下，线程实际还是 串行执行 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是 同时运行的 。总结为一句话就是：微观串行，宏观并行，一般会将这种 线程轮流使用 CPU 的做法称为并发， concurrent","page":6,"textblocks":[{"first":[52.35818099975586,618.736083984375,9.753898620605469,12.5],"last":[322.3595886230469,671.9915771484375,3.443115234375,13.15325927734375],"length":183,"rects":[[52.35818099975586,618.736083984375,482.11801528930664,12.5],[52.36043930053711,633.7481079101562,486.57565689086914,12.5],[52.36043930053711,648.7540893554688,269.7576026916504,12.5],[52.3619384765625,671.9915771484375,273.4407653808594,13.15325927734375]],"start":317,"text":"单核 cpu 下，线程实际还是 串行执行 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows\n下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感\n觉是 同时运行的 。总结为一句话就是：微观串行，宏观并行，\n一般会将这种 线程轮流使用 CPU 的做法称为并发， concurrent"}],"title":"串行与并行","type":5},{"content":"并发：同一时间段，并行：同一时刻","date":"2021-11-16 10:54:12","docid":0,"fillcolor":"ffffed99","id":524,"originaltext":"并发（concurrent）是同一时间应对（dealing with）多件事情的能力并行（parallel）是同一时间动手做（doing）多件事情的能力","page":8,"textblocks":[{"first":[74.86717987060547,667.1626586914062,9.753898620605469,14.5],"last":[329.0973815917969,682.1686401367188,9.75390625,14.5],"length":77,"rects":[[74.86717987060547,667.1626586914062,300.05628204345703,14.5],[74.86717987060547,682.1686401367188,263.9841079711914,14.5]],"start":23,"text":"并发（concurrent）是同一时间应对（dealing with）多件事情的能力\n并行（parallel）是同一时间动手做（doing）多件事情的能力"}],"title":"并发与并行","type":5},{"date":"2021-11-16 10:54:05","docid":0,"fillcolor":"ffffed99","id":523,"originaltext":"以调用方角度来讲，如果需要等待结果返回，才能继续运行就是同步不需要等待结果返回，就能继续运行就是异步","page":9,"textblocks":[{"first":[52.35893249511719,471.67279052734375,9.753898620605469,12.5],"last":[260.19134521484375,509.945556640625,9.75390625,12.5],"length":52,"rects":[[52.35893249511719,471.67279052734375,107.29290771484375,12.5],[74.86717987060547,494.9396057128906,185.32416534423828,12.5],[74.86717987060547,509.945556640625,195.07807159423828,12.5]],"start":128,"text":"以调用方角度来讲，如果\n需要等待结果返回，才能继续运行就是同步\n不需要等待结果返回，就能继续运行就是异步"}],"title":"应用:异步调用","type":5},{"date":"2021-11-16 10:53:56","docid":0,"fillcolor":"ffffed99","id":522,"originaltext":"2) 结论 1. 单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu ，不至于一个线程总占用 cpu，别的线程没法干活2. 多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的【阿姆达尔定律】）也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义3. IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化","page":10,"textblocks":[{"first":[52.36793518066406,381.138427734375,5.569477081298828,12.5],"last":[437.8293151855469,523.9013061523438,9.75390625,13.5],"length":333,"rects":[[52.36793518066406,381.138427734375,492.0602264404297,12.5],[64.53705596923828,403.04803466796875,470.94029998779297,14.5],[74.87693786621094,418.05401611328125,233.35984802246094,14.5],[64.53630065917969,438.4128723144531,324.63169860839844,13.5],[97.3769302368164,458.9244384765625,438.92574310302734,12.5],[97.3769302368164,473.9304504394531,195.07808685302734,12.5],[97.3769302368164,488.93719482421875,321.87886810302734,12.5],[64.52804565429688,509.1953125,474.2308654785156,12.5],[74.86793518066406,523.9013061523438,372.7152862548828,13.5]],"start":290,"text":"2) 结论 \n1. 单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用\ncpu ，不至于一个线程总占用 cpu，别的线程没法干活\n2. 多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的\n有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任\n务都能拆分（参考后文的【阿姆达尔定律】）\n也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义\n3. IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一\n直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化"}],"title":"应用:效率提升","type":5}],"originaltext":"进程与线程的相关概念","page":5,"textblocks":[{"first":[76.99653625488281,196.06268310546875,14.630851745605469,17.5],"last":[135.5199432373047,196.06268310546875,14.630844116210938,17.5],"length":5,"rects":[[76.99653625488281,196.06268310546875,73.15425109863281,17.5]],"start":16,"text":"进程与线程"}],"type":5},{"date":"2021-11-16 10:58:00","docid":0,"fillcolor":"ffffed99","folded":false,"id":533,"markups":[{"date":"2021-11-16 10:53:33","docid":0,"fillcolor":"ffffed99","id":518,"originaltext":"直接使用 Thread","page":10,"textblocks":[{"first":[101.12767791748047,736.7908325195312,12.192375183105469,14.5],"last":[188.00051879882812,736.7908325195312,7.7177734375,14.5],"length":11,"rects":[[101.12767791748047,736.7908325195312,94.59061431884766,14.5]],"start":686,"text":"直接使用 Thread"}],"type":5},{"date":"2021-11-16 10:53:23","docid":0,"fillcolor":"ffffed99","id":517,"originaltext":"使用 Runnable 配合 Thread","page":11,"textblocks":[{"first":[101.12767791748047,463.02532958984375,12.192375183105469,15.5],"last":[252.3762664794922,463.02532958984375,7.7177886962890625,15.5],"length":21,"rects":[[101.12767791748047,463.02532958984375,158.96637725830078,15.5]],"start":19,"text":"使用 Runnable 配合 Thread"}],"type":5},{"date":"2021-11-16 10:53:08","docid":0,"fillcolor":"ffffed99","id":516,"originaltext":"小结方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了用 Runnable 更容易与线程池等高级 API 配合用 Runnable 让任务类脱离了 Thread 继承体系，更灵活","page":12,"textblocks":[{"first":[52.35893249511719,512.1949462890625,9.753898620605469,12.5],"last":[306.64837646484375,565.1685180664062,9.75390625,13.5],"length":99,"rects":[[52.35893249511719,512.1949462890625,19.507797241210938,12.5],[74.86717987060547,534.45654296875,289.3007278442383,13.5],[74.86717987060547,550.1625366210938,195.0307388305664,13.5],[74.86717987060547,565.1685180664062,241.53510284423828,13.5]],"start":98,"text":"小结\n方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了\n用 Runnable 更容易与线程池等高级 API 配合\n用 Runnable 让任务类脱离了 Thread 继承体系，更灵活"}],"type":5},{"date":"2021-11-16 10:52:24","docid":0,"id":514,"linecolor":"ffd01a11","linewidth":7,"originaltext":"底层Thread使用了代理模式，若构造方法中传入Runnable对象，那么就会赋值Thread创建的Runnable，并且底层调用run方法的时候，会查看Thread的Runnable是否为null，不为null就调用Runnable重写的Run方法","page":12,"rect":[280.079991678715,446.99998539090166,529.9600126113894,523.7200124626162],"type":11},{"date":"2021-11-16 10:52:54","docid":0,"fillcolor":"ffffed99","id":515,"originaltext":"FutureTask 配合 Thread","page":13,"textblocks":[{"first":[101.127685546875,103.6241683959961,6.693611145019531,15.5],"last":[234.32254028320312,103.6241683959961,7.7177734375,15.5],"length":20,"rects":[[101.127685546875,103.6241683959961,140.91262817382812,15.5]],"start":8,"text":"FutureTask 配合 Thread"}],"type":5},{"date":"2021-11-16 11:02:33","docid":0,"fillcolor":"ffffed99","id":535,"originaltext":"查看进程线程的方法","page":14,"textblocks":[{"first":[76.99653625488281,150.295166015625,14.630851745605469,17.5],"last":[194.04331970214844,150.295166015625,14.630844116210938,17.5],"length":9,"rects":[[76.99653625488281,150.295166015625,131.67762756347656,17.5]],"start":12,"text":"查看进程线程的方法"}],"title":"不同系统下查看线程步骤","type":5},{"date":"2021-11-16 11:03:23","docid":0,"fillcolor":"ffffed99","id":536,"originaltext":" 原理之线程运行","page":14,"textblocks":[{"first":[84.99810791015625,761.8023681640625,3.8040237426757812,17.5],"last":[176.55833435058594,761.8023681640625,14.630844116210938,17.5],"length":8,"rects":[[84.99810791015625,761.8023681640625,106.19107055664062,17.5]],"start":524,"text":" 原理之线程运行"}],"title":"线程原理概念","type":5},{"date":"2021-11-16 11:04:30","docid":0,"fillcolor":"ffffed99","folded":true,"id":538,"markups":[{"date":"2021-11-16 11:04:10","docid":0,"fillcolor":"ffffed99","id":537,"originaltext":"其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。","page":15,"textblocks":[{"first":[250.18685913085938,104.524169921875,9.75390625,13.5],"last":[169.40499877929688,119.5301513671875,9.75390625,13.5],"length":43,"rects":[[250.18685913085938,104.524169921875,282.8632507324219,13.5],[52.35818099975586,119.5301513671875,126.80072402954102,13.5]],"start":69,"text":"其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟\n机就会为其分配一块栈内存。"}],"type":5},{"date":"2021-11-16 11:04:39","docid":0,"fillcolor":"ffffed99","id":539,"originaltext":"每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法","page":15,"textblocks":[{"first":[74.86717987060547,143.79168701171875,9.753898620605469,12.5],"last":[338.22259521484375,158.79766845703125,9.75390625,12.5],"length":63,"rects":[[74.86717987060547,143.79168701171875,311.6499710083008,12.5],[74.86717987060547,158.79766845703125,273.1093215942383,12.5]],"start":113,"text":"每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存\n每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法"}],"title":"栈帧与活动栈帧","type":5}],"originaltext":"栈与栈帧","page":15,"textblocks":[{"first":[52.35818099975586,56.25372314453125,12.192371368408203,15.5],"last":[88.935302734375,56.25372314453125,12.192375183105469,15.5],"length":4,"rects":[[52.35818099975586,56.25372314453125,48.76949691772461,15.5]],"start":0,"text":"栈与栈帧"}],"type":5},{"date":"2021-11-16 11:05:06","docid":0,"fillcolor":"ffffed99","folded":true,"id":540,"markups":[{"date":"2021-11-16 11:05:49","docid":0,"fillcolor":"ffffed99","id":542,"originaltext":"因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码线程的 cpu 时间片用完垃圾回收有更高优先级的线程需要运行线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法","page":15,"textblocks":[{"first":[52.35818099975586,231.22708129882812,9.753898620605469,14.5],"last":[406.24542236328125,299.5073547363281,9.75390625,14.5],"length":127,"rects":[[52.35818099975586,231.22708129882812,333.7995948791504,14.5],[74.86717987060547,254.588623046875,99.70589447021484,13.5],[74.86717987060547,269.5946044921875,39.015594482421875,12.5],[74.86717987060547,284.60137939453125,126.80074310302734,13.5],[74.86717987060547,299.5073547363281,341.1321487426758,14.5]],"start":211,"text":"因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码\n线程的 cpu 时间片用完\n垃圾回收\n有更高优先级的线程需要运行\n线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法"}],"title":"线程上下切换概念","type":5},{"date":"2021-11-16 11:06:39","docid":0,"fillcolor":"ffffed99","id":544,"originaltext":"当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的","page":15,"textblocks":[{"first":[52.35818099975586,323.1163635253906,9.753898620605469,12.5],"last":[513.6427001953125,338.12237548828125,9.75390625,12.5],"length":125,"rects":[[52.35818099975586,323.1163635253906,483.39731216430664,12.5],[52.35818099975586,338.12237548828125,471.03842544555664,12.5]],"start":339,"text":"当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念\n就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的"}],"title":"涉及程序计数器","type":5},{"date":"2021-11-16 11:06:55","docid":0,"fillcolor":"ffffed99","id":545,"originaltext":"状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等Context Switch 频繁发生会影响性能","page":15,"textblocks":[{"first":[74.86717987060547,360.63287353515625,9.753898620605469,12.5],"last":[222.7521209716797,376.1388854980469,9.75390625,12.5],"length":64,"rects":[[74.86717987060547,360.63287353515625,380.4022903442383,12.5],[74.86717987060547,376.1388854980469,157.63884735107422,12.5]],"start":465,"text":"状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等\nContext Switch 频繁发生会影响性能"}],"title":"其他信息","type":5},{"CL":[164.16000391387948,265.920006340027,164.04000341033944,215.54000512695325,144.04000341033944,215.54000512695325],"date":"2021-11-16 15:14:12","docid":0,"id":595,"linecolor":"ffd01a11","linewidth":7,"originaltext":"线程2到线程1算一次上下文切换","page":42,"rect":[0,198.72000473785414,145.04000341033944,233.36000551605235],"title":"上下文切换","type":9}],"originaltext":"线程上下文切换","page":15,"textblocks":[{"first":[52.35818099975586,204.86720275878906,12.192371368408203,16.5],"last":[125.5124282836914,204.86720275878906,12.192375183105469,16.5],"length":7,"rects":[[52.35818099975586,204.86720275878906,85.34662246704102,16.5]],"start":179,"text":"线程上下文切换"}],"type":5},{"date":"2021-11-16 11:07:13","docid":0,"fillcolor":"ffffed99","id":546,"originaltext":"常见方法","page":15,"textblocks":[{"first":[76.99653625488281,400.90057373046875,14.630851745605469,17.5],"last":[120.88909149169922,400.90057373046875,14.630851745605469,17.5],"length":4,"rects":[[76.99653625488281,400.90057373046875,58.523406982421875,17.5]],"start":534,"text":"常见方法"}],"type":5},{"date":"2021-11-16 11:07:29","docid":0,"fillcolor":"ffffed99","folded":true,"id":547,"markups":[{"date":"2021-11-16 11:09:44","docid":0,"id":548,"linecolor":"ffd01a11","linewidth":7,"originaltext":"真正启动线程的是start方法调用的start0方法，由JVM视时间片调用，它会开启线程执行run方法","page":18,"rect":[371.39998893141774,194.3999942064287,557.8000132751467,260.2000061798097],"type":11}],"originaltext":"直接调用 run 是在主线程中执行了 run，没有启动新的线程使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码","page":18,"textblocks":[{"first":[74.86717987060547,213.27110290527344,9.753898620605469,13.5],"last":[346.242431640625,227.57708740234375,9.75390625,13.5],"length":68,"rects":[[74.86717987060547,213.27110290527344,254.07263946533203,13.5],[74.86717987060547,227.57708740234375,281.12915802001953,13.5]],"start":47,"text":"直接调用 run 是在主线程中执行了 run，没有启动新的线程\n使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码"}],"title":"start方法和run方法","type":5},{"date":"2021-11-16 11:10:02","docid":0,"fillcolor":"ffffed99","folded":true,"id":549,"markups":[{"date":"2021-11-16 11:10:10","docid":0,"fillcolor":"ffffed99","id":550,"originaltext":"sleep 1. 调用 sleep 会让当前线程从 Running  进入 Timed Waiting 状态（阻塞）2. 其它线程可以使用  interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException 3. 睡眠结束后的线程未必会立刻得到执行4. 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性","page":18,"textblocks":[{"first":[52.35818099975586,308.35858154296875,6.059612274169922,10.5],"last":[362.98541259765625,376.0387268066406,9.75390625,14.5],"length":204,"rects":[[52.35818099975586,308.35858154296875,492.6935157775879,10.5],[64.52655029296875,331.8185119628906,314.3614807128906,13.5],[64.52655029296875,346.8267517089844,460.23846435546875,13.5],[64.53404998779297,362.13275146484375,176.15625762939453,12.5],[64.53404998779297,376.0387268066406,308.2052688598633,14.5]],"start":137,"text":"sleep \n1. 调用 sleep 会让当前线程从 Running  进入 Timed Waiting 状态（阻塞）\n2. 其它线程可以使用  interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException \n3. 睡眠结束后的线程未必会立刻得到执行\n4. 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性"}],"title":"sleep","type":5},{"date":"2021-11-16 11:10:19","docid":0,"fillcolor":"ffffed99","id":551,"originaltext":"yield 1. 调用 yield 会让当前线程从 Running 进入 Runnable  就绪状态，然后调度执行其它线程2. 具体的实现依赖于操作系统的任务调度器","page":18,"textblocks":[{"first":[52.36493682861328,404.39923095703125,6.937461853027344,12.5],"last":[240.68954467773438,442.8651428222656,9.75390625,13.5],"length":85,"rects":[[52.36493682861328,404.39923095703125,492.6935348510742,12.5],[64.5333023071289,427.05914306640625,379.2152328491211,14.5],[64.5333023071289,442.8651428222656,185.91014862060547,13.5]],"start":342,"text":"yield \n1. 调用 yield 会让当前线程从 Running 进入 Runnable  就绪状态，然后调度执行其它线程\n2. 具体的实现依赖于操作系统的任务调度器"}],"title":"yield","type":5}],"originaltext":" sleep 与 yield","page":18,"textblocks":[{"first":[73.23640441894531,275.2477722167969,3.8040237426757812,19.5],"last":[163.4498291015625,275.2477722167969,9.261322021484375,19.5],"length":14,"rects":[[73.23640441894531,275.2477722167969,99.47474670410156,19.5]],"start":121,"text":" sleep 与 yield"}],"type":5},{"date":"2021-11-16 11:10:42","docid":0,"fillcolor":"ffffed99","id":555,"originaltext":"线程优先级 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用","page":18,"textblocks":[{"first":[52.36418533325195,489.93463134765625,12.192378997802734,15.5],"last":[469.3569641113281,531.7042846679688,9.75390625,12.5],"length":98,"rects":[[52.36418533325195,489.93463134765625,492.69428634643555,15.5],[74.86717987060547,516.6983032226562,398.28568267822266,12.5],[74.86717987060547,531.7042846679688,404.24369049072266,12.5]],"start":430,"text":"线程优先级 \n线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它\n如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用"}],"title":"线程优先级","type":5},{"date":"2021-11-16 11:12:01","docid":0,"fillcolor":"ffffed99","folded":true,"id":556,"markups":[{"date":"2021-11-16 11:12:13","docid":0,"fillcolor":"ffffed99","id":558,"originaltext":"join 方法","page":19,"textblocks":[{"first":[77.0404281616211,193.46286010742188,4.462409973144531,19.5],"last":[123.01018524169922,193.46286010742188,14.630851745605469,19.5],"length":7,"rects":[[77.0404281616211,193.46286010742188,60.600608825683594,19.5]],"start":23,"text":"join 方法"}],"type":5}],"originaltext":"应用之效率","page":19,"textblocks":[{"first":[65.33612823486328,167.3011474609375,12.192375183105469,15.5],"last":[114.10562896728516,167.3011474609375,12.192375183105469,15.5],"length":5,"rects":[[65.33612823486328,167.3011474609375,60.961875915527344,15.5]],"start":5,"text":"应用之效率"}],"type":5},{"date":"2021-11-16 11:12:53","docid":0,"fillcolor":"ffffed99","folded":true,"id":559,"markups":[{"date":"2021-11-16 11:13:29","docid":0,"fillcolor":"ffffed99","id":560,"originaltext":"需要等待结果返回，才能继续运行就是同步不需要等待结果返回，就能继续运行就是异步","page":20,"textblocks":[{"first":[74.86717987060547,56.75311279296875,9.753898620605469,12.5],"last":[260.19134521484375,71.7591552734375,9.75390625,12.5],"length":40,"rects":[[74.86717987060547,56.75311279296875,185.32416534423828,12.5],[74.86717987060547,71.7591552734375,195.07807159423828,12.5]],"start":38,"text":"需要等待结果返回，才能继续运行就是同步\n不需要等待结果返回，就能继续运行就是异步"}],"title":"同步异步","type":5}],"originaltext":"应用之同步","page":19,"textblocks":[{"first":[62.15034866333008,735.3894653320312,12.192378997802734,15.5],"last":[110.91985321044922,735.3894653320312,12.192375183105469,15.5],"length":5,"rects":[[62.15034866333008,735.3894653320312,60.96187973022461,15.5]],"start":199,"text":"应用之同步"}],"type":5},{"date":"2021-11-16 11:13:50","docid":0,"fillcolor":"ffffed99","folded":true,"id":561,"markups":[{"date":"2021-11-16 11:16:01","docid":0,"fillcolor":"ffffed99","id":562,"originaltext":"打断 sleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态打断 sleep 的线程, 会清空打断状态","page":23,"textblocks":[{"first":[52.35818099975586,682.0669555664062,12.192371368408203,16.5],"last":[193.67721557617188,732.035888671875,9.75390625,12.5],"length":62,"rects":[[52.35818099975586,682.0669555664062,492.6942481994629,16.5],[52.35893249511719,709.52685546875,156.06243896484375,12.5],[52.35893249511719,732.035888671875,151.0721893310547,12.5]],"start":42,"text":"打断 sleep，wait，join 的线程 \n这几个方法都会让线程进入阻塞状态\n打断 sleep 的线程, 会清空打断状态"}],"type":5},{"annotations":[{"content":"b1a09c56984f6065811526dc64e0d542.png","style":1}],"date":"2021-11-16 11:16:27","docid":0,"fillcolor":"ffffed99","id":563,"originaltext":"模式之两阶段终止","page":25,"textblocks":[{"first":[62.14809799194336,56.25372314453125,12.192371368408203,15.5],"last":[147.49472045898438,56.25372314453125,12.1923828125,15.5],"length":8,"rects":[[62.14809799194336,56.25372314453125,97.53900527954102,15.5]],"start":2,"text":"模式之两阶段终止"}],"type":5},{"date":"2021-11-16 11:17:47","docid":0,"fillcolor":"ffffed99","id":565,"originaltext":"打断 park 线程 打断 park 线程, 不会清空打断状态","page":25,"textblocks":[{"first":[52.35818099975586,426.15386962890625,12.192371368408203,15.5],"last":[190.10279846191406,452.9137878417969,9.75390625,12.5],"length":32,"rects":[[52.35818099975586,426.15386962890625,492.6935157775879,15.5],[52.35818099975586,452.9137878417969,147.4985237121582,12.5]],"start":42,"text":"打断 park 线程 \n打断 park 线程, 不会清空打断状态"}],"title":"打断park线程","type":5},{"date":"2021-11-16 11:25:05","docid":0,"id":568,"linecolor":"ffd01a11","linewidth":7,"originaltext":"interrupt打断sleep,wait,join线程会抛出InterruptedException异常并清空打断状态\n正常执行的线程只会添加打断状态\npark状态线程，被打断，不会清空打断状态，被标记过后park失效","page":26,"rect":[288.35999091291444,473.35998607301747,593.3200141220096,568.4000135040283],"type":11},{"date":"2021-11-16 11:27:13","docid":0,"id":569,"linecolor":"ffd01a11","linewidth":7,"originaltext":"interrupted()：返回当前线程打断状态，然后清空状态\nIsinterrupted()：返回当前线程打断状态\ninterrupt：打断标志设置为true","page":26,"rect":[358.7000212091209,720.0999887102846,572.2000136184696,797.8000189971928],"type":11}],"originaltext":"interrupt 方法详解","page":23,"textblocks":[{"first":[77.0404281616211,653.4561767578125,4.462409973144531,18.5],"last":[192.22909545898438,653.4561767578125,14.630844116210938,18.5],"length":14,"rects":[[77.0404281616211,653.4561767578125,129.81951141357422,18.5]],"start":26,"text":"interrupt 方法详解"}],"type":5},{"date":"2021-11-16 11:28:28","docid":0,"fillcolor":"ffffed99","folded":false,"id":570,"markups":[{"date":"2021-11-16 11:28:48","docid":0,"fillcolor":"ffffed99","id":571,"originaltext":"垃圾回收器线程就是一种守护线程Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求","page":27,"textblocks":[{"first":[89.1236343383789,593.2288818359375,9.753898620605469,13.5],"last":[176.9087677001953,623.2416381835938,9.75390625,13.5],"length":94,"rects":[[89.1236343383789,593.2288818359375,146.3085708618164,13.5],[89.1236343383789,607.1356201171875,434.9721908569336,14.5],[89.1236343383789,623.2416381835938,97.5390396118164,13.5]],"start":258,"text":"垃圾回收器线程就是一种守护线程\nTomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等\n待它们处理完当前请求"}],"title":"守护示例","type":5}],"originaltext":"主线程与守护线程 默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。","page":27,"textblocks":[{"first":[85.3848876953125,196.0611572265625,14.630851745605469,17.5],"last":[344.9760437011719,239.577392578125,9.75390625,13.5],"length":95,"rects":[[85.3848876953125,196.0611572265625,460.301513671875,17.5],[52.35893249511719,224.57135009765625,489.04127502441406,13.5],[52.35893249511719,239.577392578125,302.3710174560547,13.5]],"start":17,"text":"主线程与守护线程 \n默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守\n护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。"}],"title":"主线程和守护线程","type":5},{"date":"2021-11-16 11:29:11","docid":0,"fillcolor":"ffffed99","id":572,"originaltext":"五种状态 这是从 操作系统 层面来描述的","page":27,"textblocks":[{"first":[85.3856430053711,671.5123291015625,14.630851745605469,17.5],"last":[174.4590301513672,699.5225219726562,9.75390625,13.5],"length":21,"rects":[[85.3856430053711,671.5123291015625,460.3014907836914,17.5],[52.35968780517578,699.5225219726562,131.8532485961914,13.5]],"start":360,"text":"五种状态 \n这是从 操作系统 层面来描述的"}],"title":"五种状态","type":5},{"date":"2021-11-16 11:29:29","docid":0,"fillcolor":"ffffed99","id":573,"originaltext":"六种状态 这是从 Java API 层面来描述的","page":28,"textblocks":[{"first":[85.3848876953125,581.4784545898438,14.630851745605469,17.5],"last":[174.61659240722656,611.9886474609375,9.75390625,12.5],"length":25,"rects":[[85.3848876953125,581.4784545898438,460.301513671875,17.5],[52.35893249511719,611.9886474609375,132.01156616210938,12.5]],"start":346,"text":"六种状态 \n这是从 Java API 层面来描述的"}],"title":"六种状态","type":5},{"date":"2021-11-16 11:29:48","docid":0,"fillcolor":"ffffed99","id":574,"originaltext":"本章小结","page":31,"textblocks":[{"first":[52.35818099975586,342.8747863769531,14.630847930908203,18.5],"last":[96.250732421875,342.8747863769531,14.630851745605469,18.5],"length":4,"rects":[[52.35818099975586,342.8747863769531,58.52340316772461,18.5]],"start":165,"text":"本章小结"}],"title":"总结","type":5}],"originaltext":"线程的创建和底层的不同","page":10,"textblocks":[{"first":[71.40755462646484,570.82373046875,5.6499481201171875,20.5],"last":[128.88653564453125,570.82373046875,17.069320678710938,20.5],"length":7,"rects":[[71.40755462646484,570.82373046875,74.54830169677734,20.5]],"start":629,"text":"Java 线程"}],"type":5},{"date":"2021-11-16 11:30:16","docid":0,"fillcolor":"ffffed99","folded":false,"id":575,"markups":[{"date":"2021-11-16 14:37:22","docid":0,"folded":true,"id":577,"linecolor":"ffd01a11","linewidth":7,"markups":[{"date":"2021-11-16 14:39:03","docid":0,"id":578,"linecolor":"ffd01a11","linewidth":7,"originaltext":"自增和自减jvm由4条指令","page":34,"rect":[142.08000338745126,749.2800178642275,276.0400065574647,768.0400182876591],"type":11},{"date":"2021-11-16 14:40:38","docid":0,"id":579,"linecolor":"ffd01a11","linewidth":7,"originaltext":"在线程2没有写回的过程中，因为时间片用完，导致上下文切换","page":37,"rect":[391.20000932693506,169.9200040512086,533.320012691498,218.44000518417369],"type":11},{"date":"2021-11-16 14:41:34","docid":0,"id":580,"linecolor":"ffd01a11","linewidth":7,"originaltext":"线程1完成写回操作，时间片用完，上下文切换，线程2操作，覆盖写回的值","page":37,"rect":[234.24000558471693,313.4400074729921,371.560008834839,361.9600086059572],"type":11},{"date":"2021-11-16 14:44:21","docid":0,"id":581,"linecolor":"ffd01a11","linewidth":7,"originaltext":"根本原因：线程上下文切换导致的指令交错","page":38,"rect":[165.12000393676766,544.8000129890445,401.80000955581687,561.6400133666995],"type":11}],"originaltext":"1、将主内存的i读入线程\n2、自增或自减操作\n3、写回主存","page":35,"rect":[449.7600107231142,360.48000859451315,578.4400137672426,409.0000097274782],"title":"自增操作","type":11},{"date":"2021-11-16 14:47:19","docid":0,"fillcolor":"ffffed99","folded":true,"id":582,"markups":[{"date":"2021-11-16 14:47:30","docid":0,"fillcolor":"ffffed99","id":583,"originaltext":"问题出在多个线程访问共享资源多个线程读共享资源其实也没有问题在多个线程对共享资源读写操作时发生指令交错，就会出现问题","page":38,"textblocks":[{"first":[74.86717987060547,623.2416381835938,9.753898620605469,12.5],"last":[360.7323303222656,657.7561645507812,9.75390625,12.5],"length":60,"rects":[[74.86717987060547,623.2416381835938,136.55463409423828,12.5],[97.3769302368164,642.7501831054688,156.06244659423828,12.5],[97.3769302368164,657.7561645507812,273.1093063354492,12.5]],"start":225,"text":"问题出在多个线程访问共享资源\n多个线程读共享资源其实也没有问题\n在多个线程对共享资源读写操作时发生指令交错，就会出现问题"}],"title":"问题根源","type":5},{"date":"2021-11-16 14:48:25","docid":0,"fillcolor":"ffffed99","id":584,"originaltext":"一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区","page":38,"textblocks":[{"first":[74.86717987060547,678.0150146484375,9.753898620605469,12.5],"last":[396.7458801269531,678.0150146484375,9.75390625,12.5],"length":34,"rects":[[74.86717987060547,678.0150146484375,331.63260650634766,12.5]],"start":286,"text":"一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区"}],"title":"概念","type":5}],"originaltext":"临界区","page":38,"textblocks":[{"first":[52.35818099975586,576.3221435546875,12.192371368408203,15.5],"last":[76.74292755126953,576.3221435546875,12.192375183105469,15.5],"length":3,"rects":[[52.35818099975586,576.3221435546875,36.57712173461914,15.5]],"start":184,"text":"临界区"}],"type":5},{"date":"2021-11-16 14:50:33","docid":0,"fillcolor":"ffffed99","folded":true,"id":585,"markups":[{"date":"2021-11-16 14:50:36","docid":0,"fillcolor":"ffffed99","id":586,"originaltext":"多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件","page":39,"textblocks":[{"first":[52.35818099975586,335.12042236328125,9.753898620605469,12.5],"last":[462.0220031738281,335.12042236328125,9.75390625,12.5],"length":43,"rects":[[52.35818099975586,335.12042236328125,419.41772842407227,12.5]],"start":27,"text":"多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件"}],"title":"概念","type":5},{"date":"2021-11-16 14:52:53","docid":0,"id":587,"linecolor":"ffd01a11","linewidth":7,"originaltext":"有临界区才能有竞态条件，临界区无法预测结果就称为竞态条件","page":39,"rect":[203.04000484085094,310.56000740432756,529.9294502880913,329.498507019474],"type":11}],"originaltext":"竞态条件","page":39,"textblocks":[{"first":[52.35818099975586,308.4605407714844,12.192371368408203,15.5],"last":[88.935302734375,308.4605407714844,12.192375183105469,15.5],"length":4,"rects":[[52.35818099975586,308.4605407714844,48.76949691772461,15.5]],"start":6,"text":"竞态条件"}],"type":5},{"date":"2021-11-16 14:56:06","docid":0,"fillcolor":"ffffed99","folded":true,"id":588,"markups":[{"date":"2021-11-16 14:56:14","docid":0,"fillcolor":"ffffed99","id":589,"originaltext":"阻塞式的解决方案：synchronized，Lock非阻塞式的解决方案：原子变量","page":39,"textblocks":[{"first":[74.86717987060547,460.0745849609375,9.753898620605469,14.5],"last":[201.6679229736328,475.88134765625,9.75390625,13.5],"length":41,"rects":[[74.86717987060547,460.0745849609375,178.58490753173828,14.5],[74.86717987060547,475.88134765625,136.55464935302734,13.5]],"start":133,"text":"阻塞式的解决方案：synchronized，Lock\n非阻塞式的解决方案：原子变量"}],"title":"两类解决方案","type":5},{"date":"2021-11-16 14:57:04","docid":0,"fillcolor":"ffffed99","folded":true,"id":590,"markups":[{"date":"2021-11-16 14:58:28","docid":0,"fillcolor":"ffffed99","id":592,"originaltext":"虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点","page":39,"textblocks":[{"first":[66.61388397216797,574.1209716796875,9.753898620605469,14.5],"last":[430.51031494140625,612.7381591796875,9.75390625,12.5],"length":122,"rects":[[66.61388397216797,574.1209716796875,381.2830581665039,14.5],[89.1236343383789,597.732177734375,331.63277435302734,12.5],[89.1236343383789,612.7381591796875,351.14058685302734,12.5]],"start":316,"text":"虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：\n互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码\n同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点"}],"type":5},{"date":"2021-11-16 15:02:22","docid":0,"fillcolor":"ffffed99","id":593,"originaltext":"你可以做这样的类比：synchronized(对象) 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人进行计算，线程 t1，t2 想象成两个人当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行 count++ 代码这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切换，阻塞住了这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦），这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才能开门进入当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count-- 代码","page":41,"textblocks":[{"first":[52.35818099975586,56.75311279296875,9.753898620605469,12.5],"last":[440.7682189941406,228.22586059570312,9.75390625,14.5],"length":459,"rects":[[52.35818099975586,56.75311279296875,97.53900527954102,12.5],[78.61868286132812,78.96214294433594,457.4287414550781,13.5],[74.86717987060547,93.96812438964844,159.63236236572266,13.5],[74.86717987060547,108.97483825683594,461.7676467895508,13.5],[78.61868286132812,128.26202392578125,59.56108093261719,8.778518676757812],[74.86717987060547,138.98765563964844,464.65491485595703,13.5],[74.86943817138672,155.29364013671875,58.523399353027344,12.5],[74.86717987060547,168.20034790039062,464.9341506958008,14.5],[74.8664321899414,184.306396484375,466.36775970458984,12.5],[74.8664321899414,199.3123779296875,48.769493103027344,12.5],[74.86717987060547,213.21914672851562,459.33594512939453,14.5],[74.86793518066406,228.22586059570312,375.65419006347656,14.5]],"start":0,"text":"你可以做这样的类比：\nsynchronized(对象) 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人\n进行计算，线程 t1，t2 想象成两个人\n当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行 \ncount++ 代码\n这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切\n换，阻塞住了\n这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦），\n这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才\n能开门进入\n当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥\n匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count-- 代码"}],"title":"底层原理","type":5},{"date":"2021-11-16 15:04:51","docid":0,"id":594,"linecolor":"ffd01a11","linewidth":7,"originaltext":"就算是t1线程使用完时间片也会拿住锁，只有等执行完锁住的代码块才放开锁，并唤醒其他全部线程让他们执行","page":41,"rect":[63.36000151062015,270.24000644302384,436.36001037979145,308.2000073242189],"type":11}],"originaltext":"synchronized，来解决上述问题，即俗称的【对象锁】","page":39,"textblocks":[{"first":[188.91278076171875,498.3406066894531,4.6526031494140625,14.500030517578125],"last":[415.05780029296875,498.3406066894531,9.75390625,14.500030517578125],"length":30,"rects":[[188.91278076171875,498.3406066894531,235.89892578125,14.500030517578125]],"start":189,"text":"synchronized，来解决上述问题，即俗称的【对象锁】"}],"title":"synchronized解决方案","type":5}],"originaltext":"解决方案","page":39,"textblocks":[{"first":[177.59976196289062,381.7911376953125,14.630844116210938,19.5],"last":[221.49229431152344,381.7911376953125,14.630844116210938,19.5],"length":4,"rects":[[177.59976196289062,381.7911376953125,58.52337646484375,19.5]],"start":90,"text":"解决方案"}],"type":5},{"date":"2021-11-22 11:54:57","docid":0,"fillcolor":"ffffed99","folded":true,"id":694,"markups":[{"date":"2021-11-16 17:21:03","docid":0,"fillcolor":"ffffed99","id":597,"originaltext":"synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。","page":42,"textblocks":[{"first":[52.35818099975586,721.1834716796875,4.652610778808594,14.5],"last":[91.373779296875,737.2894897460938,9.753898620605469,13.5],"length":62,"rects":[[52.35818099975586,721.1834716796875,482.28024673461914,14.5],[52.35818099975586,737.2894897460938,48.76949691772461,13.5]],"start":260,"text":"synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切\n换所打断。"}],"title":"synchronized的重要性","type":5},{"date":"2021-11-16 17:33:50","folded":true,"id":603,"linecolor":"ff59c6ff","markups":[{"date":"2021-11-16 17:27:53","docid":0,"id":599,"linecolor":"ff000000","linewidth":7,"originaltext":"将循环也加入到原子性中不会被其他线程打断和分割","page":43,"rect":[59.39999822974204,121.19999638795873,290.79999136328706,139.5999958693982],"type":11},{"date":"2021-11-16 17:31:14","docid":0,"id":600,"linecolor":"ff000000","linewidth":7,"originaltext":"使用的是两个对象锁，所以保护不了","page":43,"rect":[60.59999819397933,161.9999951720239,257.80000612258925,184.8400043830873],"type":11},{"date":"2021-11-16 17:32:09","docid":0,"id":601,"linecolor":"ff000000","linewidth":7,"originaltext":"如果没有加，那么就不会去尝试获取锁，会直接操作共享资源","page":43,"rect":[61.919998257636934,218.75999340319652,240.3199930005074,249.5599925448896],"type":11}],"page":-1,"title":"错误使用","type":7},{"date":"2021-11-16 17:57:44","docid":0,"id":604,"linecolor":"ffff8280","linewidth":7,"originaltext":"将synchronized加在成员方法上，那么锁就是创建的实例对象，this指向实例对象","page":44,"rect":[282.59999157786393,407.3999878585342,500.7999851047997,437.19998700022734],"type":11},{"date":"2021-11-16 17:58:59","docid":0,"id":605,"linecolor":"ffff8280","linewidth":7,"originaltext":"将synchronized加在静态方法上，那么锁就是当前的类，this指向类","page":44,"rect":[284.99999150633835,628.7999812603001,464.79998617768325,658.5999804019933],"type":11},{"date":"2021-11-16 18:04:31","docid":0,"id":607,"imgfile":"32e6f86fa2b755a89011b0444430b89d.png","linecolor":"ff5ac6ff","linewidth":2,"page":45,"rect":[49.199998533725775,118.79999645948419,425.3999873220924,118.79999645948419],"type":1},{"date":"2021-11-16 18:05:22","docid":0,"id":608,"linecolor":"ffff8280","linewidth":7,"originaltext":"总结：就是将线程当作人，如果没加入锁，那么代码块就不会保证原子性，线程可以胡乱使用","page":45,"rect":[49.19999853372576,129.5999961376191,453.7999865353111,148.3999956369401],"type":11},{"CL":[431.5200102882387,397.4400094757082,431.87997893285797,468.62001119303716,451.87997893285797,468.62001119303716],"date":"2021-11-16 15:16:25","docid":0,"id":596,"linecolor":"ffd01a11","linewidth":7,"originaltext":"线程执行完synchronized会自动释放锁，并唤醒其他全部线程","page":42,"rect":[451.87997893285797,444.36001062655464,594.999982297421,493.8800117595197],"type":9},{"date":"2021-11-16 18:05:46","docid":0,"fillcolor":"ffffed99","folded":true,"id":609,"markups":[{"date":"2021-11-16 18:16:17","docid":0,"id":610,"linecolor":"ffff8280","linewidth":7,"originaltext":"重点在于锁是哪个对象或者哪个类，他们是否要抢夺这个锁","page":45,"rect":[274.4399983356001,164.8799953694345,568.3600135269165,217.48000516128542],"type":11}],"originaltext":"线程八锁","page":45,"textblocks":[{"first":[94.34872436523438,153.54681396484375,12.192375183105469,15.5],"last":[130.92584228515625,153.54681396484375,12.1923828125,15.5],"length":4,"rects":[[94.34872436523438,153.54681396484375,48.769500732421875,15.5]],"start":76,"text":"线程八锁"}],"title":"","type":5}],"originaltext":"synchronized","page":40,"textblocks":[{"first":[52.35818099975586,84.0189208984375,6.059612274169922,10.5],"last":[125.3736343383789,84.0189208984375,7.717781066894531,10.5],"length":12,"rects":[[52.35818099975586,84.0189208984375,80.73323440551758,10.5]],"start":2,"text":"synchronized"}],"type":5},{"date":"2021-11-16 18:19:02","docid":0,"fillcolor":"ffffed99","folded":true,"id":611,"markups":[{"date":"2021-11-16 20:16:33","docid":0,"fillcolor":"ffffed99","folded":true,"id":612,"markups":[{"date":"2021-11-16 20:16:35","docid":0,"fillcolor":"ffffed99","id":613,"originaltext":"如果它们被共享了，根据它们的状态是否能够改变，又分两种情况如果只有读操作，则线程安全如果有读写操作，则这段代码是临界区，需要考虑线程安全","page":48,"textblocks":[{"first":[74.86717987060547,392.89801025390625,9.753898620605469,12.5],"last":[341.22454833984375,427.11260986328125,9.75390625,13.5],"length":70,"rects":[[74.86717987060547,392.89801025390625,282.8632278442383,12.5],[97.3769302368164,411.4065856933594,126.8007583618164,13.5],[97.3769302368164,427.11260986328125,253.60152435302734,13.5]],"start":50,"text":"如果它们被共享了，根据它们的状态是否能够改变，又分两种情况\n如果只有读操作，则线程安全\n如果有读写操作，则这段代码是临界区，需要考虑线程安全"}],"type":5},{"date":"2021-11-16 20:17:38","docid":0,"id":614,"linecolor":"ffff8280","linewidth":7,"originaltext":"存在临界区就要考虑线程安全","page":48,"rect":[361.7999892175201,423.5999873757366,492.199985390902,441.799986892939],"type":11},{"date":"2021-11-16 20:30:00","docid":0,"id":620,"linecolor":"ffff8280","linewidth":7,"originaltext":"因为成员变量属于实例对象和静态变量属于类，所以都存在于堆当中，容易被其他线程访问到","page":48,"rect":[369.5999885988237,321.71998845505726,518.9600123252872,402.32000954437274],"type":11}],"originaltext":"成员变量和静态变量是否线程安全？","page":48,"textblocks":[{"first":[52.35818099975586,345.8777770996094,12.192371368408203,15.5],"last":[235.24386596679688,345.8777770996094,12.1923828125,15.5],"length":16,"rects":[[52.35818099975586,345.8777770996094,195.07806777954102,15.5]],"start":17,"text":"成员变量和静态变量是否线程安全？"}],"type":5},{"date":"2021-11-16 20:17:46","docid":0,"fillcolor":"ffffed99","folded":true,"id":615,"markups":[{"date":"2021-11-16 20:17:57","docid":0,"fillcolor":"ffffed99","id":616,"originaltext":"局部变量是线程安全的","page":48,"textblocks":[{"first":[74.86717987060547,501.69378662109375,9.753898620605469,12.5],"last":[162.6522979736328,501.69378662109375,9.75390625,12.5],"length":10,"rects":[[74.86717987060547,501.69378662109375,97.53902435302734,12.5]],"start":136,"text":"局部变量是线程安全的"}],"type":5},{"date":"2021-11-16 20:18:01","docid":0,"fillcolor":"ffffed99","id":617,"originaltext":"但局部变量引用的对象则未必如果该对象没有逃离方法的作用访问，它是线程安全的如果该对象逃离方法的作用范围，需要考虑线程安全","page":48,"textblocks":[{"first":[74.86717987060547,521.2023315429688,9.753898620605469,12.5],"last":[311.96282958984375,555.4671630859375,9.75390625,13.5],"length":62,"rects":[[74.86717987060547,521.2023315429688,126.80074310302734,12.5],[97.3769302368164,540.46044921875,234.09371185302734,13.5],[97.3769302368164,555.4671630859375,224.33980560302734,13.5]],"start":147,"text":"但局部变量引用的对象则未必\n如果该对象没有逃离方法的作用访问，它是线程安全的\n如果该对象逃离方法的作用范围，需要考虑线程安全"}],"type":5},{"date":"2021-11-16 20:22:42","docid":0,"id":618,"linecolor":"ffff8280","linewidth":7,"originaltext":"局部变量存储在每个线程的栈中，只要没有被其他线程访问到，那就是线程安全的","page":48,"rect":[341.999989807606,493.7999852836136,519.3999845504765,523.5999844253067],"type":11},{"date":"2021-11-16 20:23:34","docid":0,"id":619,"linecolor":"ffff8280","linewidth":7,"originaltext":"引用变量存储地址，指向堆中，堆中的对象是线程共享的，只要被其他线程访问到，就要考虑线程安全问题","page":48,"rect":[342.59998978972465,537.5999839782718,535.2400127372745,596.6800142021182],"type":11},{"date":"2021-11-16 20:44:58","docid":0,"id":621,"linecolor":"ffff8280","linewidth":7,"originaltext":"推荐操作共享资源的方法使用final防止子类重写\n操作方法使用private防止子类调用","page":51,"rect":[326.3999902725222,637.7999809920793,553.0000131607059,693.6400165138248],"type":11},{"date":"2021-11-16 20:46:29","docid":0,"id":623,"linecolor":"ffff8280","linewidth":7,"originaltext":"一般局部变量逃离发生在继承上","page":51,"rect":[318.2399900779726,545.9999806380275,515.5600122680667,567.8800135154727],"type":11},{"date":"2021-11-16 20:45:33","docid":0,"fillcolor":"ffffed99","id":622,"originaltext":"从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】","page":53,"textblocks":[{"first":[66.61388397216797,300.2576599121094,9.753898620605469,14.5],"last":[449.9310302734375,300.2576599121094,9.75390625,14.5],"length":50,"rects":[[66.61388397216797,300.2576599121094,393.07105255126953,14.5]],"start":2,"text":"从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】"}],"type":5}],"originaltext":"局部变量是否线程安全？","page":48,"textblocks":[{"first":[52.35893249511719,474.9324035644531,12.192375183105469,15.5],"last":[174.28271484375,474.9324035644531,12.1923828125,15.5],"length":11,"rects":[[52.35893249511719,474.9324035644531,134.1161651611328,15.5]],"start":123,"text":"局部变量是否线程安全？"}],"type":5},{"date":"2021-11-16 20:49:34","docid":0,"fillcolor":"ffffed99","folded":true,"id":625,"markups":[{"date":"2021-11-16 20:48:45","docid":0,"id":624,"linecolor":"ffff8280","linewidth":7,"originaltext":"他们底部的方法都加入了synchronized同步锁","page":53,"rect":[161.9999951720239,397.1999881625178,371.7999889492992,415.5999876439575],"type":11},{"date":"2021-11-16 20:52:11","docid":0,"id":626,"linecolor":"ffff8280","linewidth":7,"originaltext":"单个是线程安全的，但是组合起来不是线程安全的，只对于操作同一共享变量","page":53,"rect":[167.04000398254402,421.9200100593569,389.80000926971456,455.5600108375552],"type":11}],"originaltext":"常见线程安全类","page":53,"textblocks":[{"first":[52.35818099975586,348.1271667480469,12.192371368408203,15.5],"last":[125.5124282836914,348.1271667480469,12.192375183105469,15.5],"length":7,"rects":[[52.35818099975586,348.1271667480469,85.34662246704102,15.5]],"start":55,"text":"常见线程安全类"}],"type":5},{"date":"2021-11-16 20:53:04","docid":0,"fillcolor":"ffffed99","folded":true,"id":627,"markups":[{"date":"2021-11-16 20:53:18","docid":0,"fillcolor":"ffffed99","id":628,"originaltext":"String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的","page":54,"textblocks":[{"first":[52.35818099975586,602.9820556640625,5.354892730712891,12.5],"last":[465.0271301269531,602.9820556640625,9.75390625,12.5],"length":51,"rects":[[52.35818099975586,602.9820556640625,422.42285537719727,12.5]],"start":151,"text":"String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的"}],"type":5},{"date":"2021-11-16 20:53:34","docid":0,"id":629,"linecolor":"ffff8280","linewidth":7,"originaltext":"都使用了final修饰","page":54,"rect":[289.79999136328723,577.1999827981,371.7999889492992,594.3999823153024],"type":11},{"date":"2021-11-16 20:56:39","docid":0,"id":630,"linecolor":"ffff8280","linewidth":7,"originaltext":"这些方法对字符串的操作都是创建一个新的字符串对象返回","page":54,"rect":[121.1999963879586,642.5999808490282,299.5999911308291,673.3999799907211],"type":11},{"date":"2021-11-16 20:59:54","docid":0,"fillcolor":"ffffed99","folded":true,"id":632,"markups":[{"date":"2021-11-16 20:58:48","docid":0,"id":631,"linecolor":"ffff8280","linewidth":7,"originaltext":"HttpServlet只有一个实例，会被tomcat多个线程访问，所以继承这个一定存在线程安全问题 ","page":55,"rect":[114.11999721694002,549.9599830176835,419.1199881868366,581.359982141495],"type":11},{"date":"2021-11-16 21:27:27","docid":0,"id":633,"linecolor":"ffff8280","linewidth":7,"originaltext":"线程不安全，因为多个线程使用Myservlet，成员变量存在读写操作","page":56,"rect":[338.99998989701294,260.9999922215941,500.20001190185565,332.6800079078676],"type":11},{"date":"2021-11-16 21:30:19","docid":0,"id":634,"linecolor":"ffff8280","linewidth":7,"originaltext":"spring没有特别说明的情况下都是单例的，所以会有多个线程访问它，并且成员变量存在读写操作，所以存在线程安全问题","page":56,"rect":[257.3999923288824,517.1999845862393,453.1600107803347,601.9600143280032],"type":11},{"date":"2021-11-16 21:35:43","docid":0,"id":635,"linecolor":"ffff8280","linewidth":7,"originaltext":"每个线程创建属于自己的局部变量，并且没有逃离方法的影响范围，所以线程安全","page":57,"rect":[287.39999143481276,288.8399912116529,516.0400122795107,328.36000780487075],"type":11},{"date":"2021-11-16 21:41:39","docid":0,"id":636,"linecolor":"ffff8280","linewidth":7,"originaltext":"方法是单例模式，多个线程访问conn变量并写变量，存在线程安全问题","page":58,"rect":[404.700400094865,78.7502037309994,586.700394730447,109.55020287269254],"type":11},{"date":"2021-11-16 21:44:26","docid":0,"id":637,"linecolor":"ffff8280","linewidth":7,"originaltext":"每个线程都创建自己的UserDao对象，那么没有出现线程安全问题，不推荐这样写","page":58,"rect":[275.99999177455925,419.99998748302494,453.9999864995483,449.7999866247181],"type":11},{"date":"2021-11-16 21:46:10","docid":0,"fillcolor":"ffffed99","folded":true,"id":638,"markups":[{"date":"2021-11-16 21:46:42","docid":0,"id":639,"linecolor":"ffff8280","linewidth":7,"originaltext":"可能将局部变量交给其他线程使用","page":58,"rect":[158.99999526143085,767.9999771118171,307.59999086260814,785.1999766290194],"type":11}],"originaltext":"其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为外星方法","page":59,"textblocks":[{"first":[52.35818099975586,197.06524658203125,9.753898620605469,12.5],"last":[355.3766174316406,197.06524658203125,9.75390625,12.5],"length":35,"rects":[[52.35818099975586,197.06524658203125,312.77234268188477,12.5]],"start":0,"text":"其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为外星方法"}],"type":5},{"date":"2021-11-16 21:48:08","docid":0,"id":640,"linecolor":"ffff8280","linewidth":7,"originaltext":"不想往外暴露的属性方法就要用final和private进行修饰（闭合原则）","page":59,"rect":[325.1999949431422,408.95998799228704,527.560012554169,445.9600106086733],"type":11},{"date":"2021-11-16 21:50:28","docid":0,"id":641,"linecolor":"ffff8280","linewidth":7,"originaltext":"为什么String要设置成final？\n因为怕覆盖String类中的方法破坏行为（底层使用了Synchronized），导致线程不安全","page":59,"rect":[91.19999728202828,429.59998719692265,286.12000679779067,499.24001187896755],"type":11},{"date":"2021-11-16 22:11:44","docid":0,"id":642,"linecolor":"ffff8280","linewidth":7,"originaltext":"找问题先找临界区，对共享变量的读写操作就是临界区","page":60,"rect":[141.59999577999127,145.19999567270293,315.3999906301501,176.19999477863325],"type":11},{"date":"2021-11-16 22:27:42","docid":0,"id":643,"linecolor":"ffff8280","linewidth":7,"originaltext":"不能，因为synchronized对象是实例对象，而方法的调用是使用两个对象，只能保护实例对象的共享变量，但是有两个实例对象，所以另外一个保护不了","page":62,"rect":[377.63998805022277,504.3599825742249,587.0800139732364,595.72001417923],"type":11},{"date":"2021-11-16 22:31:00","docid":0,"id":644,"linecolor":"ffff8280","linewidth":7,"originaltext":"效率较低","page":62,"rect":[382.19998860955275,625.1999813675884,490.6000116729739,659.5600157012943],"type":11}],"originaltext":"实例分析","page":55,"textblocks":[{"first":[52.35818099975586,538.7071533203125,12.192371368408203,14.5],"last":[88.935302734375,538.7071533203125,12.192375183105469,14.5],"length":4,"rects":[[52.35818099975586,538.7071533203125,48.76949691772461,14.5]],"start":23,"text":"实例分析"}],"type":5}],"originaltext":"不可变类线程安全性","page":54,"textblocks":[{"first":[52.35818099975586,578.972412109375,9.753898620605469,12.5],"last":[130.38937377929688,578.972412109375,9.75390625,12.5],"length":9,"rects":[[52.35818099975586,578.972412109375,87.78509902954102,12.5]],"start":140,"text":"不可变类线程安全性"}],"type":5}],"originaltext":"变量的线程安全分析","page":48,"textblocks":[{"first":[76.99653625488281,316.8669738769531,14.630851745605469,17.5],"last":[194.04331970214844,316.8669738769531,14.630844116210938,17.5],"length":9,"rects":[[76.99653625488281,316.8669738769531,131.67762756347656,17.5]],"start":6,"text":"变量的线程安全分析"}],"type":5},{"date":"2021-11-17 11:27:19","docid":0,"fillcolor":"ffffed99","folded":true,"id":645,"markups":[{"date":"2021-11-17 11:27:26","docid":0,"fillcolor":"ffffed99","folded":true,"id":647,"markups":[{"date":"2021-11-17 11:28:15","docid":0,"id":648,"linecolor":"ffff8280","linewidth":7,"originaltext":"对象的创建写入内存中由对象头和成员变量组成","page":62,"rect":[146.40000349044806,732.9600174751286,288.52000685501116,766.6000182533268],"type":11},{"date":"2021-11-17 11:29:45","docid":0,"id":649,"linecolor":"ffff8280","linewidth":7,"originaltext":"普通对象的头有8字节","page":63,"rect":[304.32000725555434,98.88000235748297,418.60000995636005,117.64000278091437],"type":11},{"date":"2021-11-17 11:34:49","docid":0,"fillcolor":"ffffed99","folded":true,"id":654,"markups":[{"date":"2021-11-17 11:30:53","docid":0,"id":650,"linecolor":"ffff8280","linewidth":7,"originaltext":"是指针，指向从属的class，通过这个可以找到类对象","page":63,"rect":[255.36000608825697,155.52000370788585,498.7600118675235,188.2000044631959],"type":11}],"originaltext":"Klass Word (32 bits)","page":63,"textblocks":[{"first":[267.4962158203125,135.0155029296875,4.82818603515625,8.778518676757812],"last":[359.14984130859375,135.0155029296875,4.82818603515625,8.778518676757812],"length":20,"rects":[[267.4962158203125,135.0155029296875,96.4818115234375,8.778518676757812]],"start":295,"text":"Klass Word (32 bits)"}],"type":5},{"date":"2021-11-17 11:34:30","docid":0,"fillcolor":"ffffed99","folded":true,"id":653,"markups":[{"CL":[197.7600047149659,380.1600090637209,235.68000561904918,336.32000754165665,235.68000561904918,316.32000754165665],"date":"2021-11-17 11:33:22","docid":0,"id":651,"linecolor":"ffff8280","linewidth":7,"originaltext":"垃圾回收要用到的分代年龄","page":63,"rect":[165.12000393676766,298.56000711822526,307.24000730133065,317.32000754165665],"type":9},{"CL":[315.8400075302126,382.08000910949727,441.1200105171205,311.04000741577164,450.72001074600234,311.04000741577164],"date":"2021-11-17 11:34:11","docid":0,"id":652,"linecolor":"ffff8280","linewidth":7,"originaltext":"加锁状态","page":63,"rect":[450.72001074600246,302.400007209778,500.68001191329984,321.1600076332094],"type":9},{"CL":[269.28000642013563,381.12000908660906,316.00000801086435,327.60000781059284,338.40000806808484,305.0400072727205],"date":"2021-11-17 11:36:08","docid":0,"id":655,"linecolor":"ffff8280","linewidth":7,"originaltext":"是否是偏向锁","page":63,"rect":[338.40000806808484,296.1600070610048,411.4000097846985,314.9200074844362],"type":9},{"content":"mark word不同状态下的组成","date":"2021-11-17 11:37:27","docid":0,"id":656,"imgfile":"19a2e7173761f6df5c0af759c3614520.png","linecolor":"ffa0ec6f","linewidth":2,"page":63,"rect":[340.32000811386126,373.4400089035036,435.3600103797915,514.5600122680667],"type":2},{"content":"偏向锁101，运行线程要设置到锁中，一般存储在锁记录中","date":"2021-11-18 18:21:58","docid":0,"id":680,"imgfile":"80ee66e5e55998417a77054a1dab3334.png","linecolor":"ffa0ec6f","linewidth":2,"page":63,"rect":[68.39999796152121,400.1999880731109,455.39998642802277,422.99998739361797],"type":2}],"originaltext":"Mark Word (32 bits)","page":63,"textblocks":[{"first":[108.30205535888672,135.0155029296875,4.828178405761719,8.778518676757812],"last":[195.12600708007812,135.0155029296875,4.82818603515625,8.778518676757812],"length":19,"rects":[[108.30205535888672,135.0155029296875,91.65213775634766,8.778518676757812]],"start":262,"text":"Mark Word (32 bits)"}],"type":5}],"originaltext":"Java 对象头","page":62,"textblocks":[{"first":[52.35818099975586,733.837646484375,4.035675048828125,16.5],"last":[105.5897216796875,733.837646484375,12.192375183105469,16.5],"length":8,"rects":[[52.35818099975586,733.837646484375,65.42391586303711,16.5]],"start":35,"text":"Java 对象头"}],"type":5},{"date":"2021-11-17 11:41:36","docid":0,"id":658,"linecolor":"ffff8280","linewidth":7,"originaltext":"对于Integer对象：int+对象头，也就是12字节","page":62,"rect":[322.56000769042987,733.4400174865724,524.2000124740604,766.1200182418827],"type":11},{"date":"2021-11-17 15:13:19","docid":0,"fillcolor":"ffffed99","folded":true,"id":660,"markups":[{"date":"2021-11-17 15:13:13","docid":0,"id":659,"linecolor":"ffff8280","linewidth":7,"originaltext":"被称为监视器或者管程","page":64,"rect":[131.39999608397494,83.99999749660498,231.99999311566373,101.19999701380733],"type":11},{"date":"2021-11-17 15:15:31","docid":0,"id":661,"linecolor":"ffff8280","linewidth":7,"originaltext":"每个对象都可以关联一个Monitor对象（操作系统提供Monitor对象）\n怎么指向Monitor对象？\n使用对象头中Mark word，指向Monitor\n什么时候指向Monitor对象？\n当一个类获取锁的时候\n","page":64,"rect":[286.63743412323925,67.21067635764953,580.3698226464765,172.83019526352763],"type":11},{"date":"2021-11-17 15:26:12","folded":false,"id":664,"linecolor":"ff59c6ff","markups":[{"content":"获取锁的情况下使用30位指针指向monitro，并将加锁状态变为10，运行线程要设置到锁中，一般存储在锁记录中","date":"2021-11-17 15:21:42","docid":0,"id":662,"imgfile":"7143affada4ab9eeb3fd5996dbe82336.png","linecolor":"ffa0ec6f","linewidth":2,"page":63,"rect":[65.99999803304678,452.39998651742974,454.79998644590415,478.7999857306484],"rightbottomcorner":[454.79998644590415,478.7999857306484],"type":2}],"page":-1,"title":"Mark word指向Monitor","type":7},{"date":"2021-11-17 15:49:32","docid":0,"fillcolor":"ffffed99","folded":true,"id":668,"markups":[{"date":"2021-11-17 15:28:47","docid":0,"id":665,"linecolor":"ffff8280","linewidth":7,"originaltext":"synchronized设置的对象锁，会被改造成指向系统创建的Monitor对象（线程运行到对象锁的时候才会改造，只改变对象头），对象锁可以被多个线程访问，访问之时会去查看主存Monitor存储哪个线程是锁的拥有者\n如果已经有了Monitor对象就会将后来线程放入阻塞队列","page":64,"rect":[178.03624639778542,193.7679591432134,426.86157903929035,308.01648721437215],"type":11},{"date":"2021-11-17 15:42:30","docid":0,"id":666,"linecolor":"ffff8280","linewidth":7,"originaltext":"如果线程的代码块执行完，那么Monitor中存储锁的拥有者就会为null，然后将锁还原（还原对象头），并唤醒阻塞队列，让他们竞争","page":64,"rect":[427.9198311385595,147.2843683406471,595.2254591245912,230.76717752817527],"type":11},{"date":"2021-11-17 15:48:25","docid":0,"id":667,"linecolor":"ffff8280","linewidth":7,"originaltext":"synchronized必须进入同一个对象的Monitor才有效","page":64,"rect":[50.399998497963,173.99999481439605,210.99999374151247,203.79999395608914],"type":11},{"date":"2021-11-17 16:50:02","docid":0,"id":672,"linecolor":"ffff8280","linewidth":7,"originaltext":"空间上","page":64,"rect":[28.199999159574475,343.1999897718431,61.59999819397926,360.39998928904555],"type":11},{"date":"2021-11-17 16:29:26","docid":0,"id":669,"linecolor":"ffff8280","linewidth":7,"originaltext":"没有发生竞态条件，线程自带标志放入临界区，存在竞争那么就要升级为Monitor","page":64,"rect":[214.79999359846136,329.3999901831153,563.7999832272534,346.5999897003177],"type":11},{"date":"2021-11-17 16:34:41","docid":0,"id":670,"linecolor":"ffff8280","linewidth":7,"originaltext":"没有发生竞态条件，对临界区设置标志，存在竞争那么就要升级为轻量级","page":64,"rect":[223.19999334812184,345.5999897003177,534.9999840855603,362.7999892175201],"type":11},{"date":"2021-11-17 16:49:54","docid":0,"id":671,"linecolor":"ffff8280","linewidth":7,"originaltext":"时间上","page":64,"rect":[26.999999195337352,329.3999901831153,60.39999822974213,346.5999897003177],"type":11}],"originaltext":"原理之 synchronized","page":64,"textblocks":[{"first":[62.14884948730469,153.84754943847656,12.192375183105469,16.5],"last":[174.9085693359375,153.84754943847656,7.7177734375,16.5],"length":16,"rects":[[62.14884948730469,153.84754943847656,120.47749328613281,16.5]],"start":99,"text":"原理之 synchronized"}],"type":5},{"annotations":[{"content":"3959616f50ac19bfa66e7ed75e12312d.jpg","style":1}],"content":"","date":"2021-11-17 16:51:49","docid":0,"fillcolor":"ffffed99","folded":true,"id":673,"markups":[{"content":"轻量级锁00，运行线程要设置到锁中，一般存储在锁记录中","date":"2021-11-17 17:08:55","docid":0,"id":675,"imgfile":"9bef8f9d329b408d03c465d729f5f9df.png","linecolor":"ffa0ec6f","linewidth":2,"page":63,"rect":[68.39999796152121,425.999987304211,454.79998644590415,449.3999866068367],"type":2},{"annotations":[{"content":"bd84a61087dccf02c1c225d8840af56a.jpg","style":1}],"content":"轻量锁（时间段不交错，线程交错）\n多线程访问临界区时间上是断开的，不存在竞态条件，就可以使用轻量锁。使用的语法仍然是synchronized\n\n轻量锁没有阻塞的概念，只有重量锁有\n\n对于栈帧调用方法只要遇到synchronized都会对锁记录进行写入（每个栈帧都会有锁记录结构），锁记录会存储锁的Mark Word\n\n锁记录结构：Displaced Mark Word 和 Owner\n\n当一个线程使用锁的时候，先拷贝锁的Mark Word到锁记录的Displaced Mark Word，拷贝成功使用CAS将Owner指向锁对象，将锁对象的Mark Word更新为指向锁记录的指针，并更新锁对象的锁状态\n\ncas失败有两种情况：1、有多个线程竞争资源，进入锁膨胀；2、重复获取锁，添加多一个Lock Record进行重入的计数（对锁记录为null，对锁的引用指向那个锁）\n\n对于解锁：\n重入锁：对所记录的删除即可，\n不是重入锁：尝试将线程中复制Mark Word替换当前锁对象的Mark Word\n\n总体：当线程准备获取锁对象的时候，会在栈中创建一个锁记录，1先尝试复制锁对象的Mark Word到锁记录中，成功就用CAS将锁对象的Mark Word更新为指向锁记录的指针并更新状态00，然后更新锁记录的Owner指向锁对象\n解锁尝试使用CAS复制锁记录的原Mark Word，并删除指针，失败进入重量锁解锁过程\n\nHash值：轻量锁存储在锁记录中，重量锁存储在Monitor中","date":"2021-11-18 17:45:04","docid":0,"id":677,"linecolor":"ffff8280","linewidth":7,"originaltext":"轻量锁","page":64,"rect":[298.1999911129477,704.3999790072436,331.5999901473523,721.5999785244466],"type":11},{"content":"锁膨胀\n当对锁已经设置过轻量锁了，这时有别的线程进行设置就表示有竞态条件，需要锁膨胀\n\n加锁过程：锁本身带有轻量锁的设置，多余线程申请锁时锁膨胀会申请Monitor锁，然后让锁的Mark Word指向Monitor锁，不再指向所记录，然后更改之前轻量锁放入的信息（锁状态与重量锁信息），然后根据之前放入轻量锁的信息让Owner指向那个线程，将多余线程引用放入EntryList阻塞队列。\n\n解锁过程：运行线程锁状态信息和地址存储的轻量锁的Mark Word，自己的东西已经没有了，锁地址的引用还指向那个轻量锁，根据引用去到轻量锁找不到自己的东西，所以会解锁失败进入重连锁的解锁过程。\n\n锁膨胀时会将多余线程不会立即进入阻塞队列（因为进入阻塞队列会上下文切换非常耗费性能），这时多余线程就会自旋重试（多核CPU自旋才有意义）\n\nMonitor组成：Owner、EntryList、WaitSet","date":"2021-11-18 17:45:35","docid":0,"id":678,"linecolor":"ffff8280","linewidth":7,"originaltext":"锁膨胀","page":64,"rect":[296.3999911665918,757.1999774336819,331.7999902009965,776.3999769508844],"type":11},{"annotations":[{"content":"985463b0378e1088e5162e2810ee9e33.png","style":1}],"content":"偏向锁（时间不交错，线程不交错）\n对于轻量锁锁重入的优化（减少cas操作，其中的cas操作就是想把锁的Mark Word设置成自己的锁记录信息）\n\n由于发现每次都要设置锁的信息也就是交换，所以就用偏向锁。第一次还是要交换，但是运行线程要设置的锁是偏向锁，所以锁记录里面的信息是不一样，之后的重入只检查ID是不是自己的\n\n偏向锁默认是开启的就是101，但是它是延迟生效的，刚开启的锁的对象头是001，然后才是101\n\n偏向锁的撤销\n1、当对锁进行获取Hash值之后，会默认禁用到偏向锁\n2、其他线程使用对象的时候，发生竞态条件需要锁升级\n3、调用wait/notify\n\n批量重偏向锁：当对某个类的对象偏向锁批量撤销20次，则偏向锁认为，后面的锁需要重新偏向新的线程（批量重偏向）\n\n批量撤销：当某个类的对象的偏向锁累计被撤销到阈值40次（从40次开始），则偏向锁认为偏向锁撤销过于频繁，则后面的对象包括新生成的对象（标识为101和001）如果需要使用锁，则直接轻量级锁，不在使用偏向锁（即禁用了偏向锁）\n\n锁消除是Java虚拟机在JIT编译是，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间。","date":"2021-11-18 17:47:59","docid":0,"id":679,"linecolor":"ffff8280","linewidth":7,"originaltext":"偏向锁","page":65,"rect":[302.399990987778,73.79999780058864,336.7999900221827,91.99999731779101],"type":11}],"originaltext":"原理之 synchronized 进阶","page":64,"textblocks":[{"first":[62.14884948730469,716.5785522460938,12.192375183105469,16.5],"last":[197.91561889648438,716.5785522460938,12.1923828125,16.5],"length":19,"rects":[[62.14884948730469,716.5785522460938,147.9591522216797,16.5]],"start":934,"text":"原理之 synchronized 进阶"}],"type":5}],"originaltext":" 原理之 Monitor(锁)","page":64,"textblocks":[{"first":[59.00302505493164,103.6270980834961,3.1700172424316406,15.5],"last":[167.33265686035156,103.6270980834961,4.133209228515625,15.5],"length":15,"rects":[[59.00302505493164,103.6270980834961,112.46284103393555,15.5]],"start":78,"text":" 原理之 Monitor(锁)"}],"type":5}],"originaltext":"Monitor 概念","page":62,"textblocks":[{"first":[77.0404281616211,706.02685546875,13.796890258789062,17.5],"last":[154.37872314453125,706.02685546875,14.630844116210938,17.5],"length":10,"rects":[[77.0404281616211,706.02685546875,91.9691390991211,17.5]],"start":23,"text":"Monitor 概念"}],"type":5},{"content":"重点（在Monitor锁中）：\n1、Owner的线程条件不满足会调用wait方法将线程放入waitSet中变为waiting状态\n2、Blocked与Waiting都是阻塞状态不占用CPU时间片\n3、BLOCKED的线程在Owner线程释放锁的过程中会被唤醒\n4、Waiting线程会在Owner线程调用notify或者notifyAll方法唤醒，进入阻塞队列EntryList中\n\n最重要的是只有线程获得锁才有资格唤醒或者进入Waiting状态\n\n当waiting线程也没有了程序才会结束","date":"2021-11-19 10:20:53","docid":0,"fillcolor":"ffffed99","folded":true,"id":681,"markups":[{"date":"2021-11-19 11:03:53","docid":0,"fillcolor":"ffffed99","folded":true,"id":684,"markups":[{"date":"2021-11-19 11:03:59","docid":0,"fillcolor":"ffffed99","id":685,"originaltext":"obj.wait() 让进入 object 监视器的线程到 waitSet 等待obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒 obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒","page":65,"textblocks":[{"first":[78.61868286132812,717.4839477539062,4.828178405761719,13.5],"last":[345.5634460449219,747.4967041015625,9.75390625,13.5],"length":134,"rects":[[78.61868286132812,717.4839477539062,242.80685424804688,13.5],[78.61868286132812,732.4899291992188,284.2646484375,13.5],[78.61868286132812,747.4967041015625,276.69866943359375,13.5]],"start":233,"text":"obj.wait() 让进入 object 监视器的线程到 waitSet 等待\nobj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒 \nobj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒"}],"type":5},{"date":"2021-11-19 11:03:35","docid":0,"fillcolor":"ffffed99","id":682,"originaltext":"wait() 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止wait(long n) 有时限的等待, 到 n 毫秒后结束等待，或是被 notify","page":67,"textblocks":[{"first":[56.108726501464844,147.05056762695312,4.828117370605469,13.758895874023438],"last":[335.48663330078125,184.77513122558594,4.9158935546875,13.5],"length":111,"rects":[[56.108726501464844,147.05056762695312,474.59793853759766,13.758895874023438],[52.35727310180664,161.46347045898438,48.0500602722168,14.5],[56.1088752746582,184.77513122558594,284.29365158081055,13.5]],"start":261,"text":"wait() 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到\nnotify 为止\nwait(long n) 有时限的等待, 到 n 毫秒后结束等待，或是被 notify"}],"type":5}],"originaltext":"API 介绍","page":65,"textblocks":[{"first":[52.35818099975586,692.0210571289062,8.412738800048828,12.5],"last":[87.78884887695312,692.0210571289062,12.192375183105469,12.5],"length":6,"rects":[[52.35818099975586,692.0210571289062,47.623043060302734,12.5]],"start":225,"text":"API 介绍"}],"type":5},{"date":"2021-11-19 11:03:46","docid":0,"fillcolor":"ffffed99","folded":true,"id":683,"markups":[{"content":"1、sleep方法是Thread的，wait方法是Object的\n2、sleep不用强制与Synchronized使用，但是wait需要\n3、调用后sleep，wait的线程都会进入waitSet中，但是sleep不会让其他线程进入Owner，wait的线程可以让其他的线程进入Owner","date":"2021-11-19 11:06:06","docid":0,"fillcolor":"ffffed99","id":686,"originaltext":"1) sleep 是 Thread 方法，而 wait 是 Object 的方法 2) sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 3) sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 4) 它们状态 TIMED_WAITING","page":67,"textblocks":[{"first":[52.358192443847656,290.5237731933594,5.579093933105469,14.5],"last":[141.23280334472656,322.6350402832031,7.1006622314453125,10.5],"length":171,"rects":[[52.358192443847656,290.5237731933594,487.16011810302734,14.5],[52.35894775390625,306.62872314453125,484.3983154296875,12.5],[52.35969543457031,322.6350402832031,95.97377014160156,10.5]],"start":440,"text":"1) sleep 是 Thread 方法，而 wait 是 Object 的方法 2) sleep 不需要强制和 synchronized 配合使用，但 wait 需要\n和 synchronized 一起用 3) sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 4) 它们\n状态 TIMED_WAITING"}],"type":5},{"date":"2021-11-19 11:34:34","docid":0,"id":687,"linecolor":"ffff8280","linewidth":7,"originaltext":"sleep过程中持有锁，其他线程需要等待它的睡眠无法进入代码块","page":67,"rect":[325.7999902904036,620.9999814927583,497.79998519420667,650.7999806344515],"type":11},{"date":"2021-11-19 11:35:31","docid":0,"id":688,"linecolor":"ffff8280","linewidth":7,"originaltext":"使用wait方法可以进入阻塞，放弃锁，让其他线程执行，等待运行线程唤醒，但是notify无法精确的唤醒线程","page":68,"rect":[302.399990987778,553.7999834954743,508.56757966892167,642.7634958545585],"type":11},{"date":"2021-11-19 11:41:24","docid":0,"id":689,"linecolor":"ffff8280","linewidth":7,"originaltext":"还是使用notify随机唤醒了其他线程，造成虚假唤醒","page":69,"rect":[320.3999904513362,639.599980938435,496.39998526573214,670.3999800801282],"type":11},{"content":"用while让线程一直判断是否要wait，成立就继续睡眠，不则运行干活的代码，解决虚假唤醒\n\nsynchronized(Obj){\n while(是否需要睡眠的条件){\n\t\tObj.wait()\n\t}\n}\n\n另一线程\nsynchronized(Obj){\n Obj.notifyAll()\n}","date":"2021-11-19 11:44:32","docid":0,"fillcolor":"ffffed99","id":690,"originaltext":"用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新判断的机会了解决方法，用 while + wait，当条件不成立，再次 wait","page":71,"textblocks":[{"first":[74.86717987060547,350.87823486328125,9.753898620605469,12.5],"last":[305.02545166015625,381.3902282714844,3.443115234375,12.5],"length":103,"rects":[[74.86717987060547,350.87823486328125,462.9915237426758,12.5],[74.86717987060547,365.8842468261719,58.523399353027344,12.5],[74.86717987060547,381.3902282714844,233.60138702392578,12.5]],"start":476,"text":"用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新\n判断的机会了\n解决方法，用 while + wait，当条件不成立，再次 wait"}],"type":5}],"originaltext":" wait notify 的正确姿势","page":67,"textblocks":[{"first":[73.23529815673828,209.23703002929688,3.803955078125,19.5],"last":[218.70736694335938,209.23703002929688,14.630599975585938,19.5],"length":18,"rects":[[73.23529815673828,209.23703002929688,160.10266876220703,19.5]],"start":376,"text":" wait notify 的正确姿势"}],"type":5},{"content":"<body style=\" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;\">\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">解决虚假唤醒方法的变种</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">同步之保护性暂停：一个线程要获得另一个线程执行的结果时候就可用用到（用一个开关来决定是否等待wait）</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">要点：</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">1、有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">2、如果是不断的需要传递，那么使用消息队列</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">3、join()，Future()使用了这个模式</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">（关联同一个对象使用代理模式，赋值需要锁，获取结果需要锁，一个线程等待另一线程对这个对象赋值，为null就等待，不为null就取值，这样就可以做到保护性暂停）</p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">对于超时：设置一个计时效果，不能直接让wait等，不得话等完还是要进入循环进入重新等待，要设置线程醒过来计时也是join的底层</p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">join的底层就是使用while和wait组成避免虚假唤醒，然后使用传入的时间去取得还要等待多久，并设置wait的时间，每一次被唤醒都会去拿还需要等待的时间去设置wait</p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">扩展：多个保护性暂停（也就是多个GuardedObject）</p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-family:'JetBrains Mono','monospace','华文宋体'; font-size:16pt; color:#629755;\">wait/notify</span><span style=\" font-family:'宋体','monospace','华文宋体'; font-size:16pt; color:#629755;\">进阶，保护性暂停：</span></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-family:'宋体','monospace'; font-size:16pt; color:#629755;\">获取资源：产生</span><span style=\" font-family:'JetBrains Mono','monospace'; font-size:16pt; color:#629755;\">GuardedObject</span><span style=\" font-family:'宋体','monospace'; font-size:16pt; color:#629755;\">（产生</span><span style=\" font-family:'JetBrains Mono','monospace'; font-size:16pt; color:#629755;\">ID</span><span style=\" font-family:'宋体','monospace'; font-size:16pt; color:#629755;\">）</span></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-family:'宋体','monospace'; font-size:16pt; color:#629755;\">产生资源（产生</span><span style=\" font-family:'JetBrains Mono','monospace'; font-size:16pt; color:#629755;\">ID</span><span style=\" font-family:'宋体','monospace'; font-size:16pt; color:#629755;\">）：选择</span><span style=\" font-family:'JetBrains Mono','monospace'; font-size:16pt; color:#629755;\">GuardedObject</span><span style=\" font-family:'宋体','monospace'; font-size:16pt; color:#629755;\">放入，对资源集合进行封装</span></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-family:'JetBrains Mono','monospace'; font-size:16pt; color:#629755;\">GuardedObject</span><span style=\" font-family:'宋体','monospace'; font-size:16pt; color:#629755;\">的选择使用两个</span><span style=\" font-family:'JetBrains Mono','monospace'; font-size:16pt; color:#629755;\">id</span><span style=\" font-family:'宋体','monospace'; font-size:16pt; color:#629755;\">对应</span></p></body>","date":"2021-11-19 11:49:26","docid":0,"fillcolor":"ffffed99","id":691,"originaltext":"模式之保护性暂停","page":72,"textblocks":[{"first":[62.14809799194336,441.9176940917969,12.192371368408203,15.5],"last":[147.49472045898438,441.9176940917969,12.1923828125,15.5],"length":8,"rects":[[62.14809799194336,441.9176940917969,97.53900527954102,15.5]],"start":428,"text":"模式之保护性暂停"}],"type":5},{"content":"<body style=\" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;\">\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">异步之生产者消费者</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">1、与前面的保护性暂停的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">2、消费队列可以用来平衡生产与消费的线程资源</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">3、生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">4、消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">5、JDK中各种阻塞队列均采用这种模式</p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-family:'JetBrains Mono','monospace','华文宋体'; font-size:16pt; color:#629755;\">wait/notify</span><span style=\" font-family:'宋体','monospace','华文宋体'; font-size:16pt; color:#629755;\">进阶，生产者消费者：</span></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-family:'宋体','monospace','华文宋体'; font-size:16pt; color:#629755;\">使用队列，队列存储资源，变成锁，队列为空消费者</span><span style=\" font-family:'JetBrains Mono','monospace','华文宋体'; font-size:16pt; color:#629755;\">wait</span><span style=\" font-family:'宋体','monospace','华文宋体'; font-size:16pt; color:#629755;\">，队列满生产者</span><span style=\" font-family:'JetBrains Mono','monospace','华文宋体'; font-size:16pt; color:#629755;\">wait</span><span style=\" font-family:'宋体','monospace','华文宋体'; font-size:16pt; color:#629755;\">，不管是消费还是生产一个都要唤醒全部线程。</span></p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p></body>","date":"2021-11-19 16:40:35","docid":0,"fillcolor":"ffffed99","id":692,"originaltext":"模式之生产者消费者","page":72,"textblocks":[{"first":[62.14809799194336,468.1781921386719,12.192371368408203,15.5],"last":[159.68710327148438,468.1781921386719,12.1923828125,15.5],"length":9,"rects":[[62.14809799194336,468.1781921386719,109.73138809204102,15.5]],"start":440,"text":"模式之生产者消费者"}],"type":5}],"originaltext":"原理之 wait / notify","page":65,"textblocks":[{"first":[62.14809799194336,616.0413208007812,12.192371368408203,16.5],"last":[169.36782836914062,616.0413208007812,6.9374542236328125,16.5],"length":17,"rects":[[62.14809799194336,616.0413208007812,114.15718460083008,16.5]],"start":202,"text":"原理之 wait / notify"}],"type":5},{"date":"2021-11-22 11:52:54","docid":0,"fillcolor":"ffffed99","folded":true,"id":693,"markups":[{"content":"如果先unpakr那么就park失效","date":"2021-11-22 11:59:08","docid":0,"fillcolor":"ffffed99","id":695,"originaltext":"先 park 再 unpark","page":72,"textblocks":[{"first":[52.35818099975586,747.04443359375,9.753898620605469,8.5],"last":[127.29739379882812,747.04443359375,5.1208038330078125,8.5],"length":15,"rects":[[52.35818099975586,747.04443359375,80.06001663208008,8.5]],"start":506,"text":"先 park 再 unpark"}],"type":5},{"date":"2021-11-22 12:04:24","docid":0,"fillcolor":"ffffed99","folded":false,"group":[{"date":"2021-11-22 12:04:24","docid":0,"fillcolor":"ffffed99","id":697,"originaltext":"","page":74,"textblocks":[{"first":[74.86717987060547,56.75311279296875,5.9791412353515625,12.5],"last":[341.42926025390625,86.46739196777344,4.91595458984375,13.5],"length":137,"rects":[[74.86717987060547,56.75311279296875,470.0545120239258,12.5],[74.86717987060547,71.7591552734375,175.57027435302734,12.5],[74.86717987060547,86.46739196777344,271.47803497314453,13.5]],"start":0,"text":"park & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll \n是唤醒所有等待线程，就不那么【精确】\npark & unpark 可以先 unpark，而 wait & notify 不能先 notify"}],"type":5}],"id":696,"markups":[{"date":"2021-11-22 12:05:20","docid":0,"id":698,"linecolor":"ffff8280","linewidth":7,"originaltext":"也就是唤醒比较精确，准确唤醒被park的线程","page":74,"rect":[250.89584756598157,69.4178234372281,548.9049635581218,85.78891291261432],"type":11}],"originaltext":"与 Object 的 wait & notify 相比wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必Thread t1 = new Thread(() -> {    log.debug(\"start...\");    sleep(1);    log.debug(\"park...\");    LockSupport.park();    log.debug(\"resume...\");},\"t1\");t1.start(); sleep(2);log.debug(\"unpark...\");LockSupport.unpark(t1);Thread t1 = new Thread(() -> {    log.debug(\"start...\");    sleep(2);    log.debug(\"park...\");    LockSupport.park();    log.debug(\"resume...\");}, \"t1\");t1.start(); sleep(1);log.debug(\"unpark...\");LockSupport.unpark(t1);北京市昌平区建材城西路金燕龙办公楼一层   电话：400-618-9090\npark & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】park & unpark 可以先 unpark，而 wait & notify 不能先 notify","page":73,"textblocks":[{"first":[52.3574333190918,722.7300415039062,9.753898620605469,13.5],"last":[0,0,0,0],"length":595,"rects":[[52.3574333190918,722.7300415039062,135.86958694458008,13.5],[74.86717987060547,744.4420776367188,367.67176055908203,14.5],[64.8784408569336,68.23657989501953,144.73511505126953,8.778511047363281],[64.87918853759766,81.74195098876953,125.44942474365234,8.778511047363281],[64.87994384765625,95.24658966064453,62.71681213378906,8.778511047363281],[64.87994384765625,108.75202178955078,120.6309814453125,8.778511047363281],[64.88069152832031,122.25739288330078,110.98063659667969,8.778511047363281],[64.88143920898438,135.7628173828125,130.27911376953125,8.778518676757812],[64.88143920898438,149.2681884765625,38.60143280029297,8.778518676757812],[64.88143920898438,162.77362060546875,53.07771301269531,8.778518676757812],[64.88069152832031,180.298583984375,4.828178405761719,2.5],[64.88069152832031,189.784423828125,43.41986083984375,8.778518676757812],[64.88069152832031,203.289794921875,110.98213195800781,8.778518676757812],[64.88069152832031,216.79522705078125,110.98213195800781,8.778518676757812],[64.8784408569336,389.3709411621094,144.73511505126953,8.77850341796875],[64.87918853759766,402.8763427734375,125.44942474365234,8.77850341796875],[64.87994384765625,416.3817443847656,62.71681213378906,8.77850341796875],[64.87994384765625,429.88714599609375,120.6309814453125,8.77850341796875],[64.88069152832031,443.3925476074219,110.98063659667969,8.77850341796875],[64.88143920898438,456.89794921875,130.27911376953125,8.77850341796875],[64.88143920898438,470.4033508300781,43.43186950683594,8.77850341796875],[64.88143920898438,483.9087219238281,53.07771301269531,8.77850341796875],[64.88069152832031,495.0566101074219,4.828178405761719,11.530364990234375],[64.88069152832031,510.91949462890625,43.41986083984375,8.77850341796875],[64.88069152832031,524.4249267578125,110.98213195800781,8.77850341796875],[64.88069152832031,537.9303588867188,110.98213195800781,8.77850341796875],[164.75,813.5006713867188,265.5,9],[164.75,813.5006713867188,265.5,9]],"start":414,"text":"与 Object 的 wait & notify 相比\nwait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必\nThread t1 = new Thread(() -> {\n    log.debug(\"start...\");\n    sleep(1);\n    log.debug(\"park...\");\n    LockSupport.park();\n    log.debug(\"resume...\");\n},\"t1\");\nt1.start();\n \nsleep(2);\nlog.debug(\"unpark...\");\nLockSupport.unpark(t1);\nThread t1 = new Thread(() -> {\n    log.debug(\"start...\");\n    sleep(2);\n    log.debug(\"park...\");\n    LockSupport.park();\n    log.debug(\"resume...\");\n}, \"t1\");\nt1.start();\n \nsleep(1);\nlog.debug(\"unpark...\");\nLockSupport.unpark(t1);\n北京市昌平区建材城西路金燕龙办公楼一层   电话：400-618-9090\n"}],"type":5},{"date":"2021-11-22 12:08:24","docid":0,"fillcolor":"ffffed99","id":700,"originaltext":"原理之 park & unpark","page":74,"textblocks":[{"first":[62.14884948730469,132.8368682861328,12.192375183105469,16.5],"last":[182.19497680664062,132.8368682861328,7.55926513671875,16.5],"length":17,"rects":[[62.14884948730469,132.8368682861328,127.60539245605469,16.5]],"start":142,"text":"原理之 park & unpark"}],"type":5},{"content":"_counter\n_mutex里面存在_cond\n当一个线程使用park的时候会首先检查_counter是否为1，0的情况下给线程获得_mutex互斥锁，然后进入里面的_cond阻塞队列，等待unpark将_counter置为1，然后唤醒_cond阻塞队列中的线程，阻塞线程继续运行将_counter置为0\n\n_counter：用来标记该线程下一次是否不需要等待，调用多次也只是置为1，等待park消耗一次存储\n_mutex：为互斥锁，里面存储_cond阻塞队列\n_cond：阻塞队列\n\n\npark：方法执行的时候会先检查_counter是否为1，为0就进入_cond阻塞队列，等待唤醒，并再将_counter置为0；为1将_counter置为0，继续运行。\n\nunpark：将_counter置为1，然后唤醒_counter阻塞队列的线程，如果线程唤醒则会将_counter置为0\n\n不管线程进入还是出来都会将_counter置为0","date":"2021-11-22 12:08:54","docid":0,"id":701,"linecolor":"ffff8280","linewidth":7,"originaltext":"每个线程都有park对象：由_counter，_cond，_mutex组成（Java看不到，底层由C实现）","page":74,"rect":[59.00514992164389,158.17346911768402,315.86773025546705,187.94059849257522],"type":11}],"originaltext":"Park & Unpark","page":72,"textblocks":[{"first":[77.0404281616211,565.6680908203125,9.18817138671875,18.5],"last":[174.77452087402344,565.6680908203125,9.071121215820312,18.5],"length":13,"rects":[[77.0404281616211,565.6680908203125,106.80521392822266,18.5]],"start":461,"text":"Park & Unpark"}],"type":5},{"date":"2021-11-22 19:10:22","docid":0,"fillcolor":"ffffed99","folded":false,"id":720,"markups":[{"date":"2021-11-22 19:15:46","docid":0,"fillcolor":"ffffed99","id":721,"markups":[{"date":"2021-11-22 18:18:08","docid":0,"fillcolor":"ffffed99","folded":true,"id":702,"markups":[{"date":"2021-11-22 18:47:04","docid":0,"fillcolor":"ffffed99","id":703,"originaltext":"情况 1 NEW --> RUNNABLE","page":75,"textblocks":[{"first":[52.35893249511719,494.89300537109375,12.192375183105469,12.1923828125],"last":[188.78414916992188,494.89300537109375,6.705810546875,12.1923828125],"length":21,"rects":[[52.35893249511719,494.89300537109375,143.1310272216797,12.1923828125]],"start":19,"text":"情况 1 NEW --> RUNNABLE"}],"type":5},{"date":"2021-11-22 19:01:52","folded":true,"id":712,"linecolor":"ff59c6ff","markups":[{"date":"2021-11-22 18:47:09","docid":0,"fillcolor":"ffffed99","folded":true,"id":704,"markups":[{"date":"2021-11-22 18:48:29","docid":0,"id":705,"linecolor":"ffff8280","linewidth":7,"originaltext":"调用notify唤醒不是直接进入Runnable状态，会进入竞争锁的情况然后，竞争失败进入Blocked状态（也就是线程进入EntryList集合），竞争成功才会进入Runnable状态","page":75,"rect":[281.761905201577,539.7547920381703,538.7740405077551,605.1292167766677],"type":11}],"originaltext":"情况 2 RUNNABLE <--> WAITING","page":75,"textblocks":[{"first":[52.36268615722656,569.1741943359375,12.192375183105469,12.1923828125],"last":[222.2899169921875,569.1741943359375,6.705810546875,12.1923828125],"length":26,"rects":[[52.36268615722656,569.1741943359375,176.63304138183594,12.1923828125]],"start":82,"text":"情况 2 RUNNABLE <--> WAITING"}],"type":5},{"date":"2021-11-22 18:53:07","docid":0,"fillcolor":"ffffed99","folded":false,"id":707,"markups":[{"date":"2021-11-22 18:54:13","docid":0,"id":708,"linecolor":"ffff8280","linewidth":7,"originaltext":"join谁调用谁waiting，只有指定的线程运行结束才能唤醒，直接回到Runnable状态","page":76,"rect":[279.7811536711617,532.3269737991129,500.1493856646566,582.3505741768918],"type":11}],"originaltext":"情况 3 RUNNABLE <--> WAITING","page":76,"textblocks":[{"first":[52.35818099975586,545.152587890625,12.192371368408203,12.1923828125],"last":[222.2899169921875,545.152587890625,6.705810546875,12.1923828125],"length":26,"rects":[[52.35818099975586,545.152587890625,176.63754653930664,12.1923828125]],"start":4,"text":"情况 3 RUNNABLE <--> WAITING"}],"type":5},{"date":"2021-11-22 18:54:30","docid":0,"fillcolor":"ffffed99","id":709,"originaltext":"情况 4 RUNNABLE <--> WAITING","page":76,"textblocks":[{"first":[52.36493682861328,659.200439453125,12.192375183105469,12.1923828125],"last":[222.2899169921875,659.200439453125,6.705810546875,12.1923828125],"length":26,"rects":[[52.36493682861328,659.200439453125,176.63079071044922,12.1923828125]],"start":163,"text":"情况 4 RUNNABLE <--> WAITING"}],"type":5}],"page":-1,"title":"Waiting","type":7},{"date":"2021-11-22 19:02:28","folded":true,"id":713,"linecolor":"ff59c6ff","markups":[{"date":"2021-11-22 19:00:11","docid":0,"fillcolor":"ffffed99","id":710,"originaltext":"情况 5 RUNNABLE <--> TIMED_WAITING","page":76,"textblocks":[{"first":[52.35818099975586,763.494384765625,12.192371368408203,12.1923828125],"last":[262.5247802734375,763.494384765625,6.705810546875,12.1923828125],"length":32,"rects":[[52.35818099975586,763.494384765625,216.87240982055664,12.1923828125]],"start":329,"text":"情况 5 RUNNABLE <--> TIMED_WAITING"}],"type":5},{"date":"2021-11-22 19:01:40","docid":0,"fillcolor":"ffffed99","id":711,"originaltext":"情况 6 RUNNABLE <--> TIMED_WAITING","page":77,"textblocks":[{"first":[52.36118698120117,185.01087951660156,12.192371368408203,12.192367553710938],"last":[262.5247802734375,185.01087951660156,6.705810546875,12.192367553710938],"length":32,"rects":[[52.36118698120117,185.01087951660156,216.86940383911133,12.192367553710938]],"start":238,"text":"情况 6 RUNNABLE <--> TIMED_WAITING"}],"type":5},{"content":"特殊的和join一样时间没有了都会进入Runnable状态","date":"2021-11-22 19:02:56","docid":0,"fillcolor":"ffffed99","id":715,"originaltext":"情况 7 RUNNABLE <--> TIMED_WAITING","page":77,"textblocks":[{"first":[52.35893249511719,314.0654296875,12.192375183105469,12.1923828125],"last":[262.5247802734375,314.0654296875,6.705810546875,12.1923828125],"length":32,"rects":[[52.35893249511719,314.0654296875,216.8716583251953,12.1923828125]],"start":439,"text":"情况 7 RUNNABLE <--> TIMED_WAITING"}],"type":5},{"date":"2021-11-22 19:03:03","docid":0,"fillcolor":"ffffed99","id":716,"originaltext":"情况 8 RUNNABLE <--> TIMED_WAITING","page":77,"textblocks":[{"first":[52.36343765258789,404.10369873046875,12.192378997802734,12.1923828125],"last":[262.5247802734375,404.10369873046875,6.705810546875,12.1923828125],"length":32,"rects":[[52.36343765258789,404.10369873046875,216.8671531677246,12.1923828125]],"start":589,"text":"情况 8 RUNNABLE <--> TIMED_WAITING"}],"type":5}],"page":-1,"title":"Time_Waiting","type":7},{"date":"2021-11-22 19:03:18","folded":true,"id":718,"linecolor":"ff59c6ff","markups":[{"date":"2021-11-22 19:03:05","docid":0,"fillcolor":"ffffed99","id":717,"originaltext":"情况 9 RUNNABLE <--> BLOCKED","page":77,"textblocks":[{"first":[52.35818099975586,523.4036254882812,12.192371368408203,12.1923828125],"last":[222.2899169921875,523.4036254882812,6.705810546875,12.1923828125],"length":26,"rects":[[52.35818099975586,523.4036254882812,176.63754653930664,12.1923828125]],"start":830,"text":"情况 9 RUNNABLE <--> BLOCKED"}],"type":5}],"page":-1,"title":"锁竞争失败Blocked","type":7},{"date":"2021-11-22 19:03:39","docid":0,"fillcolor":"ffffed99","id":719,"originaltext":"情况 10 RUNNABLE <--> TERMINATED","page":77,"textblocks":[{"first":[52.36343765258789,627.6975708007812,12.192378997802734,12.1923828125],"last":[249.37088012695312,627.6975708007812,6.705810546875,12.1923828125],"length":30,"rects":[[52.36343765258789,627.6975708007812,203.71325302124023,12.1923828125]],"start":1029,"text":"情况 10 RUNNABLE <--> TERMINATED"}],"type":5}],"originaltext":"重新理解线程状态转换","page":74,"textblocks":[{"first":[85.3848876953125,413.6496887207031,14.630851745605469,17.5],"last":[217.0625,413.6496887207031,14.630844116210938,17.5],"length":10,"rects":[[85.3848876953125,413.6496887207031,146.30845642089844,17.5]],"start":188,"text":"重新理解线程状态转换"}],"type":5}],"originaltext":"将锁的粒度细分好处，是可以增强并发度坏处，如果一个线程需要同时获得多把锁，就容易发生死锁","page":79,"textblocks":[{"first":[52.3574333190918,341.1221008300781,9.753898620605469,12.5],"last":[318.71478271484375,378.38885498046875,9.75390625,13.5],"length":46,"rects":[[52.3574333190918,341.1221008300781,68.27729415893555,12.5],[74.86717987060547,363.38214111328125,107.29293060302734,13.5],[74.86717987060547,378.38885498046875,253.60150909423828,13.5]],"start":94,"text":"将锁的粒度细分\n好处，是可以增强并发度\n坏处，如果一个线程需要同时获得多把锁，就容易发生死锁"}],"title":"多锁的好坏处","type":5}],"originaltext":"多把锁","page":77,"textblocks":[{"first":[85.38789367675781,746.0520629882812,14.630851745605469,17.5],"last":[114.64959716796875,746.0520629882812,14.630844116210938,17.5],"length":3,"rects":[[85.38789367675781,746.0520629882812,43.892547607421875,17.5]],"start":1098,"text":"多把锁"}],"type":5},{"date":"2021-11-22 19:18:13","docid":0,"fillcolor":"ffffed99","folded":true,"id":722,"markups":[{"content":"指两个或者两个以上的进程，由于竞争资源或者彼此通信造成的一种阻塞现象，若无外力作用，他们将无法推进下去","date":"2021-11-22 19:18:22","docid":0,"fillcolor":"ffffed99","folded":true,"id":723,"markups":[{"date":"2021-11-22 20:31:44","docid":0,"id":725,"linecolor":"ffff8280","linewidth":7,"originaltext":"就是每个线程陷入了锁的阻塞队列里面出不来了","page":79,"rect":[153.50824360718607,411.99631832638323,300.0934810927109,446.6690943434434],"type":11},{"date":"2021-11-22 20:39:18","docid":0,"fillcolor":"ffffed99","folded":true,"id":726,"markups":[{"date":"2021-11-22 20:47:02","docid":0,"fillcolor":"ffffed99","id":728,"originaltext":"避免死锁要注意加锁顺序另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排查","page":81,"textblocks":[{"first":[74.86717987060547,494.1945495605469,9.753898620605469,13.5],"last":[461.1733703613281,523.106689453125,9.75390625,14.500732421875],"length":126,"rects":[[74.86717987060547,494.1945495605469,107.29293060302734,13.5],[74.86717987060547,508.1005554199219,469.4102249145508,14.500030517578125],[74.86717987060547,523.106689453125,396.06009674072266,14.500732421875]],"start":0,"text":"避免死锁要注意加锁顺序\n另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 top 先定位到 \nCPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排查"}],"type":5}],"originaltext":"定位死锁","page":80,"textblocks":[{"first":[52.3574333190918,279.597900390625,12.192371368408203,15.5],"last":[88.93455505371094,279.597900390625,12.192375183105469,15.5],"length":4,"rects":[[52.3574333190918,279.597900390625,48.76949691772461,15.5]],"start":93,"text":"定位死锁"}],"type":5},{"date":"2021-11-22 20:48:29","docid":0,"fillcolor":"ffffed99","id":729,"originaltext":"哲学家就餐问题","page":81,"textblocks":[{"first":[52.3619384765625,571.72705078125,12.192375183105469,14.5],"last":[125.51618957519531,571.72705078125,12.192367553710938,14.5],"length":7,"rects":[[52.3619384765625,571.72705078125,85.34661865234375,14.5]],"start":129,"text":"哲学家就餐问题"}],"type":5}],"originaltext":"死锁","page":79,"textblocks":[{"first":[52.35893249511719,433.661376953125,12.192375183105469,14.5],"last":[64.55130767822266,433.661376953125,12.192375183105469,14.5],"length":2,"rects":[[52.35893249511719,433.661376953125,24.384750366210938,14.5]],"start":151,"text":"死锁"}],"type":5},{"date":"2021-11-22 19:18:33","docid":0,"fillcolor":"ffffed99","folded":true,"id":724,"markups":[{"date":"2021-11-22 21:33:40","docid":0,"fillcolor":"ffffed99","id":730,"originaltext":"活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束","page":84,"textblocks":[{"first":[52.35818099975586,714.7774658203125,9.753898620605469,12.5],"last":[325.4674987792969,714.7774658203125,9.75390625,12.5],"length":29,"rects":[[52.35818099975586,714.7774658203125,282.863224029541,12.5]],"start":61,"text":"活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束"}],"type":5},{"date":"2021-11-22 21:36:29","docid":0,"id":731,"linecolor":"ffff8280","linewidth":7,"originaltext":"将指令交错，或者改变两者的睡眠时间不相近随机的睡眠时间，即可解决活锁","page":85,"rect":[360.89347395090556,82.71049702147684,510.7600121536258,139.2400032958985],"type":11},{"date":"2021-11-22 21:45:08","docid":0,"id":735,"linecolor":"ffff8280","linewidth":7,"originaltext":"更多是获取了第一把锁，在第二把锁掉入了第二把锁的EntryList","page":83,"rect":[295.5235523443287,437.91049713594043,457.56322776072756,498.66382201684513],"type":11},{"date":"2021-11-22 21:48:49","docid":0,"id":736,"linecolor":"ffff8280","linewidth":7,"originaltext":"改变阿基米德的加锁顺序牺牲自己，让自己最后获得左边的锁，让给左边的线程，这样会造成阿基米德获取左边的锁 永远慢人一步，而右边的线程永远获取第一把锁慢人一步，造成锁饥饿","page":83,"rect":[305.93426471978387,560.7968450536071,454.1992187259034,639.1481340265184],"type":11}],"originaltext":"活锁","page":84,"textblocks":[{"first":[52.35818099975586,688.017578125,12.192371368408203,15.5],"last":[64.55055236816406,688.017578125,12.192375183105469,15.5],"length":2,"rects":[[52.35818099975586,688.017578125,24.384746551513672,15.5]],"start":57,"text":"活锁"}],"type":5},{"date":"2021-11-22 21:36:35","docid":0,"fillcolor":"ffffed99","folded":true,"id":732,"markups":[{"date":"2021-11-22 21:37:34","docid":0,"fillcolor":"ffffed99","id":733,"originaltext":"一个线程由于优先级太低，始终得不到 CPU 调度执行，","page":85,"textblocks":[{"first":[169.40499877929688,409.8511657714844,9.75390625,13.5],"last":[398.4310607910156,409.8511657714844,9.75390625,13.5],"length":27,"rects":[[169.40499877929688,409.8511657714844,238.77996826171875,13.5]],"start":76,"text":"一个线程由于优先级太低，始终得不到 CPU 调度执行，"}],"type":5},{"content":"会产生饥饿问题，也就是一个线程一直获得不到锁\n死锁：一个线程对于其他线程获取锁太慢了，造成抢不到锁，一直得不到运行","date":"2021-11-22 21:39:05","docid":0,"fillcolor":"ffffed99","id":734,"originaltext":"用顺序加锁的方式解决之前的死锁问题","page":85,"textblocks":[{"first":[296.2057800292969,447.4164733886719,9.75390625,13.5],"last":[452.2682800292969,447.4164733886719,9.75390625,13.5],"length":17,"rects":[[296.2057800292969,447.4164733886719,165.81640625,13.5]],"start":159,"text":"用顺序加锁的方式解决之前的死锁问题"}],"type":5}],"originaltext":"饥饿","page":85,"textblocks":[{"first":[52.35818099975586,382.3912658691406,12.192371368408203,15.5],"last":[64.55055236816406,382.3912658691406,12.192375183105469,15.5],"length":2,"rects":[[52.35818099975586,382.3912658691406,24.384746551513672,15.5]],"start":60,"text":"饥饿"}],"type":5}],"originaltext":"活跃性","page":79,"textblocks":[{"first":[85.3848876953125,404.65057373046875,14.630851745605469,17.5],"last":[114.64659118652344,404.65057373046875,14.630844116210938,17.5],"length":3,"rects":[[85.3848876953125,404.65057373046875,43.892547607421875,17.5]],"start":146,"text":"活跃性"}],"type":5},{"date":"2021-11-22 21:54:51","docid":0,"fillcolor":"ffffed99","folded":true,"id":738,"markups":[{"date":"2021-11-22 21:55:00","docid":0,"fillcolor":"ffffed99","folded":true,"id":739,"markups":[{"date":"2021-11-22 21:57:33","docid":0,"id":740,"linecolor":"ffff8280","linewidth":7,"originaltext":"多个waitSet，也就是多个等待房间","page":86,"rect":[161.14851869356522,486.4206056565771,324.28872057909086,503.78337832392356],"type":11}],"originaltext":"相对于 synchronized 它具备如下特点可中断可以设置超时时间可以设置为公平锁支持多个条件变量","page":86,"textblocks":[{"first":[52.35818099975586,419.60736083984375,9.753898620605469,13.5],"last":[143.1444854736328,486.43658447265625,9.75390625,13.5],"length":55,"rects":[[52.35818099975586,419.60736083984375,162.93518447875977,13.5],[74.86717987060547,442.4178161621094,29.261695861816406,12.5],[74.86717987060547,456.4245910644531,78.03121185302734,13.5],[74.86717987060547,472.43060302734375,78.03121185302734,12.5],[74.86717987060547,486.43658447265625,78.03121185302734,13.5]],"start":79,"text":"相对于 synchronized 它具备如下特点\n可中断\n可以设置超时时间\n可以设置为公平锁\n支持多个条件变量"}],"title":"可重入锁的特点","type":5},{"date":"2021-11-22 21:59:55","docid":0,"fillcolor":"ffffed99","folded":true,"id":741,"markups":[{"date":"2021-11-22 22:00:01","docid":0,"fillcolor":"ffffed99","id":742,"originaltext":"// 获取锁reentrantLock.lock();try {    // 临界区} finally {    // 释放锁    reentrantLock.unlock();}","page":86,"textblocks":[{"first":[64.8784408569336,567.9706420898438,4.828178405761719,11.5],"last":[64.87918853759766,665.4888305664062,4.828178405761719,8.77850341796875],"length":98,"rects":[[64.8784408569336,567.9706420898438,40.79380798339844,11.5],[64.8784408569336,584.4564819335938,101.34453582763672,8.77850341796875],[64.87918853759766,597.9618530273438,24.11388397216797,8.77850341796875],[64.87918853759766,609.1097412109375,60.09003448486328,11.53033447265625],[64.87918853759766,624.97265625,53.07996368408203,8.77850341796875],[64.87918853759766,636.1205444335938,60.09003448486328,11.53033447265625],[64.87918853759766,651.9834594726562,130.25960540771484,8.77850341796875],[64.87918853759766,665.4888305664062,4.828178405761719,8.77850341796875]],"start":250,"text":"// 获取锁\nreentrantLock.lock();\ntry {\n    // 临界区\n} finally {\n    // 释放锁\n    reentrantLock.unlock();\n}"}],"type":5}],"originaltext":"基本语法","page":86,"textblocks":[{"first":[52.35818099975586,533.2048950195312,9.753898620605469,12.5],"last":[81.61988067626953,533.2048950195312,9.753898620605469,12.5],"length":4,"rects":[[52.35818099975586,533.2048950195312,39.01559829711914,12.5]],"start":160,"text":"基本语法"}],"type":5},{"date":"2021-11-22 22:01:03","docid":0,"fillcolor":"ffffed99","folded":true,"id":744,"markups":[{"date":"2021-11-22 22:00:59","docid":0,"fillcolor":"ffffed99","id":743,"originaltext":"可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住","page":86,"textblocks":[{"first":[52.35818099975586,747.0448608398438,9.753898620605469,12.5],"last":[305.9596862792969,770.0042114257812,9.75390625,13.5],"length":75,"rects":[[52.35818099975586,747.0448608398438,458.433536529541,12.5],[52.35818099975586,770.0042114257812,263.355411529541,13.5]],"start":174,"text":"可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁\n如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住"}],"type":5}],"originaltext":"可重入","page":86,"textblocks":[{"first":[52.35818099975586,720.3849487304688,12.192371368408203,15.5],"last":[76.74292755126953,720.3849487304688,12.192375183105469,15.5],"length":3,"rects":[[52.35818099975586,720.3849487304688,36.57712173461914,15.5]],"start":169,"text":"可重入"}],"type":5},{"date":"2021-11-22 22:19:14","docid":0,"fillcolor":"ffffed99","folded":true,"id":746,"markups":[{"content":"打断会放弃当前线程已经得到的锁，被动的放弃锁，让其他的线程通知阻塞线程不要死等","date":"2021-11-22 22:19:39","docid":0,"id":747,"linecolor":"ffff8280","linewidth":7,"originaltext":"打断只有用lock.lockInterruptibly()方法加锁才能打断，普通的不能打断","page":87,"rect":[103.13505196388166,681.286352876796,474.9044278866537,721.5079934233592],"type":11},{"date":"2021-11-22 22:20:22","docid":0,"fillcolor":"ffffed99","id":748,"originaltext":"注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断","page":88,"textblocks":[{"first":[52.3574333190918,687.4147338867188,9.753898620605469,14.5],"last":[351.7669372558594,687.4147338867188,9.75390625,14.5],"length":38,"rects":[[52.3574333190918,687.4147338867188,309.1634101867676,14.5]],"start":666,"text":"注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断"}],"type":5}],"originaltext":"可打断","page":87,"textblocks":[{"first":[52.3574333190918,682.014404296875,12.192371368408203,14.5],"last":[76.74217987060547,682.014404296875,12.192375183105469,14.5],"length":3,"rects":[[52.3574333190918,682.014404296875,36.57712173461914,14.5]],"start":174,"text":"可打断"}],"type":5},{"content":"主动的方式放弃锁","date":"2021-11-22 22:20:29","docid":0,"fillcolor":"ffffed99","folded":true,"id":749,"markups":[{"date":"2021-11-22 22:37:26","docid":0,"fillcolor":"ffffed99","id":750,"originaltext":"立刻失败","page":89,"textblocks":[{"first":[52.3574333190918,527.2009887695312,9.753898620605469,13.5],"last":[81.61913299560547,527.2009887695312,9.753898620605469,13.5],"length":4,"rects":[[52.3574333190918,527.2009887695312,39.01559829711914,13.5]],"start":255,"text":"立刻失败"}],"type":5},{"date":"2021-11-22 22:37:31","docid":0,"fillcolor":"ffffed99","folded":false,"id":751,"markups":[{"date":"2021-11-22 22:38:10","docid":0,"id":752,"linecolor":"ffff8280","linewidth":7,"originaltext":"增加时间超时失败，可以打断。被打断应该停止执行当前的代码，然后返回","page":90,"rect":[110.07683430760456,266.762778637348,378.33545454093274,298.5049575881204],"type":11},{"date":"2021-11-22 22:38:25","docid":0,"fillcolor":"ffffed99","folded":false,"id":753,"markups":[{"date":"2021-11-22 22:55:55","docid":0,"id":754,"linecolor":"ffff8280","linewidth":7,"originaltext":"因为tryLock可以知道是否获取锁成功，使用if条件判断，没有就finally进行放弃已经持有的一级锁","page":90,"rect":[213.7077278674665,778.4713056889151,513.2043686475473,808.725959851747],"type":11}],"originaltext":"使用 tryLock 解决哲学家就餐问题","page":90,"textblocks":[{"first":[52.3574333190918,765.8038940429688,9.753898620605469,12.5],"last":[187.98544311523438,765.8038940429688,9.75390625,12.5],"length":20,"rects":[[52.3574333190918,765.8038940429688,145.38191604614258,12.5]],"start":276,"text":"使用 tryLock 解决哲学家就餐问题"}],"type":5}],"originaltext":"超时失败","page":90,"textblocks":[{"first":[52.35818099975586,269.8450927734375,9.753898620605469,12.5],"last":[81.61988067626953,269.8450927734375,9.753898620605469,12.5],"length":4,"rects":[[52.35818099975586,269.8450927734375,39.01559829711914,12.5]],"start":133,"text":"超时失败"}],"type":5}],"originaltext":"锁超时","page":89,"textblocks":[{"first":[52.3574333190918,499.4410400390625,12.192371368408203,15.5],"last":[76.74217987060547,499.4410400390625,12.192375183105469,15.5],"length":3,"rects":[[52.3574333190918,499.4410400390625,36.57712173461914,15.5]],"start":250,"text":"锁超时"}],"type":5},{"date":"2021-11-22 22:57:35","docid":0,"fillcolor":"ffffed99","folded":true,"id":755,"markups":[{"date":"2021-11-22 22:58:09","docid":0,"fillcolor":"ffffed99","id":756,"originaltext":"ReentrantLock 默认是不公平的","page":92,"textblocks":[{"first":[52.35818099975586,108.2728271484375,6.0279083251953125,12.5],"last":[179.1409149169922,108.2728271484375,9.75390625,12.5],"length":21,"rects":[[52.35818099975586,108.2728271484375,136.53664016723633,12.5]],"start":7,"text":"ReentrantLock 默认是不公平的"}],"type":5},{"date":"2021-11-22 22:59:01","docid":0,"id":757,"linecolor":"ffff8280","linewidth":7,"originaltext":"按先入先得的方式获取锁的","page":92,"rect":[124.4562405910304,86.77227929653515,241.48317405039734,103.14336877192136],"type":11},{"date":"2021-11-22 22:59:31","docid":0,"fillcolor":"ffffed99","id":758,"originaltext":"公平锁一般没有必要，会降低并发度","page":93,"textblocks":[{"first":[52.3574333190918,283.345947265625,9.753898620605469,13.5],"last":[198.6659698486328,283.345947265625,9.75390625,13.5],"length":16,"rects":[[52.3574333190918,283.345947265625,156.06244277954102,13.5]],"start":185,"text":"公平锁一般没有必要，会降低并发度"}],"type":5}],"originaltext":"公平锁","page":92,"textblocks":[{"first":[52.35818099975586,81.01287841796875,12.192371368408203,15.5],"last":[76.74292755126953,81.01287841796875,12.192375183105469,15.5],"length":3,"rects":[[52.35818099975586,81.01287841796875,36.57712173461914,15.5]],"start":2,"text":"公平锁"}],"type":5},{"date":"2021-11-22 23:00:05","docid":0,"fillcolor":"ffffed99","folded":true,"id":759,"markups":[{"content":"其实就是wait/notify的增强版，唯一不同的就是waitSet等待集合，也就是休息室，不同的休息室，理解成休息室比较容易理解","date":"2021-11-22 23:01:57","docid":0,"fillcolor":"ffffed99","id":760,"originaltext":"ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的","page":93,"textblocks":[{"first":[52.35818099975586,379.03466796875,6.0279083251953125,14.5],"last":[410.3901672363281,379.03466796875,9.75390625,14.5],"length":52,"rects":[[52.35818099975586,379.03466796875,367.78589248657227,14.5]],"start":286,"text":"ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的"}],"type":5},{"date":"2021-11-22 23:07:24","docid":0,"fillcolor":"ffffed99","id":761,"originaltext":"synchronized 是那些不满足条件的线程都在一间休息室等消息","page":93,"textblocks":[{"first":[74.86717987060547,402.64892578125,4.652610778808594,12.5],"last":[332.80767822265625,402.64892578125,9.75390625,12.5],"length":34,"rects":[[74.86717987060547,402.64892578125,267.6944046020508,12.5]],"start":344,"text":"synchronized 是那些不满足条件的线程都在一间休息室等消息"}],"type":5},{"date":"2021-11-22 23:07:30","docid":0,"fillcolor":"ffffed99","id":762,"originaltext":"而 ReentrantLock 支持多间休息室","page":93,"textblocks":[{"first":[74.86717987060547,417.6556701660156,9.753898620605469,12.5],"last":[213.92857360839844,417.6556701660156,9.75390625,12.5],"length":23,"rects":[[74.86717987060547,417.6556701660156,148.81529998779297,12.5]],"start":379,"text":"而 ReentrantLock 支持多间休息室"}],"type":5},{"date":"2021-11-22 23:07:54","docid":0,"fillcolor":"ffffed99","folded":true,"id":764,"markups":[{"date":"2021-11-22 23:07:57","docid":0,"fillcolor":"ffffed99","id":765,"originaltext":"await 前需要获得锁await 执行后，会释放锁，进入 conditionObject 等待await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁竞争 lock 锁成功后，从 await 后继续执行","page":93,"textblocks":[{"first":[74.86717987060547,501.6907958984375,5.423164367675781,12.5],"last":[244.48228454589844,546.7095336914062,9.75390625,12.5],"length":110,"rects":[[74.86717987060547,501.6907958984375,85.37590789794922,12.5],[74.86717987060547,516.3967895507812,231.10291290283203,13.5],[74.86717987060547,531.7035522460938,254.90167999267578,12.5],[74.86717987060547,546.7095336914062,179.36901092529297,12.5]],"start":445,"text":"await 前需要获得锁\nawait 执行后，会释放锁，进入 conditionObject 等待\nawait 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁\n竞争 lock 锁成功后，从 await 后继续执行"}],"type":5}],"originaltext":"使用要点：","page":93,"textblocks":[{"first":[52.35818099975586,478.1299743652344,9.753898620605469,13.5],"last":[91.373779296875,478.1299743652344,9.753898620605469,13.5],"length":5,"rects":[[52.35818099975586,478.1299743652344,48.76949691772461,13.5]],"start":439,"text":"使用要点："}],"type":5},{"content":"代码","date":"2021-11-22 23:29:55","docid":0,"fillcolor":"ffffed99","id":766,"originaltext":"同步模式之顺序控制","page":95,"textblocks":[{"first":[62.14809799194336,230.32861328125,12.192371368408203,15.5],"last":[159.68710327148438,230.32861328125,12.1923828125,15.5],"length":9,"rects":[[62.14809799194336,230.32861328125,109.73138809204102,15.5]],"start":197,"text":"同步模式之顺序控制"}],"type":5}],"originaltext":"条件变量","page":93,"textblocks":[{"first":[52.3574333190918,330.86578369140625,12.192371368408203,14.5],"last":[88.93455505371094,330.86578369140625,12.192375183105469,14.5],"length":4,"rects":[[52.3574333190918,330.86578369140625,48.76949691772461,14.5]],"start":215,"text":"条件变量"}],"type":5}],"originaltext":"ReentrantLock","page":86,"textblocks":[{"first":[85.39464569091797,392.4971618652344,9.656364440917969,15.5],"last":[184.2921142578125,392.4971618652344,9.071121215820312,15.5],"length":13,"rects":[[85.39464569091797,392.4971618652344,107.96858978271484,15.5]],"start":64,"text":"ReentrantLock"}],"type":5},{"date":"2021-11-23 00:43:26","docid":0,"fillcolor":"ffffed99","folded":true,"id":770,"markups":[{"date":"2021-11-23 00:43:07","docid":0,"id":768,"linecolor":"ffff8280","linewidth":7,"originaltext":"park属于LockSupport工具中的东西不需要常规的锁，所以与之前的东西分开，不要混淆，虽然底层还是获取了互斥锁","page":95,"rect":[219.1234163340426,575.6871283406697,516.4905857905828,637.8116170285202],"type":11}],"originaltext":"本章小结","page":95,"textblocks":[{"first":[52.3574333190918,256.59027099609375,14.630847930908203,17.5],"last":[96.24998474121094,256.59027099609375,14.630851745605469,17.5],"length":4,"rects":[[52.3574333190918,256.59027099609375,58.52340316772461,17.5]],"start":208,"text":"本章小结"}],"type":5}],"originaltext":"共享模型之管程","page":32,"textblocks":[{"first":[71.37303924560547,172.3070068359375,17.06932830810547,20.5],"last":[173.78897094726562,172.3070068359375,17.069320678710938,20.5],"length":7,"rects":[[71.37303924560547,172.3070068359375,119.4852523803711,20.5]],"start":13,"text":"共享模型之管程"}],"type":5},{"date":"2021-11-23 16:14:39","docid":0,"fillcolor":"ffffed99","folded":true,"id":771,"markups":[{"content":"JMM","date":"2021-11-23 16:14:58","docid":0,"fillcolor":"ffffed99","folded":false,"id":772,"markups":[{"content":"所有线程都共享的数据","date":"2021-11-23 16:19:04","docid":0,"fillcolor":"ffffed99","id":775,"originaltext":"主存","page":96,"textblocks":[{"first":[226.3287811279297,110.4452896118164,9.75390625,14.5],"last":[236.0826873779297,110.4452896118164,9.75390625,14.5],"length":2,"rects":[[226.3287811279297,110.4452896118164,19.5078125,14.5]],"start":89,"text":"主存"}],"type":5},{"content":"线程私有的数据","date":"2021-11-23 16:19:30","docid":0,"fillcolor":"ffffed99","id":776,"originaltext":"工作内存","page":96,"textblocks":[{"first":[255.5904998779297,110.4452896118164,9.753890991210938,14.5],"last":[284.8522033691406,110.4452896118164,9.75390625,14.5],"length":4,"rects":[[255.5904998779297,110.4452896118164,39.01560974121094,14.5]],"start":92,"text":"工作内存"}],"type":5},{"date":"2021-11-23 16:16:38","docid":0,"fillcolor":"ffffed99","folded":false,"id":773,"markups":[{"date":"2021-11-23 16:16:47","docid":0,"fillcolor":"ffffed99","id":774,"originaltext":"原子性 - 保证指令不会受到线程上下文切换的影响可见性 - 保证指令不会受 cpu 缓存的影响有序性 - 保证指令不会受 cpu 指令并行优化的影响","page":96,"textblocks":[{"first":[74.86717987060547,172.02183532714844,9.753898620605469,13.5],"last":[280.318115234375,201.23458862304688,9.75390625,14.5],"length":76,"rects":[[74.86717987060547,172.02183532714844,213.03803253173828,13.5],[74.86717987060547,186.22860717773438,176.1892318725586,14.5],[74.86717987060547,201.23458862304688,215.20484161376953,14.5]],"start":149,"text":"原子性 - 保证指令不会受到线程上下文切换的影响\n可见性 - 保证指令不会受 cpu 缓存的影响\n有序性 - 保证指令不会受 cpu 指令并行优化的影响"}],"type":5}],"originaltext":"JMM 体现在以下几个方面","page":96,"textblocks":[{"first":[52.35893249511719,150.060302734375,2.604290008544922,12.5],"last":[153.11672973632812,150.060302734375,9.75390625,12.5],"length":13,"rects":[[52.35893249511719,150.060302734375,110.51170349121094,12.5]],"start":135,"text":"JMM 体现在以下几个方面"}],"type":5},{"date":"2021-11-23 16:24:17","docid":0,"fillcolor":"ffffed99","folded":true,"id":777,"markups":[{"content":"如果一个线程多次对主存读取 数据，JIT编译器即时编译器会 缓存主存中的数据 到 工作内存中，如此主线程更改主存的值的时候，多次读取的值还是缓存的值\n\n不可见：因为CPU对主存数据的缓存导致线程看不见真正的主存数据\n\n注意：当发生线程上下文切换的时候会重新取主存里面取的值","date":"2021-11-23 16:27:57","docid":0,"fillcolor":"ffffed99","id":778,"originaltext":"为什么呢？分析一下：1. 初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。","page":96,"textblocks":[{"first":[52.35818099975586,581.9781494140625,9.753898620605469,12.5],"last":[338.494140625,605.2374267578125,9.75390625,12.5],"length":47,"rects":[[52.35818099975586,581.9781494140625,97.53900527954102,12.5],[64.52729797363281,605.2374267578125,283.7207489013672,12.5]],"start":302,"text":"为什么呢？分析一下：\n1. 初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。"}],"type":5},{"date":"2021-11-23 16:34:03","docid":0,"fillcolor":"ffffed99","folded":true,"id":779,"markups":[{"content":"volatile：对 成员变量 和 静态成员变量 修饰，修饰过后每次取数据只会去主存中取\n\n不需要修饰 基本数据类型的局部变量，他是线程私有的存储在栈中\n\n对于 引用类型的局部变量 还是取堆中的数据，所以引用类型如果被访问到就需要修饰\n\n注意：当发生线程上下文切换、获取锁和释放锁以及CPU有空闲时间的时候会重新取主存里面取的值","date":"2021-11-23 17:04:31","docid":0,"fillcolor":"ffffed99","id":782,"originaltext":"volatile（易变关键字）它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存","page":98,"textblocks":[{"first":[52.35818099975586,316.0697021484375,4.8867034912109375,13.5],"last":[255.70755004882812,354.635009765625,9.75390625,12.5],"length":95,"rects":[[52.35818099975586,316.0697021484375,100.7578010559082,13.5],[52.35818099975586,339.6289978027344,487.6952247619629,12.5],[52.35818099975586,354.635009765625,213.10327529907227,12.5]],"start":8,"text":"volatile（易变关键字）\n它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取\n它的值，线程操作 volatile 变量都是直接操作主存"}],"type":5}],"originaltext":"解决方法","page":98,"textblocks":[{"first":[52.35818099975586,288.60980224609375,12.192371368408203,15.5],"last":[88.935302734375,288.60980224609375,12.192375183105469,15.5],"length":4,"rects":[[52.35818099975586,288.60980224609375,48.76949691772461,15.5]],"start":2,"text":"解决方法"}],"type":5},{"date":"2021-11-23 17:06:11","docid":0,"fillcolor":"ffffed99","folded":true,"id":785,"markups":[{"date":"2021-11-23 17:06:02","docid":0,"fillcolor":"ffffed99","id":783,"originaltext":"一个线程对 volatile 变量的修改对另一个线程可见， 不能保证原子性","page":98,"textblocks":[{"first":[325.4682312011719,427.8644104003906,9.75390625,13.5],"last":[132.91639709472656,444.171142578125,9.75390625,12.5],"length":38,"rects":[[325.4682312011719,427.8644104003906,203.34927368164062,13.5],[52.35893249511719,444.171142578125,90.31137084960938,12.5]],"start":146,"text":"一个线程对 volatile 变量的修改对另一个线程可\n见， 不能保证原子性"}],"type":5},{"content":"volatile的缺陷，适用于一个线程写，多个线程读","date":"2021-11-23 17:10:03","docid":0,"fillcolor":"ffffed99","id":786,"originaltext":"只能保证看到最新值，不能解决指令交错","page":98,"textblocks":[{"first":[357.96661376953125,573.72705078125,9.75390625,12.5],"last":[523.7830200195312,573.72705078125,9.75390625,12.5],"length":18,"rects":[[357.96661376953125,573.72705078125,175.5703125,12.5]],"start":515,"text":"只能保证看到最新值，不能解决指令交错"}],"type":5},{"date":"2021-11-23 17:11:07","docid":0,"fillcolor":"ffffed99","id":787,"originaltext":"注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized 是属于重量级操作，性能相对更低","page":99,"textblocks":[{"first":[66.61388397216797,56.76812744140625,9.753898620605469,12.5],"last":[266.03094482421875,71.774169921875,9.75390625,12.5],"length":81,"rects":[[66.61388397216797,56.76812744140625,436.0430679321289,12.5],[66.61388397216797,71.774169921875,209.17096710205078,12.5]],"start":0,"text":"注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是\nsynchronized 是属于重量级操作，性能相对更低"}],"type":5},{"content":"注意：当发生线程上下文切换、获取锁和释放锁以及CPU有空闲时间的时候会重新取主存里面取的值","date":"2021-11-23 17:16:19","docid":0,"id":788,"linecolor":"ffff8280","linewidth":7,"originaltext":"底层使用Synchronized，保证了可见性和原子性","page":99,"rect":[240.51713192234064,110.88776861354665,399.6358697308723,150.06117689854395],"type":11}],"originaltext":"可见性 vs 原子性","page":98,"textblocks":[{"first":[52.35818099975586,401.4045104980469,12.192371368408203,14.5],"last":[132.65078735351562,401.4045104980469,12.1923828125,14.5],"length":10,"rects":[[52.35818099975586,401.4045104980469,92.48498916625977,14.5]],"start":106,"text":"可见性 vs 原子性"}],"type":5},{"date":"2021-11-23 17:36:48","docid":0,"fillcolor":"ffffed99","id":789,"originaltext":"模式之两阶段终止","page":99,"textblocks":[{"first":[62.14884948730469,225.08251953125,12.192375183105469,15.5],"last":[147.4954833984375,225.08251953125,12.1923828125,15.5],"length":8,"rects":[[62.14884948730469,225.08251953125,97.53901672363281,15.5]],"start":196,"text":"模式之两阶段终止"}],"type":5},{"date":"2021-11-23 17:36:55","docid":0,"fillcolor":"ffffed99","id":790,"originaltext":"模式之 Balking","page":99,"textblocks":[{"first":[62.14884948730469,250.6430206298828,12.192375183105469,16.499984741210938],"last":[140.46047973632812,250.6430206298828,6.8886871337890625,16.499984741210938],"length":11,"rects":[[62.14884948730469,250.6430206298828,85.2003173828125,16.499984741210938]],"start":209,"text":"模式之 Balking"}],"type":5}],"originaltext":"可见性","page":96,"textblocks":[{"first":[76.99653625488281,250.60528564453125,14.630851745605469,17.5],"last":[106.25823974609375,250.60528564453125,14.630851745605469,17.5],"length":3,"rects":[[76.99653625488281,250.60528564453125,43.892555236816406,17.5]],"start":232,"text":"可见性"}],"type":5},{"date":"2021-11-23 18:05:19","docid":0,"fillcolor":"ffffed99","folded":true,"id":791,"markups":[{"date":"2021-11-23 18:06:17","docid":0,"fillcolor":"ffffed99","folded":true,"id":793,"markups":[{"date":"2021-11-23 18:23:14","docid":0,"id":794,"linecolor":"ffff8280","linewidth":7,"originaltext":"没有依托别的变量进行操作，所以有可能CPU会指令重排","page":100,"rect":[158.26235520431078,200.43094326861728,439.86567578037494,218.09013855328158],"type":11},{"date":"2021-11-23 18:23:57","docid":0,"id":795,"linecolor":"ffff8280","linewidth":7,"originaltext":"每一个代码块依托于ready变量，指令不能重排","page":100,"rect":[158.1737588423779,78.29327365719928,479.8466824778998,103.00870381638815],"type":11}],"originaltext":"这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。为什么要有重排指令这项优化呢？","page":99,"textblocks":[{"first":[52.35818099975586,621.7417602539062,9.753898620605469,12.5],"last":[491.2839050292969,621.7417602539062,9.75390625,12.5],"length":46,"rects":[[52.35818099975586,621.7417602539062,448.679630279541,12.5]],"start":336,"text":"这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。为什么要有重排指令这项优化呢？"}],"title":"指令重排","type":5},{"date":"2021-11-23 18:29:30","docid":0,"fillcolor":"ffffed99","folded":true,"id":796,"markups":[{"content":"只需要对 可能发生重排序的代码 的最后面的操作代码加上即可\n因为volatile会加入写屏障让自己上面的代码不会排序到自己后面","date":"2021-11-23 18:30:21","docid":0,"fillcolor":"ffffed99","id":798,"originaltext":"volatile 修饰的变量，可以禁用指令重排","page":101,"textblocks":[{"first":[52.3574333190918,735.0355834960938,4.8867034912109375,12.5],"last":[214.16493225097656,735.0355834960938,9.75390625,12.5],"length":23,"rects":[[52.3574333190918,735.0355834960938,171.56140518188477,12.5]],"start":899,"text":"volatile 修饰的变量，可以禁用指令重排"}],"type":5}],"originaltext":"解决方法","page":101,"textblocks":[{"first":[52.3574333190918,708.2756958007812,12.192371368408203,15.5],"last":[88.93455505371094,708.2756958007812,12.192375183105469,15.5],"length":4,"rects":[[52.3574333190918,708.2756958007812,48.76949691772461,15.5]],"start":893,"text":"解决方法"}],"type":5}],"originaltext":" 有序性","page":99,"textblocks":[{"first":[73.23640441894531,277.60467529296875,3.8040237426757812,17.5],"last":[106.25823974609375,277.60467529296875,14.630851745605469,17.5],"length":4,"rects":[[73.23640441894531,277.60467529296875,47.652687072753906,17.5]],"start":226,"text":" 有序性"}],"type":5},{"content":"<body style=\" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;\">\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">volatile的原理是内存屏障</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">对 volatile 的写指令后加入 写屏障</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">对 volatile 的读指令前加入 读屏障</p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">对于可见性</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">读屏障：对于读屏障之后的共享变量的读取，都会读取主存中的数据</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">写屏障：对于写屏障之前的共享变量的改动，都会同步到主存中</p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">对于有序性</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">读屏障：对于之后的读指令不会排在屏障之前</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">写屏障：对于之前的写指令不会排在屏障之后</p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:11pt;\">对于读屏障和写屏障的说明：</span></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16pt;\">读屏障 : 读指令 写指令 : 写屏障</span></p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16pt;\"><br /></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16pt;\">volatile只能保证线程的有序性和可见性</span></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16pt;\">synchronized三者都可以保证但是消耗大</span></p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16pt;\"><br /></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16pt;\">synchronized不能阻止重排序，但是共享变量完全交给synchronized就不会出现有序性问题</span></p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16pt;\"><br /></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16pt;\">所以在同一时刻只有一个线程改，多个线程读的时候，只要保证有序性和可见性即可</span></p></body>","date":"2021-11-23 18:33:21","docid":0,"fillcolor":"ffffed99","folded":true,"id":799,"markups":[{"content":"使用懒汉式+Balking+双重校验创建单例（有缺点）\n","date":"2021-11-23 20:43:43","docid":0,"id":801,"linecolor":"ffff8280","linewidth":7,"originaltext":"double-checked Locking","page":102,"rect":[66.63678113865717,576.3040368788554,181.12754901543266,592.9220324582282],"type":11}],"originaltext":"原理之 volatile","page":102,"textblocks":[{"first":[62.14809799194336,551.606689453125,12.192371368408203,14.5],"last":[140.19149780273438,551.606689453125,7.2056884765625,14.5],"length":12,"rects":[[62.14809799194336,551.606689453125,85.24908828735352,14.5]],"start":139,"text":"原理之 volatile"}],"type":5},{"date":"2021-11-23 21:24:15","docid":0,"fillcolor":"ffffed99","folded":true,"id":802,"markups":[{"date":"2021-11-23 21:24:23","docid":0,"fillcolor":"ffffed99","id":803,"originaltext":"线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见","page":102,"textblocks":[{"first":[74.86717987060547,666.0064697265625,9.753898620605469,12.5],"last":[415.2393493652344,666.0064697265625,9.75390625,12.5],"length":39,"rects":[[74.86717987060547,666.0064697265625,350.1260757446289,12.5]],"start":289,"text":"线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见"}],"type":5},{"date":"2021-11-23 21:24:27","docid":0,"fillcolor":"ffffed99","id":804,"originaltext":"线程对 volatile 变量的写，对接下来其它线程对该变量的读可见","page":103,"textblocks":[{"first":[74.86717987060547,203.81414794921875,9.753898620605469,12.5],"last":[336.7400207519531,203.81414794921875,9.75390625,12.5],"length":34,"rects":[[74.86717987060547,203.81414794921875,271.62674713134766,12.5]],"start":2,"text":"线程对 volatile 变量的写，对接下来其它线程对该变量的读可见"}],"type":5},{"date":"2021-11-23 21:24:31","docid":0,"fillcolor":"ffffed99","id":805,"originaltext":"线程 start 前对变量的写，对该线程开始后对该变量的读可见","page":103,"textblocks":[{"first":[74.86717987060547,400.0972595214844,9.753898620605469,13.5],"last":[325.2011413574219,400.0972595214844,9.75390625,13.5],"length":31,"rects":[[74.86717987060547,400.0972595214844,260.0878677368164,13.5]],"start":41,"text":"线程 start 前对变量的写，对该线程开始后对该变量的读可见"}],"type":5},{"date":"2021-11-23 21:24:34","docid":0,"fillcolor":"ffffed99","id":806,"originaltext":"线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）","page":103,"textblocks":[{"first":[74.86717987060547,568.1177978515625,9.753898620605469,14.5],"last":[104.12887573242188,584.2237548828125,9.753898620605469,12.5],"length":67,"rects":[[74.86717987060547,568.1177978515625,458.42359161376953,14.5],[74.86717987060547,584.2237548828125,39.015594482421875,12.5]],"start":77,"text":"线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待\n它结束）"}],"type":5},{"date":"2021-11-23 21:24:42","docid":0,"fillcolor":"ffffed99","id":807,"originaltext":"线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）","page":104,"textblocks":[{"first":[74.86717987060547,56.7606201171875,9.753898620605469,12.5],"last":[224.6720733642578,71.46665954589844,9.75390625,13.5],"length":90,"rects":[[74.86717987060547,56.7606201171875,421.8562698364258,12.5],[74.86717987060547,71.46665954589844,159.55879974365234,13.5]],"start":0,"text":"线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过\nt2.interrupted 或 t2.isInterrupted）"}],"type":5},{"date":"2021-11-23 21:24:53","docid":0,"fillcolor":"ffffed99","id":809,"originaltext":"对变量默认值（0，false，null）的写，对其它线程对该变量的读可见具有传递性，如果 x hb-> y 并且 y hb-> z 那么有 x hb-> z，配合 volatile 的防指令重排，有下面的例子","page":104,"textblocks":[{"first":[74.86717987060547,470.927734375,9.753898620605469,12.5],"last":[530.45166015625,489.6136779785156,9.75390625,14.15325927734375],"length":105,"rects":[[74.86717987060547,470.927734375,297.4085159301758,12.5],[74.86717987060547,489.6136779785156,465.33838653564453,14.15325927734375]],"start":95,"text":"对变量默认值（0，false，null）的写，对其它线程对该变量的读可见\n具有传递性，如果 x hb-> y 并且 y hb-> z 那么有 x hb-> z，配合 volatile 的防指令重排，有下面的例子"}],"type":5},{"date":"2021-11-23 21:24:57","docid":0,"fillcolor":"ffffed99","id":810,"originaltext":"变量都是指成员变量或静态成员变量","page":104,"textblocks":[{"first":[66.61388397216797,729.5368041992188,9.753898620605469,13.5],"last":[212.92242431640625,729.5368041992188,9.75390625,13.5],"length":16,"rects":[[66.61388397216797,729.5368041992188,156.06244659423828,13.5]],"start":205,"text":"变量都是指成员变量或静态成员变量"}],"type":5}],"originaltext":"happens-before","page":102,"textblocks":[{"first":[52.3574333190918,604.72705078125,8.010391235351562,10.5],"last":[140.8473663330078,604.72705078125,7.2056884765625,10.5],"length":14,"rects":[[52.3574333190918,604.72705078125,95.69562149047852,10.5]],"start":155,"text":"happens-before"}],"type":5},{"date":"2021-11-23 21:33:38","docid":0,"fillcolor":"ffffed99","folded":true,"id":811,"markups":[{"date":"2021-11-23 21:34:59","docid":0,"fillcolor":"ffffed99","folded":false,"id":814,"markups":[{"date":"2021-11-23 21:33:51","docid":0,"id":812,"linecolor":"ffff8280","linewidth":7,"originaltext":"不能保证原子性","page":105,"rect":[143.71097130027147,106.20236993973487,289.19934767542674,128.26328582918327],"type":11}],"originaltext":"balking 模式习题","page":105,"textblocks":[{"first":[52.35818099975586,106.73075866699219,6.174217224121094,13.5],"last":[120.10877227783203,106.73075866699219,9.753898620605469,13.5],"length":12,"rects":[[52.35818099975586,106.73075866699219,77.50448989868164,13.5]],"start":6,"text":"balking 模式习题"}],"type":5},{"date":"2021-11-23 21:34:50","docid":0,"fillcolor":"ffffed99","id":813,"markups":[{"date":"2021-11-23 21:35:19","docid":0,"fillcolor":"ffffed99","id":815,"originaltext":"饿汉式：类加载就会导致该单实例对象被创建懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建","page":105,"textblocks":[{"first":[66.61388397216797,476.93011474609375,9.753898620605469,12.5],"last":[398.24664306640625,498.4391174316406,9.75390625,13.5],"length":56,"rects":[[66.61388397216797,476.93011474609375,195.07807159423828,12.5],[66.61388397216797,498.4391174316406,341.3866653442383,13.5]],"start":145,"text":"饿汉式：类加载就会导致该单实例对象被创建\n懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建"}],"type":5},{"date":"2021-11-23 21:38:08","docid":0,"fillcolor":"ffffed99","folded":true,"id":817,"markups":[{"date":"2021-11-23 21:37:53","docid":0,"id":816,"linecolor":"ffff8280","linewidth":7,"originaltext":"反序列化的时候也会创建一个对象，这样就有两个对象，当我们使用readResolve方法的时候，反序列化会使用这个方法防护的对象","page":105,"rect":[227.50213560619676,713.7423979773358,536.1766485198405,745.4577892834355],"type":11}],"originaltext":"实现1：","page":105,"textblocks":[{"first":[52.35818099975586,521.9481201171875,9.753898620605469,12.5],"last":[77.43546295166016,521.9481201171875,9.753898620605469,12.5],"length":4,"rects":[[52.35818099975586,521.9481201171875,34.831180572509766,12.5]],"start":202,"text":"实现1："}],"type":5},{"date":"2021-11-23 21:42:22","docid":0,"fillcolor":"ffffed99","id":818,"originaltext":"实现2：","page":106,"textblocks":[{"first":[52.35818099975586,56.7606201171875,9.753898620605469,12.5],"last":[77.43546295166016,56.7606201171875,9.753898620605469,12.5],"length":4,"rects":[[52.35818099975586,56.7606201171875,34.831180572509766,12.5]],"start":0,"text":"实现2："}],"type":5},{"date":"2021-11-23 21:55:22","docid":0,"fillcolor":"ffffed99","id":819,"originaltext":"实现3：","page":106,"textblocks":[{"first":[52.35818099975586,233.08111572265625,9.753898620605469,12.5],"last":[77.43546295166016,233.08111572265625,9.753898620605469,12.5],"length":4,"rects":[[52.35818099975586,233.08111572265625,34.831180572509766,12.5]],"start":7,"text":"实现3："}],"type":5},{"date":"2021-11-23 21:55:26","docid":0,"fillcolor":"ffffed99","id":820,"originaltext":"实现4：DCL","page":106,"textblocks":[{"first":[52.35818099975586,451.6726379394531,9.753898620605469,10.5],"last":[100.45466613769531,451.6726379394531,5.0622711181640625,10.5],"length":7,"rects":[[52.35818099975586,451.6726379394531,53.158756256103516,10.5]],"start":14,"text":"实现4：DCL"}],"type":5},{"date":"2021-11-23 21:55:29","docid":0,"fillcolor":"ffffed99","id":821,"originaltext":"实现5：","page":107,"textblocks":[{"first":[52.35818099975586,56.76812744140625,9.753898620605469,12.5],"last":[77.43546295166016,56.76812744140625,9.753898620605469,12.5],"length":4,"rects":[[52.35818099975586,56.76812744140625,34.831180572509766,12.5]],"start":0,"text":"实现5："}],"type":5}],"originaltext":"线程安全单例习题","page":105,"textblocks":[{"first":[52.35818099975586,414.6552429199219,9.753898620605469,12.5],"last":[120.6354751586914,414.6552429199219,9.753898620605469,12.5],"length":8,"rects":[[52.35818099975586,414.6552429199219,78.03119277954102,12.5]],"start":59,"text":"线程安全单例习题"}],"type":5}],"originaltext":"习题","page":105,"textblocks":[{"first":[52.35818099975586,82.0211181640625,12.192371368408203,13.5],"last":[64.55055236816406,82.0211181640625,12.192375183105469,13.5],"length":2,"rects":[[52.35818099975586,82.0211181640625,24.384746551513672,13.5]],"start":2,"text":"习题"}],"type":5}],"originaltext":"Java 内存模型","page":96,"textblocks":[{"first":[77.0404281616211,81.73509216308594,4.842811584472656,18.5],"last":[155.5671844482422,81.73509216308594,14.630844116210938,18.5],"length":9,"rects":[[77.0404281616211,81.73509216308594,93.15760040283203,18.5]],"start":50,"text":"Java 内存模型"}],"type":5}],"originaltext":"共享模型之内存","page":95,"textblocks":[{"first":[71.37303924560547,699.5301513671875,17.06932830810547,20.5],"last":[173.78897094726562,699.5301513671875,17.069320678710938,20.5],"length":7,"rects":[[71.37303924560547,699.5301513671875,119.4852523803711,20.5]],"start":657,"text":"共享模型之内存"}],"type":5},{"date":"2021-11-24 11:46:59","docid":0,"fillcolor":"ffffed99","folded":true,"id":823,"markups":[{"content":"cas操作每一次都会进行一次对比，对比这一次修改的值是否有效（使用主存数据对比的方式，成功就进行赋值操作）\n原子性：其实说的是对比成功后并赋值的两个操作，而用while循环保证原子性的扩展","date":"2021-11-24 17:58:54","docid":0,"fillcolor":"ffffed99","folded":true,"id":824,"markups":[{"date":"2021-11-24 17:59:09","docid":0,"fillcolor":"ffffed99","folded":false,"id":825,"markups":[{"content":"比较然后设置，这是原子操作所以可以运用到保证线程安全里面","date":"2021-11-24 18:01:32","docid":0,"id":826,"linecolor":"ffff8280","linewidth":7,"originaltext":" CAS：比较然后设置每次都会获取主存中的数据和要设置期望值比较，成功就表示这是可以更改会主存，没有发生线程安全问题","page":112,"rect":[150.0139572443819,744.4577892834355,476.42999151157716,787.8727939270641],"type":11}],"originaltext":"其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。","page":112,"textblocks":[{"first":[66.61388397216797,723.7064819335938,9.753898620605469,14.16455078125],"last":[125.1395263671875,738.5441284179688,9.75390625,13.5],"length":71,"rects":[[66.61388397216797,723.7064819335938,446.9281692504883,14.16455078125],[66.61613464355469,738.5441284179688,68.27729797363281,13.5]],"start":218,"text":"其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交\n换】的原子性。"}],"type":5},{"content":"由于cas操作必须避免CPU缓存优化带来的问题，所以一定要使用到volatile修饰变量","date":"2021-11-24 18:03:49","docid":0,"fillcolor":"ffffed99","folded":false,"id":827,"markups":[{"date":"2021-11-24 18:06:16","docid":0,"fillcolor":"ffffed99","id":828,"originaltext":"volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果","page":114,"textblocks":[{"first":[66.61312866210938,295.0545654296875,4.8867034912109375,13.5],"last":[392.9667663574219,332.6198425292969,9.75390625,13.5],"length":102,"rects":[[66.61312866210938,295.0545654296875,464.1785583496094,13.5],[66.61312866210938,310.060546875,29.261695861816406,13.5],[52.3574333190918,332.6198425292969,350.3632392883301,13.5]],"start":443,"text":"volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原\n子性）\nCAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果"}],"type":5}],"originaltext":"volatile","page":114,"textblocks":[{"first":[52.3574333190918,187.81134033203125,6.937461853027344,12.5],"last":[90.65367889404297,187.81134033203125,7.205696105957031,12.5],"length":8,"rects":[[52.3574333190918,187.81134033203125,45.5019416809082,12.5]],"start":280,"text":"volatile"}],"type":5},{"content":"发生线程上下文消耗远大于CPU重复运行的消耗\n\n一个线程运行在一个CPU核心，如果线程数大于CPU核心数的话，导致没有CPU运行这个线程，多余线程进入可运行状态，还是发生线程的上下文切换\n\n所以使用无锁来保证线程的原子性的时候，一定要确定开启的线程数小于等于CPU核心数","date":"2021-11-24 18:09:36","docid":0,"fillcolor":"ffffed99","id":829,"originaltext":"为什么无锁效率高","page":114,"textblocks":[{"first":[52.3574333190918,516.9439697265625,12.192371368408203,15.5],"last":[137.7040557861328,516.9439697265625,12.192367553710938,15.5],"length":8,"rects":[[52.3574333190918,516.9439697265625,97.53899002075195,15.5]],"start":560,"text":"为什么无锁效率高"}],"type":5},{"date":"2021-11-24 18:20:34","docid":0,"fillcolor":"ffffed99","folded":true,"id":830,"markups":[{"date":"2021-11-24 18:20:59","docid":0,"fillcolor":"ffffed99","id":831,"originaltext":"CAS 是基于乐观锁的思想","page":115,"textblocks":[{"first":[74.86717987060547,494.95684814453125,6.1547088623046875,12.5],"last":[173.11073303222656,494.95684814453125,9.75390625,12.5],"length":13,"rects":[[74.86717987060547,494.95684814453125,107.9974594116211,12.5]],"start":59,"text":"CAS 是基于乐观锁的思想"}],"type":5},{"date":"2021-11-24 18:21:04","docid":0,"fillcolor":"ffffed99","id":832,"originaltext":"synchronized 是基于悲观锁的思想","page":115,"textblocks":[{"first":[74.86717987060547,529.1217041015625,4.652610778808594,14.5],"last":[215.7608184814453,529.1217041015625,9.75390625,14.5],"length":22,"rects":[[74.86717987060547,529.1217041015625,150.64754486083984,14.5]],"start":114,"text":"synchronized 是基于悲观锁的思想"}],"type":5},{"date":"2021-11-24 18:23:49","docid":0,"fillcolor":"ffffed99","id":833,"originaltext":"CAS 体现的是无锁并发、无阻塞并发","page":115,"textblocks":[{"first":[74.86717987060547,564.7362060546875,6.1547088623046875,12.5],"last":[221.88026428222656,564.7362060546875,9.75390625,12.5],"length":18,"rects":[[74.86717987060547,564.7362060546875,156.7669906616211,12.5]],"start":187,"text":"CAS 体现的是无锁并发、无阻塞并发"}],"type":5}],"originaltext":"CAS 的特点","page":115,"textblocks":[{"first":[52.35818099975586,446.68719482421875,7.766544342041016,12.5],"last":[102.7730941772461,446.68719482421875,12.192375183105469,12.5],"length":7,"rects":[[52.35818099975586,446.68719482421875,62.6072883605957,12.5]],"start":2,"text":"CAS 的特点"}],"type":5}],"originaltext":"CAS 与 volatile","page":111,"textblocks":[{"first":[77.03968048095703,505.6953125,9.319854736328125,17.5],"last":[172.69992065429688,505.6953125,8.646835327148438,17.5],"length":14,"rects":[[77.03968048095703,505.6953125,104.30707550048828,17.5]],"start":37,"text":"CAS 与 volatile"}],"type":5},{"content":"比较的是改变期间，整数数据是否被其他线程改变，使用了Unsafe","date":"2021-11-24 18:25:17","docid":0,"fillcolor":"ffffed99","folded":true,"id":834,"markups":[{"date":"2021-11-24 18:28:29","docid":0,"fillcolor":"ffffed99","folded":true,"id":841,"markups":[{"date":"2021-11-24 18:25:42","docid":0,"fillcolor":"ffffed99","id":837,"originaltext":"AtomicBoolean","page":116,"textblocks":[{"first":[74.86717987060547,181.8135986328125,6.174217224121094,9.5],"last":[138.023681640625,181.8135986328125,5.9888916015625,9.5],"length":13,"rects":[[74.86717987060547,181.8135986328125,69.14539337158203,9.5]],"start":30,"text":"AtomicBoolean"}],"type":5},{"date":"2021-11-24 18:25:43","docid":0,"fillcolor":"ffffed99","id":838,"originaltext":"AtomicInteger","page":116,"textblocks":[{"first":[74.86717987060547,196.8203125,6.174217224121094,9.5],"last":[134.99996948242188,196.8203125,3.979583740234375,9.5],"length":13,"rects":[[74.86717987060547,196.8203125,64.11237335205078,9.5]],"start":44,"text":"AtomicInteger"}],"type":5},{"date":"2021-11-24 18:25:50","docid":0,"fillcolor":"ffffed99","id":840,"originaltext":"AtomicLong","page":116,"textblocks":[{"first":[74.86717987060547,211.82635498046875,6.174217224121094,9.5],"last":[123.5001220703125,211.82635498046875,5.3451385498046875,9.5],"length":10,"rects":[[74.86717987060547,211.82635498046875,53.97808074951172,9.5]],"start":58,"text":"AtomicLong"}],"type":5}],"originaltext":"J.U.C 并发包提供了：","page":116,"textblocks":[{"first":[52.35818099975586,157.0023651123047,2.604290008544922,13.5],"last":[133.5736541748047,157.0023651123047,9.75390625,13.5],"length":13,"rects":[[52.35818099975586,157.0023651123047,90.96937942504883,13.5]],"start":16,"text":"J.U.C 并发包提供了："}],"type":5},{"content":"使用CAS操作需要配合while，不断的去尝试修改，比较麻烦，所以使用其他封装了CAS的方法","date":"2021-11-24 18:28:41","docid":0,"fillcolor":"ffffed99","id":842,"originaltext":"以 AtomicInteger 为例","page":116,"textblocks":[{"first":[52.35818099975586,232.78562927246094,9.753898620605469,13.5],"last":[141.0436553955078,232.78562927246094,9.75390625,13.5],"length":18,"rects":[[52.35818099975586,232.78562927246094,98.43938064575195,13.5]],"start":69,"text":"以 AtomicInteger 为例"}],"type":5},{"date":"2021-11-24 18:57:17","docid":0,"id":844,"linecolor":"ffff8280","linewidth":7,"originaltext":"本质还是使用while+CAS保证并发安全","page":116,"rect":[204.59574208978336,138.47956080377193,399.25888727400576,164.46835373076837],"type":11}],"originaltext":"原子整数","page":116,"textblocks":[{"first":[76.99653625488281,128.29217529296875,14.630851745605469,17.5],"last":[120.88909149169922,128.29217529296875,14.630851745605469,17.5],"length":4,"rects":[[76.99653625488281,128.29217529296875,58.523406982421875,17.5]],"start":10,"text":"原子整数"}],"type":5},{"content":"重要：修改引用专用，封装了引用是否修改的方法，使用了Unsafe\n比较的是改变期间，引用是否被其他线程改变","date":"2021-11-24 18:57:37","docid":0,"fillcolor":"ffffed99","folded":true,"id":845,"markups":[{"date":"2021-11-24 18:57:42","docid":0,"fillcolor":"ffffed99","folded":false,"id":846,"markups":[{"date":"2021-11-24 19:55:29","docid":0,"fillcolor":"ffffed99","id":850,"originaltext":"安全实现-使用 CAS","page":118,"textblocks":[{"first":[52.35818099975586,627.3485107421875,12.192371368408203,15.5],"last":[148.77528381347656,627.3485107421875,6.7180023193359375,15.5],"length":11,"rects":[[52.35818099975586,627.3485107421875,103.13510513305664,15.5]],"start":16,"text":"安全实现-使用 CAS"}],"type":5},{"date":"2021-11-24 19:55:31","docid":0,"fillcolor":"ffffed99","id":851,"originaltext":"安全实现-使用锁","page":118,"textblocks":[{"first":[52.35818099975586,261.844970703125,12.192371368408203,14.5],"last":[129.42599487304688,261.844970703125,12.1923828125,14.5],"length":8,"rects":[[52.35818099975586,261.844970703125,89.26019668579102,14.5]],"start":2,"text":"安全实现-使用锁"}],"type":5},{"date":"2021-11-24 19:55:33","docid":0,"fillcolor":"ffffed99","id":852,"originaltext":"不安全实现","page":117,"textblocks":[{"first":[52.35818099975586,655.7576904296875,12.192371368408203,14.5],"last":[101.12767791748047,655.7576904296875,12.192375183105469,14.5],"length":5,"rects":[[52.35818099975586,655.7576904296875,60.96187210083008,14.5]],"start":132,"text":"不安全实现"}],"type":5},{"content":"在第一次获取值到CAS操作的时间段，线程不能察觉到其他线程对共享变量的修改然后修改回去的操作这就是ABA问题","date":"2021-11-24 19:55:24","docid":0,"fillcolor":"ffffed99","id":849,"originaltext":"ABA 问题及解决","page":119,"textblocks":[{"first":[52.3574333190918,488.5317687988281,8.412738800048828,15.5],"last":[129.02084350585938,488.5317687988281,12.1923828125,15.5],"length":9,"rects":[[52.3574333190918,488.5317687988281,88.85579299926758,15.5]],"start":65,"text":"ABA 问题及解决"}],"type":5}],"originaltext":"AtomicReference","page":117,"textblocks":[{"first":[74.86717987060547,112.28692626953125,6.174217224121094,8.5],"last":[146.72715759277344,112.28692626953125,5.4719390869140625,8.5],"length":15,"rects":[[74.86717987060547,112.28692626953125,77.33191680908203,8.5]],"start":23,"text":"AtomicReference"}],"type":5},{"date":"2021-11-24 19:59:20","docid":0,"fillcolor":"ffffed99","folded":false,"id":853,"markups":[{"content":"遵从版本号规则谁动了引用，版本号就要+1\n定义一个变量控制是否发生ABA问题，CAS的时候会带上变量，只要动过就会导致变量的更改","date":"2021-11-24 20:00:44","docid":0,"fillcolor":"ffffed99","id":854,"originaltext":"主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号","page":120,"textblocks":[{"first":[52.3574333190918,233.07666015625,9.753898620605469,12.5],"last":[530.560546875,271.0419921875,9.75390625,13.5],"length":116,"rects":[[52.3574333190918,233.07666015625,486.56584548950195,12.5],[52.355934143066406,248.08184814453125,29.261695861816406,12.5],[52.355934143066406,271.0419921875,487.9585189819336,13.5]],"start":192,"text":"主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程\n希望：\n只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号"}],"type":5},{"date":"2021-11-24 20:03:50","docid":0,"id":855,"linecolor":"ffff8280","linewidth":7,"originaltext":"创建的时候需要设置版本号","page":120,"rect":[437.82447607508345,342.03410318826377,554.397643362442,358.6520987676365],"type":11},{"date":"2021-11-24 20:04:15","docid":0,"id":856,"linecolor":"ffff8280","linewidth":7,"originaltext":"cas操作需要添加版本号的新旧值","page":120,"rect":[373.79069419965504,471.14286664441204,513.7908548560728,487.7608622237848],"type":11}],"originaltext":"AtomicStampedReference","page":120,"textblocks":[{"first":[52.355934143066406,298.3515625,6.730190277099609,8.5],"last":[173.27279663085938,298.3515625,5.764556884765625,8.5],"length":22,"rects":[[52.355934143066406,298.3515625,126.6814193725586,8.5]],"start":309,"text":"AtomicStampedReference"}],"type":5},{"content":"，使用了Unsafe","date":"2021-11-24 20:06:25","docid":0,"fillcolor":"ffffed99","folded":true,"id":857,"markups":[{"content":"定义一个状态来控制是否发生ABA问题，只要发生了，不管多少次，最后改变状态即可，使用了Unsafe","date":"2021-11-24 20:06:33","docid":0,"fillcolor":"ffffed99","id":859,"originaltext":"但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了","page":121,"textblocks":[{"first":[52.35818099975586,257.83880615234375,9.753898620605469,12.5],"last":[413.25250244140625,257.83880615234375,9.75390625,12.5],"length":38,"rects":[[52.35818099975586,257.83880615234375,370.6482276916504,12.5]],"start":450,"text":"但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了"}],"type":5}],"originaltext":"AtomicMarkableReference","page":121,"textblocks":[{"first":[52.35818099975586,274.84478759765625,6.174217224121094,9.5],"last":[166.89149475097656,274.84478759765625,5.4719390869140625,9.5],"length":23,"rects":[[52.35818099975586,274.84478759765625,120.00525283813477,9.5]],"start":489,"text":"AtomicMarkableReference"}],"type":5}],"originaltext":"原子引用","page":117,"textblocks":[{"first":[76.99653625488281,58.26995849609375,14.630851745605469,16.5],"last":[120.88909149169922,58.26995849609375,14.630851745605469,16.5],"length":4,"rects":[[76.99653625488281,58.26995849609375,58.523406982421875,16.5]],"start":4,"text":"原子引用"}],"type":5},{"content":"对比的是 数组内容 改变期间是否被其他线程改变","date":"2021-11-24 20:23:44","docid":0,"fillcolor":"ffffed99","folded":true,"id":860,"markups":[{"date":"2021-11-24 20:26:04","docid":0,"fillcolor":"ffffed99","id":861,"originaltext":"AtomicIntegerArrayAtomicLongArrayAtomicReferenceArray","page":123,"textblocks":[{"first":[74.86717987060547,88.7801513671875,6.174217224121094,9.5],"last":[171.56170654296875,118.79290771484375,4.9159698486328125,9.5],"length":55,"rects":[[74.86717987060547,88.7801513671875,88.3893814086914,9.5],[74.86717987060547,103.786865234375,78.2544937133789,9.5],[74.86717987060547,118.79290771484375,101.6104965209961,9.5]],"start":10,"text":"AtomicIntegerArray\nAtomicLongArray\nAtomicReferenceArray"}],"type":5}],"originaltext":"原子数组","page":123,"textblocks":[{"first":[76.99653625488281,57.76995849609375,14.630851745605469,17.5],"last":[120.88909149169922,57.76995849609375,14.630851745605469,17.5],"length":4,"rects":[[76.99653625488281,57.76995849609375,58.523406982421875,17.5]],"start":4,"text":"原子数组"}],"type":5},{"content":"对比的是 对象的属性或者叫做成员变量 改变期间是否被其他线程改变","date":"2021-11-24 21:04:16","docid":0,"fillcolor":"ffffed99","folded":true,"id":862,"markups":[{"date":"2021-11-24 21:10:12","docid":0,"id":863,"linecolor":"ffff8280","linewidth":7,"originaltext":"字段更新器需要精确到哪个类的哪个字段，如果是引用类型的字段更新器，需要给出字段的类型","page":125,"rect":[355.04909950440776,51.018785559284424,509.1054561822609,92.62557406565364],"type":11}],"originaltext":"字段更新器","page":124,"textblocks":[{"first":[76.99578857421875,478.677734375,14.630851745605469,17.5],"last":[135.51919555664062,478.677734375,14.630844116210938,17.5],"length":5,"rects":[[76.99578857421875,478.677734375,73.15425109863281,17.5]],"start":159,"text":"字段更新器"}],"type":5},{"content":"累加器效果比较好","date":"2021-11-24 21:17:55","docid":0,"fillcolor":"ffffed99","folded":true,"id":864,"markups":[{"date":"2021-11-24 21:22:18","docid":0,"fillcolor":"ffffed99","folded":true,"id":865,"markups":[{"content":"对共享变量设置累加单元","date":"2021-11-24 21:24:20","docid":0,"fillcolor":"ffffed99","id":866,"originaltext":"性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]... 最后将结果汇总。","page":126,"textblocks":[{"first":[52.3574333190918,504.68896484375,9.753898620605469,12.5],"last":[159.4657745361328,519.6949462890625,9.75390625,12.5],"length":81,"rects":[[52.3574333190918,504.68896484375,451.8426704406738,12.5],[52.3574333190918,519.6949462890625,116.86224746704102,12.5]],"start":199,"text":"性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加\nCell[1]... 最后将结果汇总。"}],"type":5}],"originaltext":"LongAdder","page":126,"textblocks":[{"first":[156.5328369140625,208.54638671875,4.82818603515625,8.778518676757812],"last":[195.1583251953125,208.54638671875,4.82818603515625,8.778518676757812],"length":9,"rects":[[156.5328369140625,208.54638671875,43.45367431640625,8.778518676757812]],"start":589,"text":"LongAdder"}],"type":5},{"date":"2021-11-24 21:31:04","docid":0,"fillcolor":"ffffed99","folded":true,"id":867,"markups":[{"date":"2021-11-24 23:54:26","docid":0,"fillcolor":"ffffed99","id":868,"originaltext":"cas 锁","page":127,"textblocks":[{"first":[52.35818099975586,78.01123046875,6.266880035400391,10.5],"last":[75.2063217163086,78.01123046875,12.192375183105469,10.5],"length":5,"rects":[[52.35818099975586,78.01123046875,35.0405158996582,10.5]],"start":0,"text":"cas 锁"}],"type":5}],"originaltext":"源码之 LongAdder","page":126,"textblocks":[{"first":[62.14809799194336,580.7704467773438,12.192371368408203,16.5],"last":[162.28407287597656,580.7704467773438,5.53533935546875,16.5],"length":13,"rects":[[62.14809799194336,580.7704467773438,105.67131423950195,16.5]],"start":331,"text":"源码之 LongAdder"}],"type":5},{"date":"2021-11-24 23:55:40","docid":0,"fillcolor":"ffffed99","folded":false,"id":869,"markups":[{"content":"伪共享原理：\n因为CPU具有多级缓存，每个CPU核心运行一个线程，也有自己的缓存，如果他们缓存中缓存行存在同一个数据，其中要给核心写回数据，那么另一个缓存行中的同一份的数据就会作废，相当于没有进行到共享\n\n伪共享：\n而累加单元的大小是24byte，缓存行的大小是64byte，所以一个缓存行绝对装的下多个累加单元\n问题就出在这每个累加单元交给一对一 一个线程，但是一个缓存行存在多个累加单元，当前线程修改了自己的累加单元势必会影响到别的累加单元，别的核心就会认为修改了同一份数据导致将自己数据作废，导致伪共享\n\n解决办法：\n让每个累加单元单独占一个缓存行，修改就不会影响到别的缓存行中的累加单元","date":"2021-11-24 23:55:56","docid":0,"fillcolor":"ffffed99","id":870,"originaltext":"// 防止缓存行伪共享@sun.misc.Contended","page":128,"textblocks":[{"first":[64.8784408569336,245.81362915039062,4.828178405761719,13.15325927734375],"last":[151.73544311523438,263.322021484375,4.82818603515625,8.77850341796875],"length":31,"rects":[[64.8784408569336,245.81362915039062,84.68634796142578,13.15325927734375],[64.8784408569336,263.322021484375,91.68518829345703,8.77850341796875]],"start":317,"text":"// 防止缓存行伪共享\n@sun.misc.Contended"}],"type":5},{"date":"2021-11-24 23:57:51","docid":0,"fillcolor":"ffffed99","id":872,"originaltext":"每个缓存行对应着一块内存，一般是 64 byte","page":129,"textblocks":[{"first":[159.65109252929688,586.1287841796875,9.75390625,14.5],"last":[346.0759582519531,586.1287841796875,5.471923828125,14.5],"length":24,"rects":[[159.65109252929688,586.1287841796875,191.89678955078125,14.5]],"start":153,"text":"每个缓存行对应着一块内存，一般是 64 byte"}],"type":5},{"content":"伪共享原理：\n因为CPU具有多级缓存，每个CPU核心运行一个线程，也有自己的缓存，如果他们缓存中缓存行存在同一个数据，其中要给核心写回数据，那么另一个缓存行中的同一份的数据就会作废，相当于没有进行到共享\n\n伪共享：\n而累加单元的大小是24byte，缓存行的大小是64byte，所以一个缓存行绝对装的下多个累加单元\n问题就出在这每个累加单元交给一对一 一个线程，但是一个缓存行存在多个累加单元，当前线程修改了自己的累加单元势必会影响到别的累加单元，别的核心就会认为修改了同一份数据导致将自己数据作废，导致伪共享\n\n解决办法：\n让每个累加单元单独占一个缓存行，修改就不会影响到别的缓存行中的累加单元","date":"2021-11-24 23:57:46","docid":0,"fillcolor":"ffffed99","id":871,"originaltext":"一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value）","page":130,"textblocks":[{"first":[259.30975341796875,266.8431396484375,9.75390625,12.5],"last":[504.28863525390625,266.8431396484375,9.75390625,12.5],"length":39,"rects":[[259.30975341796875,266.8431396484375,254.7327880859375,12.5]],"start":25,"text":"一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value）"}],"type":5}],"originaltext":"原理之伪共享","page":128,"textblocks":[{"first":[62.14809799194336,185.31658935546875,12.192371368408203,15.5],"last":[123.10997009277344,185.31658935546875,12.192367553710938,15.5],"length":6,"rects":[[62.14809799194336,185.31658935546875,73.15423965454102,15.5]],"start":274,"text":"原理之伪共享"}],"type":5},{"content":"使用了懒加载（创建了对象但是没有初始化和赋值）\n没有竞争就使用long变量base进行累加，累加失败进入创建列加单元\n竞争查看有没有创建累加单元cells，创建就使用累加单元，没有创建就创建累加单元","date":"2021-11-25 00:09:46","docid":0,"fillcolor":"ffffed99","id":873,"originaltext":"add 流程图","page":131,"textblocks":[{"first":[52.35818099975586,305.10693359375,5.423168182373047,12.5],"last":[91.75418090820312,305.10693359375,9.753898620605469,12.5],"length":7,"rects":[[52.35818099975586,305.10693359375,49.149898529052734,12.5]],"start":102,"text":"add 流程图"}],"type":5},{"date":"2021-11-25 00:14:00","docid":0,"fillcolor":"ffffed99","id":874,"originaltext":"longAccumulate 流程图","page":132,"textblocks":[{"first":[52.35818099975586,560.9647827148438,2.4677352905273438,8.5],"last":[147.4016876220703,560.9647827148438,9.75390625,8.5],"length":18,"rects":[[52.35818099975586,560.9647827148438,104.79741287231445,8.5]],"start":87,"text":"longAccumulate 流程图"}],"type":5},{"date":"2021-11-25 00:22:04","docid":0,"fillcolor":"ffffed99","id":875,"originaltext":"获取最终结果通过 sum 方法","page":133,"textblocks":[{"first":[52.35818099975586,523.146484375,9.753898620605469,13.5],"last":[164.898681640625,523.146484375,9.75390625,13.5],"length":15,"rects":[[52.35818099975586,523.146484375,122.29440689086914,13.5]],"start":210,"text":"获取最终结果通过 sum 方法"}],"type":5}],"originaltext":" 原子累加器","page":125,"textblocks":[{"first":[73.23565673828125,443.6639404296875,3.8040237426757812,17.5],"last":[135.51919555664062,443.6639404296875,14.630844116210938,17.5],"length":6,"rects":[[73.23565673828125,443.6639404296875,76.91438293457031,17.5]],"start":22,"text":" 原子累加器"}],"type":5},{"content":"对内存进行操作，只能通过反射进行获取","date":"2021-11-25 00:22:24","docid":0,"fillcolor":"ffffed99","folded":true,"id":876,"markups":[{"date":"2021-11-25 00:22:35","docid":0,"fillcolor":"ffffed99","id":877,"originaltext":"Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得","page":134,"textblocks":[{"first":[52.35818099975586,83.02862548828125,7.100837707519531,12.5],"last":[491.90802001953125,83.02862548828125,9.75390625,12.5],"length":53,"rects":[[52.35818099975586,83.02862548828125,449.3037452697754,12.5]],"start":4,"text":"Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得"}],"type":5},{"date":"2021-11-25 00:27:25","docid":0,"fillcolor":"ffffed99","id":878,"originaltext":"Unsafe CAS 操作","page":134,"textblocks":[{"first":[52.35818099975586,392.5483093261719,9.21743392944336,14.5],"last":[136.29049682617188,392.5483093261719,12.1923828125,14.5],"length":13,"rects":[[52.35818099975586,392.5483093261719,96.12469863891602,14.5]],"start":62,"text":"Unsafe CAS 操作"}],"type":5},{"date":"2021-11-25 00:29:07","docid":0,"fillcolor":"ffffed99","id":879,"originaltext":"使用自定义的 AtomicData 实现之前线程安全的原子整数 Account 实现","page":135,"textblocks":[{"first":[52.3574333190918,116.0328369140625,9.753898620605469,12.5],"last":[347.43243408203125,116.0328369140625,9.75390625,12.5],"length":42,"rects":[[52.3574333190918,116.0328369140625,304.82890701293945,12.5]],"start":27,"text":"使用自定义的 AtomicData 实现之前线程安全的原子整数 Account 实现"}],"type":5},{"date":"2021-11-25 00:30:17","docid":0,"fillcolor":"ffffed99","id":880,"originaltext":"Account 实现","page":135,"textblocks":[{"first":[52.35818099975586,647.247802734375,6.174217224121094,8.5],"last":[101.4135513305664,647.247802734375,9.753898620605469,8.5],"length":10,"rects":[[52.35818099975586,647.247802734375,58.809268951416016,8.5]],"start":72,"text":"Account 实现"}],"type":5}],"originaltext":"Unsafe","page":133,"textblocks":[{"first":[77.0404281616211,756.0492553710938,11.060920715332031,11.5],"last":[119.48452758789062,756.0492553710938,8.646835327148438,11.5],"length":6,"rects":[[77.0404281616211,756.0492553710938,51.09093475341797,11.5]],"start":234,"text":"Unsafe"}],"type":5}],"originaltext":"共享模型之无锁","page":107,"textblocks":[{"first":[71.37303924560547,623.3485107421875,17.06932830810547,20.5],"last":[173.78897094726562,623.3485107421875,17.069320678710938,20.5],"length":7,"rects":[[71.37303924560547,623.3485107421875,119.4852523803711,20.5]],"start":165,"text":"共享模型之无锁"}],"type":5},{"date":"2021-11-25 15:48:27","docid":0,"fillcolor":"ffffed99","folded":true,"id":882,"markups":[{"content":"<body style=\" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;\">\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">因为底层没有使用不可变，他进行改变value的时候，变得线程可能已经改变准备提交，提交成功，变的线程又进行了改变，导致了发生线程安全</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">比如时期类转换：第一个日期转换成功，又被第二个日期类进行了赋值，这样导致第一个日期转换是第二个日期转换的结果，线程不安全</p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:12pt;\">不可变做到线程安全</span></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">所以不可变保证的是底层方法对属性的原子性，只要每一个属性不能改变只能读取那么就可以保证线程安全</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">那么怎么进行赋值操作，返回副本数据即可，这个副本数据是线程创建的，那么就不会被其他线程访问到，这样就可以做到线程安全。</p>\n<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">上面的不可变做到了Function方法获取参数然后返回的原子性，但是副本数据对象创建过多也导致了问题</p>\n<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">使用享元模式：不管取多少，先进行创建一个对象要相同拿去用即可，如果没有再进行创建新的对象</p></body>","date":"2021-11-25 15:51:13","docid":0,"fillcolor":"ffffed99","folded":true,"id":886,"markups":[{"date":"2021-11-25 15:51:20","docid":0,"fillcolor":"ffffed99","id":887,"originaltext":"由于 SimpleDateFormat 不是线程安全的","page":136,"textblocks":[{"first":[149.89718627929688,744.7894897460938,9.75390625,12.5],"last":[318.0447082519531,744.7894897460938,9.75390625,12.5],"length":27,"rects":[[149.89718627929688,744.7894897460938,177.90142822265625,12.5]],"start":163,"text":"由于 SimpleDateFormat 不是线程安全的"}],"type":5},{"date":"2021-11-25 16:07:23","docid":0,"fillcolor":"ffffed99","id":888,"originaltext":"如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！","page":138,"textblocks":[{"first":[52.35818099975586,272.5965576171875,9.753898620605469,13.5],"last":[471.7760925292969,272.5965576171875,9.75390625,13.5],"length":44,"rects":[[52.35818099975586,272.5965576171875,429.171817779541,13.5]],"start":12,"text":"如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！"}],"type":5},{"date":"2021-11-25 15:50:09","docid":0,"id":885,"linecolor":"ffff8280","linewidth":7,"originaltext":"只有读没有写的的共享变量是线程安全的，最典型的就是不可变类","page":136,"rect":[209.31382596449146,695.7335918641814,355.1583337531773,747.3615094092663],"type":11}],"originaltext":"日期转换的问题","page":136,"textblocks":[{"first":[76.99653625488281,689.018798828125,14.630851745605469,17.5],"last":[164.78163146972656,689.018798828125,14.630844116210938,17.5],"length":7,"rects":[[76.99653625488281,689.018798828125,102.41593933105469,17.5]],"start":138,"text":"日期转换的问题"}],"type":5},{"content":"他们都是线程安全的，但是多个方法组合在一起就不是线程安全的","date":"2021-11-25 16:18:45","docid":0,"fillcolor":"ffffed99","folded":true,"id":893,"markups":[{"date":"2021-11-25 16:19:18","docid":0,"fillcolor":"ffffed99","folded":true,"id":894,"markups":[{"date":"2021-11-25 16:09:16","docid":0,"id":889,"linecolor":"ffff8280","linewidth":7,"originaltext":"hash是私有的并没有暴露接口，所以是安全的","page":138,"rect":[264.0000062942506,697.4400166282658,409.00000972747824,731.080017406464],"type":11},{"date":"2021-11-25 16:09:39","docid":0,"id":890,"linecolor":"ffff8280","linewidth":7,"originaltext":"char[]数组不能改只能读，所以线程安全","page":138,"rect":[221.86487379944825,652.9311012043123,460.93905344725806,675.7123559380482],"type":11}],"originaltext":" String 类也是不可变","page":138,"textblocks":[{"first":[149.89718627929688,574.1224365234375,2.5360107421875,14.5],"last":[230.3098602294922,574.1224365234375,9.75390625,14.5],"length":14,"rects":[[149.89718627929688,574.1224365234375,90.16658020019531,14.5]],"start":174,"text":" String 类也是不可变"}],"type":5},{"date":"2021-11-25 16:18:39","docid":0,"fillcolor":"ffffed99","folded":true,"id":892,"markups":[{"date":"2021-11-25 16:19:41","docid":0,"fillcolor":"ffffed99","id":895,"originaltext":"类、类中所有属性都是 final ","page":139,"textblocks":[{"first":[81.61988067626953,83.0203857421875,9.753898620605469,12.5],"last":[201.34901428222656,83.0203857421875,2.5360107421875,12.5],"length":17,"rects":[[81.61988067626953,83.0203857421875,122.26514434814453,12.5]],"start":14,"text":"类、类中所有属性都是 final "}],"type":5},{"date":"2021-11-25 16:19:52","docid":0,"fillcolor":"ffffed99","id":896,"originaltext":"属性用 final 修饰保证了该属性是只读的，不能修改类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性","page":139,"textblocks":[{"first":[74.86717987060547,104.54408264160156,9.753898620605469,14.357589721679688],"last":[401.9561462402344,119.5361328125,9.75390625,13.5],"length":67,"rects":[[74.86717987060547,104.54408264160156,219.7959976196289,14.357589721679688],[74.86717987060547,119.5361328125,336.8428726196289,13.5]],"start":33,"text":"属性用 final 修饰保证了该属性是只读的，不能修改\n类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性"}],"type":5}],"originaltext":"final 的使用","page":139,"textblocks":[{"first":[52.35818099975586,55.47821044921875,8.437122344970703,16.603775024414062],"last":[107.41895294189453,55.47821044921875,12.192375183105469,16.603775024414062],"length":9,"rects":[[52.35818099975586,55.47821044921875,67.25314712524414,16.603775024414062]],"start":0,"text":"final 的使用"}],"type":5},{"date":"2021-11-25 16:18:33","docid":0,"fillcolor":"ffffed99","folded":true,"id":891,"markups":[{"content":"对属性进行修改的时候，要创建副本数据来修改，然后将引用赋值","date":"2021-11-25 16:23:10","docid":0,"fillcolor":"ffffed99","id":897,"originaltext":"这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】","page":139,"textblocks":[{"first":[422.7137756347656,711.5318603515625,9.75390625,13.5],"last":[285.55517578125,726.4378662109375,9.75390625,14.5],"length":45,"rects":[[422.7137756347656,711.5318603515625,117.04684448242188,13.5],[52.35818099975586,726.4378662109375,242.95090103149414,14.5]],"start":312,"text":"这种通过创建副本对象来避\n免共享的手段称之为【保护性拷贝（defensive copy）】"}],"type":5}],"originaltext":"保护性拷贝","page":139,"textblocks":[{"first":[52.35818099975586,168.05596923828125,12.192371368408203,15.5],"last":[101.12767791748047,168.05596923828125,12.192375183105469,15.5],"length":5,"rects":[[52.35818099975586,168.05596923828125,60.96187210083008,15.5]],"start":103,"text":"保护性拷贝"}],"type":5}],"originaltext":"不可变设计","page":138,"textblocks":[{"first":[76.99653625488281,545.7122192382812,14.630851745605469,17.5],"last":[135.5199432373047,545.7122192382812,14.630844116210938,17.5],"length":5,"rects":[[76.99653625488281,545.7122192382812,73.15425109863281,17.5]],"start":157,"text":"不可变设计"}],"type":5},{"content":"享元模式\n因为都是对副本数据进行修改，所以有可能会导致副本数据创建过多，可以使用享元模式解决（当需要重用数量有限的同一种对象的时候）\n\n使用最多的情况就是基本数据类型的包装类，其中valueOf()方法就是享元模式\n\n对于长整型long的包装类种的valueOf方法，他最开始会创建一个cash[long]数组，创建包装类的时候就会创建256长度的数组，当需要获取的时候只要长度在这个里面就直接返回，避免的重复创建，底层先创建好了，要的时候进行获取即可\n\nString串池，BigInteger，BigDecimal里面也是使用了享元模式\n\nByte,Long,Shout,Integer,Character范围都是：-128 到 127 \nCharacter范围：0 到 127 \nBoolean：缓存TRUE和FALSE","date":"2021-11-25 16:25:09","docid":0,"fillcolor":"ffffed99","id":898,"originaltext":"模式之享元","page":140,"textblocks":[{"first":[62.14809799194336,56.26123046875,12.192371368408203,15.5],"last":[110.91759490966797,56.26123046875,12.192375183105469,15.5],"length":5,"rects":[[62.14809799194336,56.26123046875,60.96187210083008,15.5]],"start":80,"text":"模式之享元"}],"type":5},{"content":"为什么final的创建是没有线程安全问题的？\n因为是成员变量，所以在对象创建过程中，成员变量会跟着创建会跟着赋值，这个时候线程没有机会调用这个对象，后面又用了final进行修饰，导致其他线程想修改也没用了。\n\n为什么获取final的获取是没有线程安全问题？\nfinal修饰的变量，没有超过极限都会复制到栈内存中，超过复制放在常量池中\n没有final修饰的变量，都要去堆中找","date":"2021-11-25 17:10:28","docid":0,"fillcolor":"ffffed99","id":899,"originaltext":"原理之 final","page":140,"textblocks":[{"first":[62.14809799194336,81.36115264892578,12.192371368408203,17.071983337402344],"last":[125.70695495605469,81.36115264892578,3.7186737060546875,17.071983337402344],"length":9,"rects":[[62.14809799194336,81.36115264892578,67.27753067016602,17.071983337402344]],"start":89,"text":"原理之 final"}],"type":5},{"date":"2021-11-25 20:26:51","docid":0,"fillcolor":"ffffed99","folded":true,"id":900,"markups":[{"date":"2021-11-25 20:26:56","docid":0,"fillcolor":"ffffed99","id":901,"originaltext":"因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】","page":140,"textblocks":[{"first":[66.61388397216797,176.80560302734375,9.753898620605469,12.5],"last":[427.50836181640625,176.80560302734375,9.75390625,12.5],"length":38,"rects":[[66.61388397216797,176.80560302734375,370.6483840942383,12.5]],"start":191,"text":"因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】"}],"type":5}],"originaltext":"无状态","page":140,"textblocks":[{"first":[76.99653625488281,110.2803955078125,14.630851745605469,17.5],"last":[106.25823974609375,110.2803955078125,14.630851745605469,17.5],"length":3,"rects":[[76.99653625488281,110.2803955078125,43.892555236816406,17.5]],"start":104,"text":"无状态"}],"type":5}],"originaltext":"共享模型之不可变","page":136,"textblocks":[{"first":[71.37303924560547,566.96923828125,17.06932830810547,19.5],"last":[190.85829162597656,566.96923828125,17.069320678710938,19.5],"length":8,"rects":[[71.37303924560547,566.96923828125,136.55457305908203,19.5]],"start":96,"text":"共享模型之不可变"}],"type":5},{"date":"2021-11-26 17:56:25","docid":0,"fillcolor":"ffffed99","folded":false,"id":902,"markups":[{"date":"2021-11-26 17:56:29","docid":0,"fillcolor":"ffffed99","folded":false,"id":903,"markups":[{"date":"2021-11-26 17:56:31","docid":0,"fillcolor":"ffffed99","id":904,"originaltext":"自定义线程池","page":140,"textblocks":[{"first":[65.94011688232422,421.6603088378906,12.192375183105469,14.5],"last":[126.90199279785156,421.6603088378906,12.192367553710938,14.5],"length":6,"rects":[[65.94011688232422,421.6603088378906,73.15424346923828,14.5]],"start":295,"text":"自定义线程池"}],"type":5},{"date":"2021-11-28 14:40:37","docid":0,"fillcolor":"ffffed99","folded":false,"id":905,"markups":[{"date":"2021-11-28 14:45:06","docid":0,"id":906,"linecolor":"ffff8280","linewidth":7,"originaltext":"基本线程池的接口","page":146,"rect":[386.80569051579903,69.23978040188598,465.8956684126629,85.85777598125875],"type":11},{"date":"2021-11-28 14:45:19","docid":0,"id":907,"linecolor":"ffff8280","linewidth":7,"originaltext":"带任务调度的线程池接口","page":146,"rect":[102.03757111856879,115.57316728735853,209.23994105830366,132.1911628667313],"type":11},{"date":"2021-11-28 14:45:29","docid":0,"fillcolor":"ffffed99","folded":true,"id":908,"markups":[{"content":"如果最高位是1那么代表负数-","date":"2021-11-28 14:45:36","docid":0,"fillcolor":"ffffed99","id":909,"originaltext":"ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量","page":146,"textblocks":[{"first":[52.35893249511719,305.6024169921875,5.3939056396484375,12.5],"last":[395.4786682128906,305.6024169921875,9.75390625,12.5],"length":53,"rects":[[52.35893249511719,305.6024169921875,352.87364196777344,12.5]],"start":180,"text":"ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量"}],"type":5},{"date":"2021-11-28 14:47:00","docid":0,"fillcolor":"ffffed99","id":912,"originaltext":"RUNNING111YY","page":146,"textblocks":[{"first":[62.86238098144531,381.8849792480469,6.0279083251953125,10.5],"last":[253.43856811523438,381.8849792480469,5.462188720703125,10.5],"length":12,"rects":[[62.86238098144531,381.8849792480469,196.0383758544922,10.5]],"start":30,"text":"RUNNING111YY"}],"type":5},{"content":"温和的结束线程池","date":"2021-11-28 14:47:03","docid":0,"fillcolor":"ffffed99","id":913,"originaltext":"SHUTDOWN000NY不会接收新任务，但会处理阻塞队列剩余任务","page":146,"textblocks":[{"first":[62.86238098144531,414.14788818359375,5.354888916015625,10.5],"last":[353.9787902832031,420.65087890625,9.75390625,12.5],"length":35,"rects":[[62.86238098144531,414.14788818359375,196.0383758544922,10.5],[344.2248840332031,405.6448669433594,175.57028198242188,12.5],[344.2248840332031,420.65087890625,19.5078125,12.5]],"start":44,"text":"SHUTDOWN000NY\n不会接收新任务，但会处理阻塞队列剩余\n任务"}],"type":5},{"content":"直接拉闸使用打断","date":"2021-11-28 14:47:05","docid":0,"fillcolor":"ffffed99","id":914,"originaltext":"STOP001NN会中断正在执行的任务，并抛弃阻塞队列任务","page":146,"textblocks":[{"first":[62.86238098144531,453.9137878417969,5.354888916015625,10.5],"last":[353.9787902832031,459.4167785644531,9.75390625,13.5],"length":31,"rects":[[62.86238098144531,453.9137878417969,197.9306182861328,10.5],[344.2248840332031,444.4107666015625,175.57028198242188,13.5],[344.2248840332031,459.4167785644531,19.5078125,13.5]],"start":80,"text":"STOP001NN\n会中断正在执行的任务，并抛弃阻塞队列\n任务"}],"type":5},{"date":"2021-11-28 14:47:07","docid":0,"fillcolor":"ffffed99","id":915,"originaltext":"TIDYING010--任务全执行完毕，活动线程为 0 即将进入终结","page":146,"textblocks":[{"first":[62.86238098144531,487.9772644042969,5.3939056396484375,19.003021240234375],"last":[353.9787902832031,500.18267822265625,9.75390625,12.5],"length":35,"rects":[[62.86238098144531,487.9772644042969,457.8232879638672,19.003021240234375],[344.2248840332031,500.18267822265625,19.5078125,12.5]],"start":112,"text":"TIDYING010--任务全执行完毕，活动线程为 0 即将进入\n终结"}],"type":5},{"date":"2021-11-28 14:47:09","docid":0,"fillcolor":"ffffed99","id":916,"originaltext":"TERMINATED011--终结状态","page":146,"textblocks":[{"first":[62.86238098144531,525.9425659179688,5.3939056396484375,10.5],"last":[373.4866027832031,525.9425659179688,9.75390625,10.5],"length":19,"rects":[[62.86238098144531,525.9425659179688,320.3781280517578,10.5]],"start":148,"text":"TERMINATED011--终结状态"}],"type":5},{"content":"为什么将 线程状态 和 线程数量 存储在同一个原子变量中","date":"2021-11-28 14:52:48","docid":0,"fillcolor":"ffffed99","id":917,"originaltext":"这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值","page":146,"textblocks":[{"first":[52.35818099975586,588.4661254882812,9.753898620605469,13.5],"last":[81.61988067626953,603.4721069335938,9.753898620605469,13.5],"length":61,"rects":[[52.35818099975586,588.4661254882812,484.04709243774414,13.5],[52.35818099975586,603.4721069335938,39.01559829711914,13.5]],"start":290,"text":"这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作\n进行赋值"}],"type":5}],"originaltext":"线程池状态","page":146,"textblocks":[{"first":[63.76499557495117,282.09283447265625,9.753902435302734,12.5],"last":[102.78059387207031,282.09283447265625,9.753898620605469,12.5],"length":5,"rects":[[63.76499557495117,282.09283447265625,48.76949691772461,12.5]],"start":173,"text":"线程池状态"}],"type":5},{"content":"脑子里面想自定义线程池的图","date":"2021-11-28 15:26:46","docid":0,"fillcolor":"ffffed99","folded":false,"id":918,"markups":[{"date":"2021-11-28 15:27:01","docid":0,"fillcolor":"ffffed99","folded":true,"id":921,"markups":[{"date":"2021-11-28 15:33:15","docid":0,"id":922,"linecolor":"ffff8280","linewidth":7,"originaltext":"救急线程的使用只有 执行在任务队列也装不下的情况来执行的任务，执行完就会终止，而核心线程一直伴随线程池存在","page":147,"rect":[307.2947181768766,191.70254529724434,473.8000112724306,265.4800063056947],"type":11}],"originaltext":"corePoolSize 核心线程数目 (最多保留的线程数)maximumPoolSize 最大线程数目keepAliveTime 生存时间 - 针对救急线程unit 时间单位 - 针对救急线程workQueue 阻塞队列threadFactory 线程工厂 - 可以为线程创建时起个好名字handler 拒绝策略","page":147,"textblocks":[{"first":[74.86717987060547,179.81134033203125,4.642852783203125,12.5],"last":[141.95826721191406,270.349609375,9.75390625,12.5],"length":163,"rects":[[74.86717987060547,179.81134033203125,205.15003204345703,12.5],[74.86717987060547,195.318115234375,145.1673355102539,12.5],[74.86717987060547,209.5240936279297,173.99835968017578,13.5],[74.86717987060547,224.830810546875,126.16223907470703,12.5],[74.86717987060547,240.3367919921875,94.64362335205078,12.5],[74.86717987060547,254.84283447265625,239.91675567626953,12.5],[74.86717987060547,270.349609375,76.8449935913086,12.5]],"start":2,"text":"corePoolSize 核心线程数目 (最多保留的线程数)\nmaximumPoolSize 最大线程数目\nkeepAliveTime 生存时间 - 针对救急线程\nunit 时间单位 - 针对救急线程\nworkQueue 阻塞队列\nthreadFactory 线程工厂 - 可以为线程创建时起个好名字\nhandler 拒绝策略"}],"type":5},{"date":"2021-11-28 15:36:22","docid":0,"id":923,"linecolor":"ffff8280","linewidth":7,"originaltext":"拒绝策略只有救急线程也装满的情况下才会使用","page":147,"rect":[162.42715402547685,274.35612234431505,316.48351070333,303.4685143871861],"type":11}],"originaltext":"构造方法","page":146,"textblocks":[{"first":[63.76499557495117,750.5429077148438,9.753902435302734,13.5],"last":[93.02669525146484,750.5429077148438,9.753898620605469,13.5],"length":4,"rects":[[63.76499557495117,750.5429077148438,39.01559829711914,13.5]],"start":359,"text":"构造方法"}],"type":5},{"date":"2021-11-28 15:41:15","docid":0,"fillcolor":"ffffed99","folded":true,"id":927,"markups":[{"content":"所以一定要是有界队列才可以有救急线程","date":"2021-11-28 15:39:14","docid":0,"fillcolor":"ffffed99","id":924,"originaltext":"如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。","page":148,"textblocks":[{"first":[74.86717987060547,693.7713623046875,9.753898620605469,12.5],"last":[113.88277435302734,708.77734375,9.753898620605469,12.5],"length":70,"rects":[[74.86717987060547,693.7713623046875,467.35364532470703,12.5],[74.86717987060547,708.77734375,48.769493103027344,12.5]],"start":173,"text":"如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线\n程来救急。"}],"type":5},{"content":"线程池最重要的就是 限制线程的创建","date":"2021-11-28 15:40:58","docid":0,"fillcolor":"ffffed99","folded":true,"group":[{"date":"2021-11-28 15:40:58","docid":0,"fillcolor":"ffffed99","id":926,"originaltext":"CallerRunsPolicy 让调用者运行任务DiscardPolicy 放弃本次任务DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题Netty 的实现，是创建一个新线程来执行任务ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略","page":149,"textblocks":[{"first":[97.3769302368164,56.4681282043457,6.1547088623046875,13.499996185302734],"last":[430.5009765625,159.0059814453125,9.75360107421875,12.5],"length":267,"rects":[[97.3769302368164,56.4681282043457,155.36017608642578,13.499996185302734],[97.3756332397461,69.76744079589844,121.37442779541016,13.5],[97.37527465820312,84.60832214355469,268.02740478515625,13.5],[97.37518310546875,100.48210144042969,441.894775390625,13.5],[97.37593841552734,115.787841796875,48.76860809326172,12.5],[97.37454986572266,130.1041259765625,192.94701385498047,12.5],[97.37427520751953,143.864013671875,373.92733001708984,12.5],[97.37387084960938,159.0059814453125,342.8807067871094,12.5]],"start":0,"text":"CallerRunsPolicy 让调用者运行任务\nDiscardPolicy 放弃本次任务\nDiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之\nDubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方\n便定位问题\nNetty 的实现，是创建一个新线程来执行任务\nActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略\nPinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略"}],"type":5}],"id":925,"markups":[{"date":"2021-11-28 15:48:12","docid":0,"id":929,"linecolor":"ffff8280","linewidth":7,"originaltext":"放弃本次任务，放弃最早的任务，让调用者运行，抛出异常","page":149,"rect":[56.22478408574199,300.9067148292488,564.8096404153572,317.0041105559758],"type":11}],"originaltext":"如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它著名框架也提供了实现AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略北京市昌平区建材城西路金燕龙办公楼一层   电话：400-618-9090\nCallerRunsPolicy 让调用者运行任务DiscardPolicy 放弃本次任务DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题Netty 的实现，是创建一个新线程来执行任务ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略","page":148,"textblocks":[{"first":[74.86717987060547,727.1859130859375,9.753898620605469,14.5],"last":[0,0,0,0],"length":166,"rects":[[74.86717987060547,727.1859130859375,459.91443634033203,14.5],[74.86717987060547,743.2918701171875,97.53902435302734,13.5],[97.3769302368164,762.4507446289062,333.06197357177734,14.5],[164.75,813.5006713867188,265.5,9],[164.75,813.5006713867188,265.5,9]],"start":244,"text":"如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它\n著名框架也提供了实现\nAbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略\n北京市昌平区建材城西路金燕龙办公楼一层   电话：400-618-9090\n"}],"type":5},{"content":"为什么会有工厂方法，因为线程池的构造方法很多，调用者会不知道调用哪些构造方法是自己想要的，工厂方法也是调用构造方法的，但是他能告诉你，创建的是哪种用途的线程池","date":"2021-11-28 15:49:10","docid":0,"fillcolor":"ffffed99","id":931,"originaltext":"根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池","page":149,"textblocks":[{"first":[52.356109619140625,318.6980895996094,9.75351333618164,12.5],"last":[410.0924377441406,318.6980895996094,9.753509521484375,12.5],"length":45,"rects":[[52.356109619140625,318.6980895996094,367.4898376464844,12.5]],"start":348,"text":"根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池"}],"type":5}],"originaltext":"工作方式：","page":147,"textblocks":[{"first":[52.35818099975586,293.10888671875,9.753898620605469,12.5],"last":[91.373779296875,293.10888671875,9.753898620605469,12.5],"length":5,"rects":[[52.35818099975586,293.10888671875,48.76949691772461,12.5]],"start":166,"text":"工作方式："}],"type":5},{"content":"线程池创建的线程都是非守护线程","date":"2021-11-28 21:12:53","docid":0,"fillcolor":"ffffed99","id":966,"originaltext":"JDK Executors 类中提供了众多工厂方法","page":149,"textblocks":[{"first":[140.1377410888672,318.6980895996094,2.60418701171875,12.5],"last":[302.8038330078125,318.6980895996094,9.753509521484375,12.5],"length":25,"rects":[[140.1377410888672,318.6980895996094,172.4196014404297,12.5]],"start":357,"text":"JDK Executors 类中提供了众多工厂方法"}],"type":5},{"content":"创建固定大小的线程池\n没有救急线程\n任务队列无限","date":"2021-11-28 15:58:53","docid":0,"fillcolor":"ffffed99","folded":true,"id":933,"markups":[{"date":"2021-11-28 15:59:50","docid":0,"fillcolor":"ffffed99","folded":true,"id":934,"markups":[{"date":"2021-11-28 15:59:53","docid":0,"fillcolor":"ffffed99","id":935,"originaltext":"核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间","page":149,"textblocks":[{"first":[74.86717987060547,512.947509765625,9.753898620605469,12.5],"last":[383.705810546875,512.947509765625,9.75390625,12.5],"length":35,"rects":[[74.86717987060547,512.947509765625,318.59253692626953,12.5]],"start":424,"text":"核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间"}],"type":5},{"date":"2021-11-28 15:59:55","docid":0,"fillcolor":"ffffed99","id":936,"originaltext":"阻塞队列是无界的，可以放任意数量的任务","page":149,"textblocks":[{"first":[74.86717987060547,527.9534912109375,9.753898620605469,12.5],"last":[250.4374542236328,527.9534912109375,9.753890991210938,12.5],"length":19,"rects":[[74.86717987060547,527.9534912109375,185.32416534423828,12.5]],"start":460,"text":"阻塞队列是无界的，可以放任意数量的任务"}],"type":5}],"originaltext":"特点","page":149,"textblocks":[{"first":[52.35818099975586,489.43780517578125,9.753898620605469,13.5],"last":[62.11207962036133,489.43780517578125,9.753902435302734,13.5],"length":2,"rects":[[52.35818099975586,489.43780517578125,19.507801055908203,13.5]],"start":421,"text":"特点"}],"type":5},{"content":"任务数量少，但是任务时间长","date":"2021-11-28 15:59:58","docid":0,"fillcolor":"ffffed99","id":937,"originaltext":"评价 适用于任务量已知，相对耗时的任务","page":149,"textblocks":[{"first":[66.61388397216797,550.912841796875,9.753898620605469,13.5],"last":[234.9564971923828,550.912841796875,9.75390625,13.5],"length":19,"rects":[[66.61388397216797,550.912841796875,178.09651947021484,13.5]],"start":480,"text":"评价 适用于任务量已知，相对耗时的任务"}],"type":5}],"originaltext":" newFixedThreadPool","page":149,"textblocks":[{"first":[61.231807708740234,368.9651184082031,2.5359153747558594,8.5],"last":[162.11798095703125,368.9651184082031,2.974822998046875,8.5],"length":19,"rects":[[61.231807708740234,368.9651184082031,103.86099624633789,8.5]],"start":398,"text":" newFixedThreadPool"}],"type":5},{"date":"2021-11-28 16:10:01","docid":0,"fillcolor":"ffffed99","folded":true,"id":938,"markups":[{"content":"全是救急线程来任务就创建线程执行任务，其中SynchronousQueue只有拿任务才可以放任务","date":"2021-11-28 16:10:10","docid":0,"fillcolor":"ffffed99","folded":true,"id":939,"markups":[{"date":"2021-11-28 16:10:16","docid":0,"fillcolor":"ffffed99","group":[{"date":"2021-11-28 16:10:16","docid":0,"fillcolor":"ffffed99","id":941,"originaltext":"救急线程可以无限创建队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）","page":150,"textblocks":[{"first":[97.3769302368164,56.76812744140625,9.753898620605469,12.5],"last":[84.61994934082031,93.09405517578125,9.753768920898438,12.5],"length":70,"rects":[[97.3769302368164,56.76812744140625,97.5390396118164,12.5],[74.8661880493164,78.0875244140625,465.30403900146484,12.5],[74.8661880493164,93.09405517578125,19.507530212402344,12.5]],"start":0,"text":"救急线程可以无限创建\n队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交\n货）"}],"type":5}],"id":940,"originaltext":"核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着全部都是救急线程（60s 后可以回收）public static ExecutorService newFixedThreadPool(int nThreads) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue<Runnable>());}public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue<Runnable>());}北京市昌平区建材城西路金燕龙办公楼一层   电话：400-618-9090\n救急线程可以无限创建队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）","page":149,"textblocks":[{"first":[74.86717987060547,741.44384765625,9.753898620605469,14.5],"last":[0,0,0,0],"length":606,"rects":[[74.86717987060547,741.44384765625,413.2120132446289,14.5],[97.3769302368164,762.0523681640625,164.64962005615234,12.5],[64.8784408569336,405.88128662109375,308.8369827270508,8.77850341796875],[64.87918853759766,419.3866882324219,255.7450180053711,8.77850341796875],[64.87918853759766,430.5345764160156,289.55501556396484,11.530364990234375],[64.87994384765625,446.3974914550781,342.6455078125,8.77850341796875],[64.88069152832031,459.90289306640625,4.828178405761719,8.77850341796875],[64.8784408569336,635.4776000976562,255.64298248291016,8.77850341796875],[64.87918853759766,648.9829711914062,265.3826217651367,8.77850341796875],[64.87994384765625,660.1309204101562,270.2467956542969,11.53033447265625],[64.87994384765625,673.6362915039062,328.1669921875,11.53033447265625],[64.87994384765625,689.4992065429688,4.828178405761719,8.77850341796875],[164.75,813.5006713867188,265.5,9],[164.75,813.5006713867188,265.5,9]],"start":531,"text":"核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着\n全部都是救急线程（60s 后可以回收）\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n北京市昌平区建材城西路金燕龙办公楼一层   电话：400-618-9090\n"}],"type":5}],"originaltext":"特点","page":149,"textblocks":[{"first":[52.35818099975586,720.0348510742188,9.753898620605469,12.5],"last":[62.11207962036133,720.0348510742188,9.753902435302734,12.5],"length":2,"rects":[[52.35818099975586,720.0348510742188,19.507801055908203,12.5]],"start":528,"text":"特点"}],"type":5},{"content":"任务多，但是任务时间少","date":"2021-11-28 16:14:20","docid":0,"fillcolor":"ffffed99","id":942,"markups":[{"date":"2021-11-28 16:14:29","docid":0,"fillcolor":"ffffed99","id":943,"originaltext":"整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况","page":151,"textblocks":[{"first":[88.64794158935547,56.76812744140625,9.753898620605469,12.5],"last":[312.98773193359375,71.774169921875,9.75390625,12.5],"length":73,"rects":[[88.64794158935547,56.76812744140625,427.51343536376953,12.5],[66.61388397216797,71.774169921875,256.1277542114258,12.5]],"start":3,"text":"整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线\n程。 适合任务数比较密集，但每个任务执行时间较短的情况"}],"type":5}],"originaltext":"评价","page":151,"textblocks":[{"first":[66.61388397216797,56.76812744140625,9.753898620605469,12.5],"last":[76.36778259277344,56.76812744140625,9.753898620605469,12.5],"length":2,"rects":[[66.61388397216797,56.76812744140625,19.507797241210938,12.5]],"start":0,"text":"评价"}],"type":5}],"originaltext":"newCachedThreadPool","page":149,"textblocks":[{"first":[63.77024459838867,599.7314453125,6.408313751220703,9.5],"last":[171.88307189941406,599.7314453125,2.974945068359375,9.5],"length":19,"rects":[[63.77024459838867,599.7314453125,111.08777236938477,9.5]],"start":505,"text":"newCachedThreadPool"}],"type":5},{"content":"单线程执行器，只有一个核心线程，排队","date":"2021-11-28 16:21:49","docid":0,"fillcolor":"ffffed99","folded":true,"id":944,"markups":[{"date":"2021-11-28 16:22:49","docid":0,"fillcolor":"ffffed99","folded":true,"id":947,"markups":[{"date":"2021-11-28 16:22:41","docid":0,"fillcolor":"ffffed99","id":945,"originaltext":"希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。","page":151,"textblocks":[{"first":[52.35818099975586,275.60003662109375,9.753898620605469,13.5],"last":[110.88157653808594,290.6060791015625,9.753898620605469,12.5],"length":61,"rects":[[52.35818099975586,275.60003662109375,486.94260025024414,13.5],[52.35818099975586,290.6060791015625,68.27729415893555,12.5]],"start":115,"text":"希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程\n也不会被释放。"}],"type":5}],"originaltext":"使用场景：","page":151,"textblocks":[{"first":[52.35818099975586,254.091064453125,9.753898620605469,12.5],"last":[91.373779296875,254.091064453125,9.753898620605469,12.5],"length":5,"rects":[[52.35818099975586,254.091064453125,48.76949691772461,12.5]],"start":109,"text":"使用场景："}],"type":5},{"date":"2021-11-28 16:22:53","docid":0,"fillcolor":"ffffed99","folded":true,"id":948,"markups":[{"content":"对比直接创建单线程和任务队列\n更完备的执行任务，不会因为其中一个任务的异常而导致整个线程池的结束，它会执行重新创建一个核心线程继续执行完任务队列中的任务\n\n对比使用newFixdThreadPool(1)固定大小线程池\n不够安全，固定大小线程池直接返回线程池对象，而单线程执行器使用装饰模式，只暴露接口 ExecutorService 中的方法","date":"2021-11-28 16:22:59","docid":0,"fillcolor":"ffffed99","id":949,"originaltext":"自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改","page":151,"textblocks":[{"first":[74.86717987060547,336.3758239746094,9.753898620605469,13.5],"last":[486.8711853027344,447.421875,9.75390625,12.5],"length":323,"rects":[[74.86717987060547,336.3758239746094,458.4335403442383,13.5],[74.86717987060547,351.3818054199219,117.04683685302734,13.5],[74.86717987060547,371.5904235839844,295.51920318603516,13.5],[97.3769302368164,391.0492248535156,440.4591293334961,14.5],[97.3769302368164,406.8552551269531,204.2174301147461,13.5],[74.86717987060547,427.16302490234375,278.3883743286133,12.5],[97.3769302368164,447.421875,399.24816131591797,12.5]],"start":181,"text":"自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一\n个线程，保证池的正常工作\nExecutors.newSingleThreadExecutor() 线程个数始终为1，不能修改\nFinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因\n此不能调用 ThreadPoolExecutor 中特有的方法\nExecutors.newFixedThreadPool(1) 初始时为1，以后还可以修改\n对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改"}],"type":5}],"originaltext":"区别：","page":151,"textblocks":[{"first":[52.35818099975586,314.61505126953125,9.753898620605469,12.5],"last":[71.86598205566406,314.61505126953125,9.753898620605469,12.5],"length":3,"rects":[[52.35818099975586,314.61505126953125,29.261699676513672,12.5]],"start":177,"text":"区别："}],"type":5}],"originaltext":"newSingleThreadExecutor","page":151,"textblocks":[{"first":[63.77024459838867,121.29571533203125,6.408313751220703,8.5],"last":[185.58425903320312,121.29571533203125,4.4282684326171875,8.5],"length":23,"rects":[[63.77024459838867,121.29571533203125,126.24228286743164,8.5]],"start":82,"text":"newSingleThreadExecutor"}],"type":5},{"date":"2021-11-28 16:36:07","docid":0,"fillcolor":"ffffed99","folded":false,"id":950,"markups":[{"content":"使用，callable可以抛出异常，有返回结果，使用了保护性暂停模式","date":"2021-11-28 16:37:11","docid":0,"fillcolor":"ffffed99","id":951,"originaltext":"Future<T>","page":151,"textblocks":[{"first":[84.15364837646484,585.20751953125,4.828178405761719,8.77850341796875],"last":[122.746826171875,585.20751953125,4.828178405761719,8.77850341796875],"length":9,"rects":[[84.15364837646484,585.20751953125,43.421356201171875,8.77850341796875]],"start":877,"text":"Future<T>"}],"type":5},{"content":"获取结果等待的时间是线程中任务执行最长的时间","date":"2021-11-28 16:44:43","docid":0,"fillcolor":"ffffed99","id":952,"originaltext":"invokeAll","page":151,"textblocks":[{"first":[161.3302459716797,625.7236938476562,4.82818603515625,8.77850341796875],"last":[199.9557342529297,625.7236938476562,4.82818603515625,8.77850341796875],"length":9,"rects":[[161.3302459716797,625.7236938476562,43.45367431640625,8.77850341796875]],"start":953,"text":"invokeAll"}],"type":5},{"content":"找对最先执行的任务结果然后返回，抢夺的过程，哪个任务先执行成功就返回哪个任务的结果，注意其中比较的是线程，不是任务队列中的任务","date":"2021-11-28 16:46:14","docid":0,"fillcolor":"ffffed99","id":953,"originaltext":"invokeAny","page":151,"textblocks":[{"first":[93.79650115966797,747.2722778320312,4.828178405761719,8.77850341796875],"last":[132.42193603515625,747.2722778320312,4.82818603515625,8.77850341796875],"length":9,"rects":[[93.79650115966797,747.2722778320312,43.45362091064453,8.77850341796875]],"start":1293,"text":"invokeAny"}],"type":5}],"originaltext":" 提交任务","page":151,"textblocks":[{"first":[61.234981536865234,492.44049072265625,2.5360145568847656,13.5],"last":[93.0274429321289,492.44049072265625,9.753898620605469,13.5],"length":5,"rects":[[61.234981536865234,492.44049072265625,41.54636001586914,13.5]],"start":509,"text":" 提交任务"}],"type":5},{"date":"2021-11-28 17:02:21","docid":0,"fillcolor":"ffffed99","folded":true,"id":954,"markups":[{"content":"修改线程池状态，打断空闲的线程，然后尝试终结\n不会阻塞主线程的执行","date":"2021-11-28 17:03:42","docid":0,"fillcolor":"ffffed99","id":955,"originaltext":"shutdown","page":152,"textblocks":[{"first":[52.35893249511719,194.05755615234375,4.847686767578125,8.5],"last":[94.62783813476562,194.05755615234375,6.4083099365234375,8.5],"length":8,"rects":[[52.35893249511719,194.05755615234375,48.677215576171875,8.5]],"start":12,"text":"shutdown"}],"type":5},{"content":"返回还没有执行的任务，也就是任务队列中的任务，\n打断所有的线程","date":"2021-11-28 17:05:05","docid":0,"fillcolor":"ffffed99","id":956,"originaltext":"shutdownNow","page":152,"textblocks":[{"first":[52.35818099975586,611.2333984375,4.847686767578125,8.5],"last":[114.81075286865234,611.2333984375,8.349342346191406,8.5],"length":11,"rects":[[52.35818099975586,611.2333984375,70.80191421508789,8.5]],"start":27,"text":"shutdownNow"}],"type":5},{"date":"2021-11-28 17:08:02","docid":0,"fillcolor":"ffffed99","folded":true,"id":957,"markups":[{"content":"等shutdown结束或者时间等够","date":"2021-11-28 17:36:01","docid":0,"fillcolor":"ffffed99","id":959,"originaltext":"awaitTermination","page":153,"textblocks":[{"first":[103.473876953125,487.6609802246094,4.828178405761719,8.77850341796875],"last":[175.89662170410156,487.6609802246094,4.82818603515625,8.77850341796875],"length":16,"rects":[[103.473876953125,487.6609802246094,77.25093078613281,8.77850341796875]],"start":761,"text":"awaitTermination"}],"type":5}],"originaltext":"其它方法","page":153,"textblocks":[{"first":[52.35818099975586,341.8724060058594,9.753898620605469,12.5],"last":[81.61988067626953,341.8724060058594,9.753898620605469,12.5],"length":4,"rects":[[52.35818099975586,341.8724060058594,39.01559829711914,12.5]],"start":2,"text":"其它方法"}],"type":5}],"originaltext":"关闭线程池","page":152,"textblocks":[{"first":[63.76499557495117,168.0479736328125,9.753902435302734,12.5],"last":[102.78059387207031,168.0479736328125,9.753898620605469,12.5],"length":5,"rects":[[63.76499557495117,168.0479736328125,48.76949691772461,12.5]],"start":5,"text":"关闭线程池"}],"type":5},{"content":"有可能会发生饥饿现象，有可能算是保护性暂停的错误运用，两者可以互相转换导致，导致全部变成了消费者，等待生产者，只要让他们不要互相转换即可，不同的任务使用不同的线程池","date":"2021-11-28 17:08:13","docid":0,"fillcolor":"ffffed99","id":958,"originaltext":" 模式之 Worker Thread","page":153,"textblocks":[{"first":[57.67405700683594,541.906982421875,2.5360145568847656,13.5],"last":[158.2170867919922,541.906982421875,6.174224853515625,13.5],"length":18,"rects":[[57.67405700683594,541.906982421875,106.71725463867188,13.5]],"start":12,"text":" 模式之 Worker Thread"}],"type":5},{"date":"2021-11-28 21:07:30","docid":0,"fillcolor":"ffffed99","folded":true,"id":960,"markups":[{"date":"2021-11-28 21:09:05","docid":0,"fillcolor":"ffffed99","folded":true,"id":962,"markups":[{"content":"Timer让一个线程管理所有的任务，所以不能让两个任务同时执行，并且出现一个异常导致全部的任务都不能执行","date":"2021-11-28 21:08:57","docid":0,"fillcolor":"ffffed99","id":961,"originaltext":"可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。","page":153,"textblocks":[{"first":[218.17527770996094,613.1358032226562,9.75390625,14.5],"last":[237.68309020996094,644.247802734375,9.75390625,13.5],"length":118,"rects":[[218.17527770996094,613.1358032226562,321.69337463378906,14.5],[52.35893249511719,628.9417724609375,487.69520568847656,13.5],[52.35893249511719,644.247802734375,195.07806396484375,13.5]],"start":64,"text":"可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但\n由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个\n任务的延迟或异常都将会影响到之后的任务。"}],"type":5}],"originaltext":"Timer","page":153,"textblocks":[{"first":[403.6748962402344,613.1358032226562,5.3939208984375,14.5],"last":[426.0796203613281,613.1358032226562,3.979583740234375,14.5],"length":5,"rects":[[403.6748962402344,613.1358032226562,26.384307861328125,14.5]],"start":93,"text":"Timer"}],"type":5},{"content":"任务调度的形式创建线程池\n延时执行（参数）：线程任务，延时时间，时间单位","date":"2021-11-28 21:11:18","docid":0,"fillcolor":"ffffed99","id":963,"originaltext":"ScheduledExecutorService","page":154,"textblocks":[{"first":[74.4012451171875,344.1228332519531,5.354888916015625,8.5],"last":[188.29612731933594,344.1228332519531,5.4719390869140625,8.5],"length":24,"rects":[[74.4012451171875,344.1228332519531,119.3668212890625,8.5]],"start":140,"text":"ScheduledExecutorService"}],"type":5},{"content":"可延时，可以使用有频率的执行任务\n延时执行（参数）：线程任务，延时时间，间隔时间，时间单位\n间隔时间从开始时间算\n注意就算任务执行时间比间隔时间长，也要会等任务执行完毕，才会执行下一次任务","date":"2021-11-28 21:18:29","docid":0,"fillcolor":"ffffed99","id":967,"originaltext":"scheduleAtFixedRate","page":154,"textblocks":[{"first":[52.3574333190918,617.738525390625,4.652610778808594,12.5],"last":[141.39344787597656,617.738525390625,5.4719390869140625,12.5],"length":19,"rects":[[52.3574333190918,617.738525390625,94.50795364379883,12.5]],"start":254,"text":"scheduleAtFixedRate"}],"type":5},{"content":"可延时，可以使用有频率的执行任务\n延时执行（参数）：线程任务，延时时间，间隔时间，时间单位\n间隔时间从结束时间算","date":"2021-11-28 21:26:19","docid":0,"fillcolor":"ffffed99","id":968,"originaltext":"scheduleWithFixedDelay","page":155,"textblocks":[{"first":[52.3574333190918,399.29876708984375,4.652610778808594,14.5],"last":[158.28396606445312,399.29876708984375,4.9159698486328125,14.5],"length":22,"rects":[[52.3574333190918,399.29876708984375,110.84250259399414,14.5]],"start":632,"text":"scheduleWithFixedDelay"}],"type":5},{"date":"2021-11-28 21:27:38","docid":0,"fillcolor":"ffffed99","id":969,"originaltext":"评价 整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。用来执行延迟或反复执行的任务","page":155,"textblocks":[{"first":[66.61312866210938,669.01220703125,9.753898620605469,12.5],"last":[271.4450988769531,684.0181884765625,9.75390625,12.5],"length":71,"rects":[[66.61312866210938,669.01220703125,460.9598083496094,12.5],[66.61312866210938,684.0181884765625,214.58587646484375,12.5]],"start":1014,"text":"评价 整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线\n程也不会被释放。用来执行延迟或反复执行的任务"}],"type":5},{"content":"对于普通线程池一样适用","date":"2021-11-28 21:29:27","docid":0,"fillcolor":"ffffed99","folded":false,"id":970,"markups":[{"content":"","date":"2021-11-28 21:29:35","docid":0,"fillcolor":"ffffed99","id":971,"originaltext":"方法1：主动捉异常","page":155,"textblocks":[{"first":[52.35818099975586,754.2463989257812,9.753898620605469,13.5],"last":[126.2049560546875,754.2463989257812,9.75390625,13.5],"length":9,"rects":[[52.35818099975586,754.2463989257812,83.60068130493164,13.5]],"start":1103,"text":"方法1：主动捉异常"}],"type":5},{"content":"获得返回结果包括异常","date":"2021-11-28 21:29:41","docid":0,"fillcolor":"ffffed99","id":972,"originaltext":"方法2：使用 Future","page":156,"textblocks":[{"first":[52.3574333190918,400.8490905761719,9.753898620605469,13.5],"last":[133.46726989746094,400.8490905761719,5.4719390869140625,13.5],"length":13,"rects":[[52.3574333190918,400.8490905761719,86.5817756652832,13.5]],"start":567,"text":"方法2：使用 Future"}],"type":5}],"originaltext":"正确处理执行任务异常","page":155,"textblocks":[{"first":[63.764244079589844,729.5368041992188,9.753898620605469,13.5],"last":[151.54934692382812,729.5368041992188,9.75390625,13.5],"length":10,"rects":[[63.764244079589844,729.5368041992188,97.53900909423828,13.5]],"start":1091,"text":"正确处理执行任务异常"}],"type":5}],"originaltext":"任务调度线程池","page":153,"textblocks":[{"first":[63.76499557495117,590.2261962890625,9.753902435302734,13.5],"last":[122.28839111328125,590.2261962890625,9.75390625,13.5],"length":7,"rects":[[63.76499557495117,590.2261962890625,68.27730178833008,13.5]],"start":38,"text":"任务调度线程池"}],"type":5},{"content":"Tomcat有两大核心组件中的Connector使用了线程连接池","date":"2021-11-28 21:32:37","docid":0,"fillcolor":"ffffed99","folded":true,"id":973,"markups":[{"content":"Connector中的NIO EndPoint中使用了线程池\n三大线程组成：\nAcceptor监听是否有连接\nPoller监听连接是否有有可读的I/O事件\nExecutor处理这些任务对象","date":"2021-11-28 21:50:17","docid":0,"fillcolor":"ffffed99","id":974,"originaltext":"Tomcat 在哪里用到了线程池呢","page":157,"textblocks":[{"first":[52.35818099975586,175.01255798339844,5.3939056396484375,13.5],"last":[175.8560791015625,175.01255798339844,9.75390625,13.5],"length":17,"rects":[[52.35818099975586,175.01255798339844,133.25180435180664,13.5]],"start":33,"text":"Tomcat 在哪里用到了线程池呢"}],"type":5},{"date":"2021-11-28 22:17:52","docid":0,"fillcolor":"ffffed99","folded":true,"id":976,"markups":[{"date":"2021-11-28 22:18:00","docid":0,"fillcolor":"ffffed99","id":977,"originaltext":"如果总线程数达到 maximumPoolSize这时不会立刻抛 RejectedExecutionException 异常而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常","page":157,"textblocks":[{"first":[74.86717987060547,457.18328857421875,9.753898620605469,12.5],"last":[463.9674987792969,491.6481628417969,9.75390625,13.5],"length":116,"rects":[[74.86717987060547,457.18328857421875,164.75312042236328,12.5],[97.3769302368164,476.64215087890625,220.28209686279297,13.5],[97.3769302368164,491.6481628417969,376.34447479248047,13.5]],"start":300,"text":"如果总线程数达到 maximumPoolSize\n这时不会立刻抛 RejectedExecutionException 异常\n而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常"}],"type":5}],"originaltext":"Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同","page":157,"textblocks":[{"first":[52.35818099975586,433.8728332519531,5.3939056396484375,13.5],"last":[299.51605224609375,433.8728332519531,9.75390625,13.5],"length":39,"rects":[[52.35818099975586,433.8728332519531,256.9117774963379,13.5]],"start":260,"text":"Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同"}],"type":5},{"date":"2021-11-28 22:29:19","docid":0,"fillcolor":"ffffed99","id":978,"originaltext":"Connector 配置","page":158,"textblocks":[{"first":[52.35818099975586,359.12811279296875,6.1547088623046875,8.5],"last":[112.06180572509766,359.12811279296875,9.753898620605469,8.5],"length":12,"rects":[[52.35818099975586,359.12811279296875,69.45752334594727,8.5]],"start":205,"text":"Connector 配置"}],"type":5},{"date":"2021-11-28 22:29:25","docid":0,"fillcolor":"ffffed99","id":979,"originaltext":"Executor 线程配置","page":158,"textblocks":[{"first":[52.35818099975586,560.958740234375,5.423168182373047,8.5],"last":[123.88352966308594,560.958740234375,9.75390625,8.5],"length":13,"rects":[[52.35818099975586,560.958740234375,81.27925491333008,8.5]],"start":218,"text":"Executor 线程配置"}],"type":5},{"date":"2021-11-28 22:33:05","docid":0,"id":980,"linecolor":"ffff8280","linewidth":7,"originaltext":"提交的任务是否大于核心线程，否，表明任务一次有可能完不成，判断是否真的完不成，是的话，就完不成了，要先进行救急线程尝试先执行一部分","page":159,"rect":[57.144184267428486,279.36631974774025,212.20054094528166,346.9619011811058],"type":11}],"originaltext":"Tomcat 线程池","page":157,"textblocks":[{"first":[69.3397216796875,151.00291442871094,5.6475067138671875,13.5],"last":[127.03854370117188,151.00291442871094,9.75390625,13.5],"length":10,"rects":[[69.3397216796875,151.00291442871094,67.45272827148438,13.5]],"start":21,"text":"Tomcat 线程池"}],"type":5}],"originaltext":"ThreadPoolExecutor","page":145,"textblocks":[{"first":[65.96487426757812,742.2438354492188,7.05938720703125,13.5],"last":[183.03994750976562,742.2438354492188,5.53533935546875,13.5],"length":18,"rects":[[65.96487426757812,742.2438354492188,122.61041259765625,13.5]],"start":18,"text":"ThreadPoolExecutor"}],"type":5},{"date":"2021-11-28 22:35:17","docid":0,"fillcolor":"ffffed99","folded":false,"id":981,"markups":[{"date":"2021-11-28 22:35:59","docid":0,"fillcolor":"ffffed99","folded":false,"id":983,"markups":[{"date":"2021-11-28 22:35:53","docid":0,"fillcolor":"ffffed99","id":982,"originaltext":"Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算","page":159,"textblocks":[{"first":[52.35893249511719,562.7139892578125,5.033012390136719,12.5],"last":[62.11207962036133,576.7200317382812,9.753902435302734,12.5],"length":66,"rects":[[52.35893249511719,562.7139892578125,482.22230529785156,12.5],[52.35818099975586,576.7200317382812,19.507801055908203,12.5]],"start":313,"text":"Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型\n运算"}],"type":5},{"date":"2021-11-28 22:36:47","docid":0,"fillcolor":"ffffed99","id":984,"originaltext":"Fork/Join 默认会创建与 cpu 核心数大小相同的线程池","page":159,"textblocks":[{"first":[52.35818099975586,676.0093383789062,5.033012390136719,12.5],"last":[273.1880187988281,676.0093383789062,9.75390625,12.5],"length":32,"rects":[[52.35818099975586,676.0093383789062,230.58374404907227,12.5]],"start":519,"text":"Fork/Join 默认会创建与 cpu 核心数大小相同的线程池"}],"type":5}],"originaltext":"概念","page":159,"textblocks":[{"first":[63.76499557495117,537.7044677734375,9.753902435302734,12.5],"last":[73.5188980102539,537.7044677734375,9.753898620605469,12.5],"length":2,"rects":[[63.76499557495117,537.7044677734375,19.507801055908203,12.5]],"start":309,"text":"概念"}],"type":5},{"date":"2021-11-28 22:39:02","docid":0,"fillcolor":"ffffed99","id":985,"markups":[{"content":" 任务对象拆分\nfork开启另一个线程来拆分任务\njoin开启另一个线程去回收执行完的的任务结果并合并\n\n底层使用了保护行暂停\n其实就是保护性暂停的一种使用，当fork就是开启消费者，定义生产者要生产的资源，但是这个生产者要去获取另一个生产着生产的资源，所以fork就是创建这个任务链的关键性代码\njoin就是将底层最后一个提供资源的生产者执行的开关\n","date":"2021-11-28 22:44:00","docid":0,"fillcolor":"ffffed99","id":986,"originaltext":"AddTask1 t1 = new AddTask1(n - 1);        t1.fork();        log.debug(\"fork() {} + {}\", n, t1);                // 合并(join)结果        int result = n + t1.join();","page":160,"textblocks":[{"first":[103.4896240234375,357.8538513183594,4.828178405761719,8.77850341796875],"last":[228.8925323486328,425.380859375,4.82818603515625,8.77850341796875],"length":164,"rects":[[103.4896240234375,357.8538513183594,163.99609375,8.77850341796875],[64.88519287109375,371.3592529296875,86.85324096679688,8.77850341796875],[64.88519287109375,384.8646545410156,207.48870849609375,8.77850341796875],[64.88443756103516,396.0125427246094,38.62542724609375,11.530364990234375],[64.88443756103516,408.6724548339844,117.09406280517578,12.15325927734375],[64.88443756103516,425.380859375,168.8362808227539,8.77850341796875]],"start":444,"text":"AddTask1 t1 = new AddTask1(n - 1);\n        t1.fork();\n        log.debug(\"fork() {} + {}\", n, t1);\n        \n        // 合并(join)结果\n        int result = n + t1.join();"}],"type":5},{"date":"2021-11-28 22:47:01","docid":0,"fillcolor":"ffffed99","id":987,"originaltext":"Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值）","page":159,"textblocks":[{"first":[84.1566390991211,722.728515625,5.033012390136719,13.5],"last":[492.09552001953125,722.728515625,9.75390625,13.5],"length":64,"rects":[[84.1566390991211,722.728515625,417.69278717041016,13.5]],"start":563,"text":"Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值）"}],"type":5},{"date":"2021-11-28 22:47:08","docid":0,"fillcolor":"ffffed99","id":988,"originaltext":"用图来表示","page":161,"textblocks":[{"first":[52.3574333190918,215.07843017578125,9.753898620605469,12.5],"last":[91.37303161621094,215.07843017578125,9.753898620605469,12.5],"length":5,"rects":[[52.3574333190918,215.07843017578125,48.76949691772461,12.5]],"start":481,"text":"用图来表示"}],"type":5}],"originaltext":"使用","page":159,"textblocks":[{"first":[63.76499557495117,700.0189208984375,9.753902435302734,12.5],"last":[73.5188980102539,700.0189208984375,9.753898620605469,12.5],"length":2,"rects":[[63.76499557495117,700.0189208984375,19.507801055908203,12.5]],"start":555,"text":"使用"}],"type":5}],"originaltext":"Fork/Join","page":159,"textblocks":[{"first":[65.96487426757812,511.7948303222656,6.693611145019531,15.499969482421875],"last":[113.6370620727539,511.7948303222656,8.010391235351562,15.499969482421875],"length":9,"rects":[[65.96487426757812,511.7948303222656,55.682579040527344,15.499969482421875]],"start":295,"text":"Fork/Join"}],"type":5}],"originaltext":"线程池","page":140,"textblocks":[{"first":[76.99653625488281,392.6495056152344,14.630851745605469,17.5],"last":[106.25823974609375,392.6495056152344,14.630851745605469,17.5],"length":3,"rects":[[76.99653625488281,392.6495056152344,43.892555236816406,17.5]],"start":287,"text":"线程池"}],"type":5},{"date":"2021-11-30 14:16:58","docid":0,"fillcolor":"ffffed99","folded":false,"id":989,"markups":[{"content":"工具包中最基础的原理","date":"2021-11-30 14:17:49","docid":0,"fillcolor":"ffffed99","id":990,"originaltext":"AQS 原理","page":163,"textblocks":[{"first":[75.77223205566406,402.9975891113281,8.412734985351562,15.5],"last":[115.71501922607422,402.9975891113281,12.192375183105469,15.5],"length":6,"rects":[[75.77223205566406,402.9975891113281,52.135162353515625,15.5]],"start":96,"text":"AQS 原理"}],"type":5}],"originaltext":"J.U.C","page":163,"textblocks":[{"first":[77.0404281616211,374.8868103027344,4.842811584472656,14.5],"last":[99.96562194824219,374.8868103027344,9.319854736328125,14.5],"length":5,"rects":[[77.0404281616211,374.8868103027344,32.24504852294922,14.5]],"start":84,"text":"J.U.C"}],"type":5}],"originaltext":"共享模型之工具","page":140,"textblocks":[{"first":[71.37303924560547,354.3854064941406,17.06932830810547,20.5],"last":[173.78897094726562,354.3854064941406,17.069320678710938,20.5],"length":7,"rects":[[71.37303924560547,354.3854064941406,119.4852523803711,20.5]],"start":274,"text":"共享模型之工具"}],"type":5}],"maxid":1054,"notelinks":[],"scalingratio":80,"title":"并发编程","unimportant":[]}