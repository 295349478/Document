{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"content":"spring只能削减耦合不能直接消除耦合\n\nspringIOC能解决什么问题？\n如何搭建springIOC基于xml的环境？\n如何实现依赖注入？","date":"2021-12-20 14:05:35","docid":0,"fillcolor":"ffffed99","folded":false,"id":1,"markups":[{"date":"2021-12-20 14:05:45","docid":0,"fillcolor":"ffffed99","id":2,"originaltext":"spring 的体系结构","page":1,"textblocks":[{"first":[106.9000015258789,342.2499694824219,5.368202209472656,16.5],"last":[204.818603515625,342.2499694824219,13.800003051757812,16.5],"length":12,"rects":[[106.9000015258789,342.2499694824219,111.7186050415039,16.5]],"start":519,"text":"spring 的体系结构"}],"type":5}],"originaltext":"spring 概述","page":0,"textblocks":[{"first":[276.8800048828125,203.05874633789062,6.301788330078125,19.364059448242188],"last":[340.55499267578125,203.05874633789062,16.20001220703125,19.364059448242188],"length":9,"rects":[[276.8800048828125,203.05874633789062,79.875,19.364059448242188]],"start":114,"text":"spring 概述"}],"type":5},{"content":"IOC的作用：降低耦合（依赖）\n\n基于工厂模式+反射实现的框架","date":"2021-12-20 14:05:51","docid":0,"fillcolor":"ffffed99","folded":false,"id":3,"markups":[{"content":"做到编译不依赖，运行依赖","date":"2021-12-20 14:06:16","docid":0,"fillcolor":"ffffed99","id":4,"originaltext":"解决程序耦合的思路","page":3,"textblocks":[{"first":[106.9000015258789,702.640625,13.800003051757812,14.015625],"last":[219.82540893554688,702.640625,13.800003051757812,14.015625],"length":9,"rects":[[106.9000015258789,702.640625,126.72541046142578,14.015625]],"start":1031,"text":"解决程序耦合的思路"}],"type":5},{"content":"bean：英语含义是可重用组件\nJavabean：用Java语言编写的可重用组件\nJavabaen > 实体类\n\nspring要做到类的可重用，就要掌握类创建的功能\n最好的实现就是使用 配置文件 的反射创建 对象\n创建对象就需要 \n对象名 = 全限定类名\n使用key = value 的方式进行创建","date":"2021-12-20 14:20:41","docid":0,"fillcolor":"ffffed99","id":5,"originaltext":"控制反转-Inversion Of Control","page":4,"textblocks":[{"first":[106.9000015258789,275.8749694824219,13.800003051757812,14.65625],"last":[290.08001708984375,275.8749694824219,3.836395263671875,14.65625],"length":25,"rects":[[106.9000015258789,275.8749694824219,187.01641082763672,14.65625]],"start":390,"text":"控制反转-Inversion Of Control"}],"type":5}],"originaltext":"IoC 的概念和作用","page":2,"textblocks":[{"first":[242.64999389648438,79.98040771484375,8.645523071289062,22.311813354492188],"last":[394.0050354003906,79.98040771484375,22.225006103515625,22.311813354492188],"length":10,"rects":[[242.64999389648438,79.98040771484375,173.58004760742188,22.311813354492188]],"start":87,"text":"IoC 的概念和作用"}],"type":5},{"content":"其实就是导入文件中所有的key = value\n根据key获得value使用反射将文件中的所有全限定类名打入内存\n也就是创建了类 \n然后将这些使用反射方法newInstance()创建的实例对象全部存储到map<String,Object> 中\n所以IOC本质就是返回一个map<String,Object>类型的map集合","date":"2021-12-20 15:33:46","docid":0,"fillcolor":"ffffed99","folded":false,"id":6,"markups":[{"date":"2021-12-20 15:47:01","docid":0,"fillcolor":"ffffed99","folded":true,"id":7,"markups":[{"content":"其中ApplicationContext的实现类有4个类型：\n1、Xml：基于类路径下的配置文件 创建的bean容器\n2、File：基于磁盘任意路径下的配置文件 创建的bean容器\n3、Anntoatio：基于注解创建的bean容器\n4、Generic：基于脚本创建的bean容器","date":"2021-12-20 15:47:27","docid":0,"fillcolor":"ffffed99","id":8,"originaltext":"spring 中工厂的类结构图","page":10,"textblocks":[{"first":[106.9000015258789,449.87060546875,5.368202209472656,14.015625],"last":[247.4477996826172,449.87060546875,13.800003051757812,14.015625],"length":15,"rects":[[106.9000015258789,449.87060546875,154.3478012084961,14.015625]],"start":540,"text":"spring 中工厂的类结构图"}],"type":5},{"content":"两大容器的区别\nApplicationContext：\n创建对象采取的策略是立即加载的方式：\n一加载完成配置文件，就立即创建对象的模式\n\n使用时机：创建单例对象的时候使用\n\nBeanFactory：\n创建对象采取的策略是延迟加载的方式：\n什么时候根据id获取对象，什么时候真正创建对象\n\nBeanFactory的重要实现：DefaultListableBeanFactory\n\n\n使用时机：创建多例对象的时候使用\n\n注意：BeanFactory已经过时，因为ApplicationContext是在BeanFactory上面的拓展，对单例多例配置已经集成，可以在配置文件进行配置scope。但是他的延迟创建还是一摸一样的","date":"2021-12-20 15:52:58","docid":0,"fillcolor":"ffffed99","id":9,"originaltext":"BeanFactory 和 ApplicationContext 的区别","page":11,"textblocks":[{"first":[112.93000030517578,468.3499755859375,9.204597473144531,16.5],"last":[360.3699645996094,468.3499755859375,13.79998779296875,16.5],"length":36,"rects":[[112.93000030517578,468.3499755859375,261.23995208740234,16.5]],"start":93,"text":"BeanFactory 和 ApplicationContext 的区别"}],"type":5},{"content":"其中ApplicationContext的实现类有4个类型：\n1、Xml：基于类路径下的配置文件 创建的bean容器\n2、File：基于磁盘任意路径下的配置文件 创建的bean容器\n3、Anntoatio：基于注解创建的bean容器，回去寻找带有@Configation注解的类\n注意当作为AnnotationConfigApplicationContext的参数时候可以不写，因为作为参数它会直接定位，并不绝对，有特殊情况\n4、Generic：基于脚本创建的bean容器","date":"2021-12-20 15:55:48","docid":0,"fillcolor":"ffffed99","id":10,"originaltext":"ApplicationContext 接口的实现类","page":11,"textblocks":[{"first":[112.93000030517578,621.9625244140625,9.963600158691406,15.859375],"last":[304.4847717285156,621.9625244140625,13.79998779296875,15.859375],"length":25,"rects":[[112.93000030517578,621.9625244140625,205.3547592163086,15.859375]],"start":328,"text":"ApplicationContext 接口的实现类"}],"type":5}],"originaltext":" Spring 基于 XML 的 IOC 细节","page":10,"textblocks":[{"first":[90.69999694824219,405,4.50360107421875,14.5],"last":[290.1050109863281,405,16.20001220703125,14.5],"length":23,"rects":[[90.69999694824219,405,215.6050262451172,14.5]],"start":505,"text":" Spring 基于 XML 的 IOC 细节"}],"type":5},{"date":"2021-12-20 16:07:00","docid":0,"fillcolor":"ffffed99","folded":false,"id":11,"markups":[{"content":"作用范围：\n\n对于global session作用范围专门用于多台服务器的情况\n也就是集群下的session，因为session在替换服务器的过程会导致普通的服务器产生新的session","date":"2021-12-20 16:34:05","docid":0,"fillcolor":"ffffed99","id":17,"originaltext":"bean 标签","page":12,"textblocks":[{"first":[112.93000030517578,124.89997863769531,7.672798156738281,16.5],"last":[159.77500915527344,124.89997863769531,13.800003051757812,16.5],"length":7,"rects":[[112.93000030517578,124.89997863769531,60.64501190185547,16.5]],"start":119,"text":"bean 标签"}],"type":5},{"content":"生命周期：\n单例的生命周期容易理解\n\n多例的生命周期：是延迟创建，使用到的时候创建，使用就一直存活，长时间不用的时候才会由 Java垃圾回收器 销毁\n\n可以使用加入init-Method加入创建的时候会调用的方法\n可以使用加入destory-Method加入销毁的时候会调用的方法","date":"2021-12-20 16:26:47","docid":0,"fillcolor":"ffffed99","id":16,"originaltext":"bean 的作用范围和生命周期","page":12,"textblocks":[{"first":[112.93000030517578,435.4706115722656,7.672798156738281,14.015625],"last":[272.07537841796875,435.4706115722656,13.79998779296875,14.015625],"length":15,"rects":[[112.93000030517578,435.4706115722656,172.94536590576172,14.015625]],"start":623,"text":"bean 的作用范围和生命周期"}],"type":5},{"date":"2021-12-20 16:11:16","docid":0,"fillcolor":"ffffed99","folded":true,"id":12,"markups":[{"content":"直接使用无参构造方法，没有就回抛异常","date":"2021-12-20 16:12:18","docid":0,"fillcolor":"ffffed99","id":13,"originaltext":"第一种方式：使用默认无参构造函数","page":12,"textblocks":[{"first":[91.9000015258789,722.3956298828125,9,9],"last":[227.49398803710938,722.3956298828125,9,9],"length":16,"rects":[[91.9000015258789,722.3956298828125,144.59398651123047,9]],"start":958,"text":"第一种方式：使用默认无参构造函数"}],"type":5},{"content":"创建对象的方法在别的类里面，并且这个方法是静态的属于类的\n\n直接搞一个把bean输入真正的id，指定静态全限定类名，指定方法名那个即可","date":"2021-12-20 16:15:22","docid":0,"fillcolor":"ffffed99","id":14,"originaltext":"第二种方式：spring 管理静态工厂-使用静态工厂的方法创建对象","page":13,"textblocks":[{"first":[91.9000015258789,121.96563720703125,9,9],"last":[348.843994140625,121.96563720703125,9,9],"length":33,"rects":[[91.9000015258789,121.96563720703125,265.9439926147461,9]],"start":172,"text":"第二种方式：spring 管理静态工厂-使用静态工厂的方法创建对象"}],"type":5},{"content":"创建对象的方法在别的类里面\n\n需要实例这个对象，然后使用factory-bean指定对象，factory-method指定里面的方法","date":"2021-12-20 16:19:16","docid":0,"fillcolor":"ffffed99","id":15,"originaltext":"第三种方式：spring 管理实例工厂-使用实例工厂的方法创建对象","page":13,"textblocks":[{"first":[91.9000015258789,434.18560791015625,9,9],"last":[348.843994140625,434.18560791015625,9,9],"length":33,"rects":[[91.9000015258789,434.18560791015625,265.9439926147461,9]],"start":674,"text":"第三种方式：spring 管理实例工厂-使用实例工厂的方法创建对象"}],"type":5}],"originaltext":"实例化 Bean 的三种方式","page":12,"textblocks":[{"first":[112.93000030517578,683.4874267578125,13.800003051757812,14.015625],"last":[249.2491912841797,683.4874267578125,13.800003051757812,14.015625],"length":14,"rects":[[112.93000030517578,683.4874267578125,150.11919403076172,14.015625]],"start":941,"text":"实例化 Bean 的三种方式"}],"type":5}],"originaltext":"IOC 中 bean 标签和管理对象细节","page":12,"textblocks":[{"first":[106.9000015258789,80.0699691772461,5.368202209472656,15.5],"last":[299.71337890625,80.0699691772461,13.79998779296875,15.5],"length":20,"rects":[[106.9000015258789,80.0699691772461,206.61336517333984,15.5]],"start":89,"text":"IOC 中 bean 标签和管理对象细节"}],"type":5},{"date":"2021-12-20 16:39:52","docid":0,"fillcolor":"ffffed99","folded":false,"id":18,"markups":[{"content":"对于类之间的依赖，springIOC只能削减不能消除，也就是说还是有依赖的\n而依赖注入就是写明类的依赖\n\n什么数据可以注入？\n三种数据可以依赖注入（也就是说这些数据不能再削除依赖的）：\n1、基本数据类型和String\n2、其他bean类型（配置文件中或者注解过的bean）\n3、复杂类型/也就是集合类型\n\n怎么注入？\n三种方法：\n1、使用构造函数提供\n2、使用set方法提供\n3、使用注解提供","date":"2021-12-20 16:41:58","docid":0,"fillcolor":"ffffed99","id":19,"originaltext":"依赖注入的概念","page":14,"textblocks":[{"first":[112.93000030517578,126.2406005859375,13.800003051757812,13.800003051757812],"last":[197.62060546875,126.2406005859375,13.800003051757812,13.800003051757812],"length":7,"rects":[[112.93000030517578,126.2406005859375,98.49060821533203,13.800003051757812]],"start":111,"text":"依赖注入的概念"}],"type":5},{"date":"2021-12-20 16:46:59","folded":true,"id":21,"linecolor":"ff59c6ff","markups":[{"content":"本质上就是分为\nconstructor-arg构造函数注入：创建对象的时候直接进入依赖注入数据，这样创建对象就必须提供初始数据\n\nset方法配合property的set方法注入：可以选择的注入数据","date":"2021-12-20 16:46:51","docid":0,"fillcolor":"ffffed99","folded":false,"id":20,"markups":[{"content":"用于构造函数","date":"2021-12-20 16:52:42","docid":0,"fillcolor":"ffffed99","id":25,"originaltext":"constructor-arg","page":14,"textblocks":[{"first":[133.92999267578125,708.5087890625,6.4799957275390625,12.234375],"last":[222.1927947998047,708.5087890625,6.4799957275390625,12.234375],"length":15,"rects":[[133.92999267578125,708.5087890625,94.7427978515625,12.234375]],"start":923,"text":"constructor-arg"}],"type":5}],"originaltext":"构造函数注入","page":14,"textblocks":[{"first":[112.93000030517578,263.7406005859375,13.800003051757812,14.015625],"last":[183.21340942382812,263.7406005859375,13.800003051757812,14.015625],"length":6,"rects":[[112.93000030517578,263.7406005859375,84.08341217041016,14.015625]],"start":363,"text":"构造函数注入"}],"type":5},{"date":"2021-12-20 16:47:17","docid":0,"fillcolor":"ffffed99","folded":false,"id":22,"markups":[{"content":"属性","date":"2021-12-20 16:54:31","docid":0,"fillcolor":"ffffed99","id":26,"originaltext":"property","page":15,"textblocks":[{"first":[133.92999267578125,757.7587890625,6.4799957275390625,12.234375],"last":[178.29635620117188,757.7587890625,6.4799957275390625,12.234375],"length":8,"rects":[[133.92999267578125,757.7587890625,50.84635925292969,12.234375]],"start":1151,"text":"property"}],"type":5}],"originaltext":" set 方法注入","page":15,"textblocks":[{"first":[109.30000305175781,314.2074890136719,3.8364028930664062,14.015625],"last":[175.3719940185547,314.2074890136719,13.800003051757812,14.015625],"length":9,"rects":[[109.30000305175781,314.2074890136719,79.87199401855469,14.015625]],"start":606,"text":" set 方法注入"}],"type":5},{"content":"复杂类型也是要使用set，也就是property属性name写属性即可","date":"2021-12-20 16:47:38","docid":0,"fillcolor":"ffffed99","id":24,"originaltext":"注入集合属性","page":17,"textblocks":[{"first":[112.93000030517578,219.91058349609375,13.800003051757812,13.800003051757812],"last":[183.21340942382812,219.91058349609375,13.800003051757812,13.800003051757812],"length":6,"rects":[[112.93000030517578,219.91058349609375,84.08341217041016,13.800003051757812]],"start":470,"text":"注入集合属性"}],"type":5},{"date":"2021-12-20 16:47:31","docid":0,"fillcolor":"ffffed99","id":23,"originaltext":"使用 p 名称空间注入数据（本质还是调用 set 方法）","page":16,"textblocks":[{"first":[112.93000030517578,282.34063720703125,13.800003051757812,14.015625],"last":[418.634765625,282.34063720703125,13.79998779296875,14.015625],"length":28,"rects":[[112.93000030517578,282.34063720703125,319.50475311279297,14.015625]],"start":493,"text":"使用 p 名称空间注入数据（本质还是调用 set 方法）"}],"type":5}],"page":-1,"title":"注入的要点","type":7}],"originaltext":"spring 的依赖注入","page":14,"textblocks":[{"first":[106.9000015258789,78.469970703125,5.368202209472656,17.5],"last":[204.80580139160156,78.469970703125,13.800003051757812,17.5],"length":12,"rects":[[106.9000015258789,78.469970703125,111.70580291748047,17.5]],"start":89,"text":"spring 的依赖注入"}],"type":5}],"originaltext":"使用 spring 的 IOC 解决程序耦合","page":5,"textblocks":[{"first":[168.77000427246094,485.75,22.225006103515625,25.5],"last":[467.8750305175781,485.75,22.225006103515625,25.5],"length":22,"rects":[[168.77000427246094,485.75,321.3300323486328,25.5]],"start":181,"text":"使用 spring 的 IOC 解决程序耦合"}],"type":5}],"maxid":26,"notelinks":[],"title":"spring5第一天","unimportant":[]}