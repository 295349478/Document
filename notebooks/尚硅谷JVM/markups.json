{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2022-04-02 15:35:01","docid":0,"id":591,"imgfile":"580fc6f143d438dc42a4b2d270aa7250.png","linecolor":"ffa0ec6f","linewidth":2,"page":19,"rect":[57.32048329433766,29.163052904136705,557.6176839773725,452.5301312710868],"title":"整体结构","type":2},{"date":"2022-04-01 16:06:02","docid":0,"fillcolor":"ffffed99","folded":false,"id":441,"markups":[{"date":"2022-04-01 16:06:06","docid":0,"fillcolor":"ffffed99","id":442,"originaltext":"虚拟机","page":8,"textblocks":[{"first":[75.52161407470703,369.41650390625,17.07042694091797,20.5],"last":[109.6624755859375,369.41650390625,17.0704345703125,20.5],"length":3,"rects":[[75.52161407470703,369.41650390625,51.21129608154297,20.5]],"start":219,"text":"虚拟机"}],"type":5},{"content":"操作系统上一级","date":"2022-04-01 16:06:20","docid":0,"fillcolor":"ffffed99","id":443,"originaltext":"JVM的位置","page":9,"textblocks":[{"first":[75.52161407470703,105.59394836425781,5.6503143310546875,21.5],"last":[142.5030517578125,105.59394836425781,17.0704345703125,21.5],"length":6,"rects":[[75.52161407470703,105.59394836425781,84.05187225341797,21.5]],"start":37,"text":"JVM的位置"}],"type":5},{"content":"说出整体结构即可","date":"2022-04-01 16:06:25","docid":0,"fillcolor":"ffffed99","id":444,"originaltext":"JVM的整体结构","page":9,"textblocks":[{"first":[75.52161407470703,750.59375,5.6503143310546875,20.5],"last":[176.6439208984375,750.59375,17.0704345703125,20.5],"length":8,"rects":[[75.52161407470703,750.59375,118.19274139404297,20.5]],"start":76,"text":"JVM的整体结构"}],"type":5},{"content":"Java的执行流程","date":"2022-04-01 16:06:30","docid":0,"fillcolor":"ffffed99","id":445,"originaltext":"Java代码执行流程","page":10,"textblocks":[{"first":[75.52161407470703,526.98828125,5.6503143310546875,19.5],"last":[196.85670471191406,526.98828125,17.0704345703125,19.5],"length":10,"rects":[[75.52161407470703,526.98828125,138.40552520751953,19.5]],"start":75,"text":"Java代码执行流程"}],"type":5},{"content":"两种指令集架构：\n1、基于栈的指令集架构（Java）\n2、基于寄存器的指令集架构\n\n特点从高效以及移植性，是否依赖于硬件","date":"2022-04-01 16:06:41","docid":0,"fillcolor":"ffffed99","folded":true,"id":446,"markups":[{"content":"相当于手机：\n实现简单，移植性性强，不需要硬件","date":"2022-04-01 16:13:08","docid":0,"fillcolor":"ffffed99","id":449,"originaltext":"基于栈的指令集架构","page":11,"textblocks":[{"first":[75.52161407470703,461.70703125,14.631797790527344,17.5],"last":[192.5760040283203,461.70703125,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,461.70703125,131.6861801147461,17.5]],"start":82,"text":"基于栈的指令集架构"}],"type":5},{"content":"相当于电脑：\n高效强，依赖硬件","date":"2022-04-01 16:13:13","docid":0,"fillcolor":"ffffed99","id":450,"originaltext":"基于寄存器的指令级架构","page":11,"textblocks":[{"first":[75.52161407470703,584.0146484375,14.631797790527344,17.5],"last":[221.839599609375,584.0146484375,14.631805419921875,17.5],"length":11,"rects":[[75.52161407470703,584.0146484375,160.94979095458984,17.5]],"start":227,"text":"基于寄存器的指令级架构"}],"type":5},{"content":"跨平台性，指令集小，指令多，执行性能比寄存器差","date":"2022-04-01 16:18:57","docid":0,"fillcolor":"ffffed99","folded":true,"id":451,"markups":[{"date":"2022-04-01 16:19:06","docid":0,"fillcolor":"ffffed99","id":452,"originaltext":"由于跨平台性的设计，Java的指令都是根据栈来设计的。","page":12,"textblocks":[{"first":[98.03207397460938,456.703125,9.754531860351562,12.5],"last":[333.1842956542969,456.703125,9.754547119140625,12.5],"length":27,"rects":[[98.03207397460938,456.703125,244.90676879882812,12.5]],"start":99,"text":"由于跨平台性的设计，Java的指令都是根据栈来设计的。"}],"type":5}],"originaltext":"JVM架构总结","page":12,"textblocks":[{"first":[75.52161407470703,427.19140625,4.8431243896484375,17.5],"last":[147.56607055664062,427.19140625,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,427.19140625,86.67626190185547,17.5]],"start":87,"text":"JVM架构总结"}],"type":5}],"originaltext":"JVM的架构模型","page":11,"textblocks":[{"first":[75.52161407470703,391.9248046875,5.6503143310546875,19.5],"last":[176.6439208984375,391.9248046875,17.0704345703125,19.5],"length":8,"rects":[[75.52161407470703,391.9248046875,118.19274139404297,19.5]],"start":2,"text":"JVM的架构模型"}],"type":5},{"date":"2022-04-01 16:06:52","docid":0,"fillcolor":"ffffed99","folded":true,"id":447,"markups":[{"content":"通过 类加载器 创建 初始类 开始","date":"2022-04-01 16:21:26","docid":0,"fillcolor":"ffffed99","id":454,"originaltext":"虚拟机的启动","page":12,"textblocks":[{"first":[75.52161407470703,632.5380859375,14.631797790527344,17.5],"last":[148.68060302734375,632.5380859375,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,632.5380859375,87.7907943725586,17.5]],"start":390,"text":"虚拟机的启动"}],"type":5},{"content":"执行一个Java程序，其实执行的是Java虚拟机的一个进程","date":"2022-04-01 16:21:31","docid":0,"fillcolor":"ffffed99","folded":true,"id":455,"markups":[{"date":"2022-04-01 16:25:05","docid":0,"fillcolor":"ffffed99","id":457,"originaltext":"3. 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程","page":12,"textblocks":[{"first":[87.52719116210938,762.845703125,5.57958984375,12.5],"last":[441.5459289550781,762.845703125,9.754547119140625,12.5],"length":43,"rects":[[87.52719116210938,762.845703125,363.7732849121094,12.5]],"start":555,"text":"3. 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程"}],"type":5}],"originaltext":"虚拟机的执行","page":12,"textblocks":[{"first":[75.52161407470703,703.3203125,14.631797790527344,17.5],"last":[148.68060302734375,703.3203125,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,703.3203125,87.7907943725586,17.5]],"start":487,"text":"虚拟机的执行"}],"type":5},{"content":"正常执行完毕的Java程序虚拟机就结束了","date":"2022-04-01 16:21:36","docid":0,"fillcolor":"ffffed99","folded":true,"id":456,"markups":[{"date":"2022-04-01 16:25:28","docid":0,"fillcolor":"ffffed99","id":458,"originaltext":"1. 程序正常执行结束","page":13,"textblocks":[{"first":[87.52719116210938,82.279296875,5.57958984375,13.5],"last":[166.3137969970703,82.279296875,9.754531860351562,13.5],"length":11,"rects":[[87.52719116210938,82.279296875,88.5411376953125,13.5]],"start":18,"text":"1. 程序正常执行结束"}],"type":5},{"date":"2022-04-01 16:25:34","docid":0,"fillcolor":"ffffed99","id":459,"originaltext":"2. 程序在执行过程中遇到了异常或错误而异常终止","page":13,"textblocks":[{"first":[87.52719116210938,96.98612976074219,5.57958984375,13.5],"last":[293.1227111816406,96.98612976074219,9.754547119140625,13.5],"length":24,"rects":[[87.52719116210938,96.98612976074219,215.35006713867188,13.5]],"start":30,"text":"2. 程序在执行过程中遇到了异常或错误而异常终止"}],"type":5},{"date":"2022-04-01 16:25:40","docid":0,"fillcolor":"ffffed99","id":460,"originaltext":"3. 由于操作系统用现错误而导致Java虚拟机进程终止","page":13,"textblocks":[{"first":[87.52719116210938,111.99296569824219,5.57958984375,13.5],"last":[301.7103271484375,111.99296569824219,9.7545166015625,13.5],"length":27,"rects":[[87.52719116210938,111.99296569824219,223.93765258789062,13.5]],"start":55,"text":"3. 由于操作系统用现错误而导致Java虚拟机进程终止"}],"type":5}],"originaltext":"虚拟机的退出","page":13,"textblocks":[{"first":[75.52161407470703,30.2568359375,14.631797790527344,17.5],"last":[148.68060302734375,30.2568359375,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,30.2568359375,87.7907943725586,17.5]],"start":0,"text":"虚拟机的退出"}],"type":5}],"originaltext":"JVM的生命周期","page":12,"textblocks":[{"first":[75.52161407470703,602.5234375,5.6503143310546875,19.5],"last":[176.6439208984375,602.5234375,17.0704345703125,19.5],"length":8,"rects":[[75.52161407470703,602.5234375,118.19274139404297,19.5]],"start":380,"text":"JVM的生命周期"}],"type":5},{"date":"2022-04-01 16:06:58","docid":0,"fillcolor":"ffffed99","folded":true,"id":448,"markups":[{"content":"默认以HotSpot虚拟机为主","date":"2022-04-01 16:30:14","docid":0,"fillcolor":"ffffed99","id":461,"markups":[{"date":"2022-04-01 16:30:23","docid":0,"fillcolor":"ffffed99","id":462,"originaltext":"具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以Oracle HotSpot VM为默认虚拟机。","page":16,"textblocks":[{"first":[75.52161407470703,319.83966064453125,9.754531860351562,13.5],"last":[308.3062744140625,334.0464782714844,9.7545166015625,14.5],"length":82,"rects":[[75.52161407470703,319.83966064453125,444.1265182495117,13.5],[75.52161407470703,334.0464782714844,242.53917694091797,14.5]],"start":632,"text":"具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存\n在一定差异。主要以Oracle HotSpot VM为默认虚拟机。"}],"type":5}],"originaltext":"总结","page":16,"textblocks":[{"first":[75.52161407470703,289.6279296875,14.631797790527344,18.5],"last":[90.15341186523438,289.6279296875,14.631797790527344,18.5],"length":2,"rects":[[75.52161407470703,289.6279296875,29.263595581054688,18.5]],"start":628,"text":"总结"}],"type":5}],"originaltext":"JVM发展历程","page":13,"textblocks":[{"first":[75.52161407470703,220.595703125,5.6503143310546875,19.5],"last":[159.573486328125,220.595703125,17.0704345703125,19.5],"length":7,"rects":[[75.52161407470703,220.595703125,101.12230682373047,19.5]],"start":261,"text":"JVM发展历程"}],"type":5}],"originaltext":"第1章-JVM和Java体系架构","page":0,"textblocks":[{"first":[75.52161407470703,214.1458740234375,21.94770050048828,26.5],"last":[315.28521728515625,214.1458740234375,21.94769287109375,26.5],"length":16,"rects":[[75.52161407470703,214.1458740234375,261.71129608154297,26.5]],"start":186,"text":"第1章-JVM和Java体系架构"}],"type":5},{"content":"总结：\n\n过程：\n1、二进制字节流\n2、cafebabe验证\n3、准备赋初始值\n4、符号引用换直接引用\n5、clint()方法\n\n类加载器分类已经机制\n\n其他：\n1、判断class对象的相同\n2、一个类由用户类加载器加载，会携带加载器的引用\n\n记住：\n1、类加载的过程\n2、类加载器的分类\n3、自定义类加载器的用处\n4、双亲委派机制\n5、如何判断两个类相同","date":"2022-04-01 16:30:51","docid":0,"fillcolor":"ffffed99","folded":false,"id":463,"markups":[{"date":"2022-04-01 16:33:02","docid":0,"fillcolor":"ffffed99","folded":true,"id":464,"markups":[{"date":"2022-04-01 16:33:23","docid":0,"fillcolor":"ffffed99","id":466,"originaltext":"注意：方法区只有HotSpot虚拟机有","page":19,"textblocks":[{"first":[75.52161407470703,457.1043395996094,9.754531860351562,14.5],"last":[220.0201416015625,457.1043395996094,9.754531860351562,14.5],"length":19,"rects":[[75.52161407470703,457.1043395996094,154.25305938720703,14.5]],"start":0,"text":"注意：方法区只有HotSpot虚拟机有"}],"type":5}],"originaltext":"内存结构概述","page":17,"textblocks":[{"first":[75.52161407470703,122.0509033203125,17.07042694091797,19.5],"last":[160.87376403808594,122.0509033203125,17.0704345703125,19.5],"length":6,"rects":[[75.52161407470703,122.0509033203125,102.4225845336914,19.5]],"start":14,"text":"内存结构概述"}],"type":5},{"date":"2022-04-01 16:35:36","docid":0,"fillcolor":"ffffed99","folded":true,"id":467,"markups":[{"content":"1、根据表示接收Class字节码文件（存在特定标识）\n2、加载处理Class字节码文件\n3、其中的类信息被放到方法区中\n\n总结：根据特定的方法将class字节码文件加载到内存中","date":"2022-04-01 16:36:52","docid":0,"fillcolor":"ffffed99","folded":false,"id":468,"markups":[{"date":"2022-04-01 16:41:14","docid":0,"fillcolor":"ffffed99","id":469,"originaltext":"加载的类信息存放于一块称为方法区的内存空间","page":19,"textblocks":[{"first":[98.03207397460938,665.300537109375,9.754531860351562,13.5],"last":[293.1227111816406,665.300537109375,9.754547119140625,13.5],"length":21,"rects":[[98.03207397460938,665.300537109375,204.84518432617188,13.5]],"start":220,"text":"加载的类信息存放于一块称为方法区的内存空间"}],"type":5}],"originaltext":"类加载器子系统作用：","page":19,"textblocks":[{"first":[75.52161407470703,597.769287109375,9.754531860351562,12.5],"last":[163.31240844726562,597.769287109375,9.754531860351562,12.5],"length":10,"rects":[[75.52161407470703,597.769287109375,97.54532623291016,12.5]],"start":91,"text":"类加载器子系统作用："}],"type":5}],"originaltext":"类加载器子系统","page":19,"textblocks":[{"first":[75.52161407470703,566.3572998046875,17.07042694091797,20.5],"last":[177.94419860839844,566.3572998046875,17.0704345703125,20.5],"length":7,"rects":[[75.52161407470703,566.3572998046875,119.4930191040039,20.5]],"start":82,"text":"类加载器子系统"}],"type":5},{"content":"相当于根据.class文件在内存中画出一个类来，其中画出的类就是DNA元数据模板（DNA放在方法区中）\n而这个画师就是classLoader","date":"2022-04-01 16:41:20","docid":0,"fillcolor":"ffffed99","id":470,"originaltext":"类加载器ClassLoader角色","page":20,"textblocks":[{"first":[75.52161407470703,219.74594116210938,17.07042694091797,19.5],"last":[263.4046936035156,219.74594116210938,17.0704345703125,19.5],"length":17,"rects":[[75.52161407470703,219.74594116210938,204.9535140991211,19.5]],"start":2,"text":"类加载器ClassLoader角色"}],"type":5},{"content":"classLoader画师画画的过程","date":"2022-04-01 16:44:16","docid":0,"fillcolor":"ffffed99","folded":true,"id":471,"markups":[{"date":"2022-04-01 16:44:50","docid":0,"fillcolor":"ffffed99","folded":true,"id":472,"markups":[{"content":"1、加载\n（也就是让classloader画师画出DNA元数据，其中画不出来就抛异常）\n2、链接\n3、初始化","date":"2022-04-01 16:48:19","docid":0,"fillcolor":"ffffed99","id":473,"originaltext":"加载过程","page":21,"textblocks":[{"first":[95.03067779541016,200.5849609375,9.754531860351562,13.5],"last":[124.29427337646484,200.5849609375,9.754524230957031,13.5],"length":4,"rects":[[95.03067779541016,200.5849609375,39.01811981201172,13.5]],"start":8,"text":"加载过程"}],"type":5},{"date":"2022-04-01 16:50:12","docid":0,"fillcolor":"ffffed99","id":474,"originaltext":"完整的流程图","page":21,"textblocks":[{"first":[75.52161407470703,648.543212890625,9.754531860351562,12.5],"last":[124.29427337646484,648.543212890625,9.754524230957031,12.5],"length":6,"rects":[[75.52161407470703,648.543212890625,58.527183532714844,12.5]],"start":125,"text":"完整的流程图"}],"type":5}],"originaltext":"概述","page":21,"textblocks":[{"first":[75.52161407470703,30.25732421875,14.631797790527344,17.5],"last":[90.15341186523438,30.25732421875,14.631797790527344,17.5],"length":2,"rects":[[75.52161407470703,30.25732421875,29.263595581054688,17.5]],"start":0,"text":"概述"}],"type":5},{"content":"画师查看直接看的一个动作\n将字节码文件转化成二进制流文件","date":"2022-04-01 16:50:20","docid":0,"fillcolor":"ffffed99","folded":true,"id":475,"markups":[{"content":"1、以全限定类名获取二进制字节流\n2、将字节流的信息放到方法区\n3、内存中生成一个class对象指向方法区，以便访问","date":"2022-04-01 16:51:29","docid":0,"fillcolor":"ffffed99","id":476,"originaltext":"加载","page":22,"textblocks":[{"first":[75.52161407470703,245.855712890625,9.754531860351562,12.5],"last":[85.2761459350586,245.855712890625,9.754531860351562,12.5],"length":2,"rects":[[75.52161407470703,245.855712890625,19.509063720703125,12.5]],"start":8,"text":"加载"}],"type":5},{"content":"画师可以向哪些地方画画","date":"2022-04-01 16:56:49","docid":0,"fillcolor":"ffffed99","id":477,"originaltext":"加载class文件的方式：","page":22,"textblocks":[{"first":[75.52161407470703,321.640869140625,9.754531860351562,12.5],"last":[167.38473510742188,321.640869140625,9.754531860351562,12.5],"length":13,"rects":[[75.52161407470703,321.640869140625,101.6176528930664,12.5]],"start":127,"text":"加载class文件的方式："}],"type":5}],"originaltext":"加载阶段","page":22,"textblocks":[{"first":[75.52161407470703,216.343505859375,14.631797790527344,17.5],"last":[119.41700744628906,216.343505859375,14.631790161132812,17.5],"length":4,"rects":[[75.52161407470703,216.343505859375,58.527183532714844,17.5]],"start":2,"text":"加载阶段"}],"type":5},{"content":"1、验证是否可以画\n2、准备进行画画，挤颜料\n3、画师的画笔蘸颜料","date":"2022-04-01 16:57:51","docid":0,"fillcolor":"ffffed99","folded":true,"id":478,"markups":[{"content":"画师比对大纲是否正确\n也就是可不可以画\n\n1、保证字节流符合虚拟机要求，并且正确\n2、使用4种验证：\n   （文件格式验证，元数据验证，字节码验证，符号引用验证）\n\n（二进制字节流必须以CAFE BABE开头）","date":"2022-04-01 17:00:06","docid":0,"fillcolor":"ffffed99","id":480,"originaltext":"验证(Verify)","page":22,"textblocks":[{"first":[75.52161407470703,543.2948608398438,12.193168640136719,16.5],"last":[140.0844268798828,543.2948608398438,4.13348388671875,16.5],"length":10,"rects":[[75.52161407470703,543.2948608398438,68.69629669189453,16.5]],"start":349,"text":"验证(Verify)"}],"type":5},{"content":"1、为类变量分配内存赋初始值\n2、不包括使用final修饰的类变量\n3、类变量放到方法区\n（实例变量不会分配内存初始化，随着对象放到Java堆当中）","date":"2022-04-01 17:00:11","docid":0,"fillcolor":"ffffed99","id":481,"originaltext":"准备(Prepare)","page":23,"textblocks":[{"first":[75.52161407470703,297.18084716796875,12.193168640136719,16.5],"last":[152.26539611816406,297.18084716796875,4.13348388671875,16.5],"length":11,"rects":[[75.52161407470703,297.18084716796875,80.87726593017578,16.5]],"start":0,"text":"准备(Prepare)"}],"type":5},{"content":"1、对常量池中的符号引用转化为直接引用","date":"2022-04-01 17:00:16","docid":0,"fillcolor":"ffffed99","id":482,"originaltext":"解析(Resolve)","page":23,"textblocks":[{"first":[75.52161407470703,634.8870849609375,12.193168640136719,15.5],"last":[150.765625,634.8870849609375,4.13348388671875,15.5],"length":11,"rects":[[75.52161407470703,634.8870849609375,79.37749481201172,15.5]],"start":216,"text":"解析(Resolve)"}],"type":5}],"originaltext":"链接阶段","page":22,"textblocks":[{"first":[75.52161407470703,467.710205078125,14.631797790527344,17.5],"last":[119.41700744628906,467.710205078125,14.631790161132812,17.5],"length":4,"rects":[[75.52161407470703,467.710205078125,58.527183532714844,17.5]],"start":316,"text":"链接阶段"}],"type":5},{"content":"全部准备好了，开始画画","date":"2022-04-01 16:58:59","docid":0,"fillcolor":"ffffed99","folded":true,"id":479,"markups":[{"date":"2022-04-01 17:10:46","docid":0,"fillcolor":"ffffed99","id":483,"originaltext":"类的初始化时机","page":24,"textblocks":[{"first":[75.52161407470703,361.66015625,12.193168640136719,14.5],"last":[148.68060302734375,361.66015625,12.193161010742188,14.5],"length":7,"rects":[[75.52161407470703,361.66015625,85.3521499633789,14.5]],"start":42,"text":"类的初始化时机"}],"type":5},{"content":"1、会自动收集所有类变量的赋值操作静态成员变成一个<clinit>()方法\n2、按静态成员出现的顺序执行语句\n3、存在父类就像执行父类的<clinit>()方法\n4、<clinit>()方法使用了同步锁","date":"2022-04-01 17:11:07","docid":0,"fillcolor":"ffffed99","id":484,"originaltext":"clinit()","page":24,"textblocks":[{"first":[75.52161407470703,580.0621948242188,7.520744323730469,16.5],"last":[117.35392761230469,580.0621948242188,4.960182189941406,16.5],"length":8,"rects":[[75.52161407470703,580.0621948242188,46.79249572753906,16.5]],"start":386,"text":"clinit()"}],"type":5}],"originaltext":"初始化阶段","page":24,"textblocks":[{"first":[75.52161407470703,332.64794921875,14.631797790527344,17.5],"last":[134.04879760742188,332.64794921875,14.631805419921875,17.5],"length":5,"rects":[[75.52161407470703,332.64794921875,73.15898895263672,17.5]],"start":35,"text":"初始化阶段"}],"type":5}],"originaltext":"类加载过程","page":20,"textblocks":[{"first":[75.52161407470703,744.84033203125,17.07042694091797,19.5],"last":[143.80332946777344,744.84033203125,17.0704345703125,19.5],"length":5,"rects":[[75.52161407470703,744.84033203125,85.3521499633789,19.5]],"start":260,"text":"类加载过程"}],"type":5},{"date":"2022-04-01 17:11:18","docid":0,"fillcolor":"ffffed99","folded":false,"id":485,"markups":[{"content":"只支持两类加载器：\n1、引导类加载器：Bootstrap ClassLoader\n2、自定义类加载器：User-Defined ClassLoader\n\n另外还有\n扩展类加载器\n和\n系统类加载器，\n但是他们都继承于ClassLoader，所以定义在自定义类加载器中\n\n并且Bootstrap ClassLoader由C语言编写的加载器，其他都有Java编写的加载器\n\n系统类加载器全局唯一，引导类加载器获取不到","date":"2022-04-01 17:19:05","docid":0,"fillcolor":"ffffed99","folded":true,"id":486,"markups":[{"date":"2022-04-01 17:20:20","docid":0,"fillcolor":"ffffed99","id":487,"originaltext":"将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器","page":28,"textblocks":[{"first":[234.59552001953125,720.0751953125,9.754531860351562,12.5],"last":[107.78660583496094,735.0830078125,9.754531860351562,12.5],"length":37,"rects":[[234.59552001953125,720.0751953125,282.943359375,12.5],[98.03207397460938,735.0830078125,19.509063720703125,12.5]],"start":356,"text":"将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加\n载器"}],"type":5}],"originaltext":"概述","page":28,"textblocks":[{"first":[75.52161407470703,617.7802734375,14.631797790527344,17.5],"last":[90.15341186523438,617.7802734375,14.631797790527344,17.5],"length":2,"rects":[[75.52161407470703,617.7802734375,29.263595581054688,17.5]],"start":196,"text":"概述"}],"type":5}],"originaltext":"类加载器的分类","page":28,"textblocks":[{"first":[75.52161407470703,585.765625,17.07042694091797,19.5],"last":[177.94419860839844,585.765625,17.0704345703125,19.5],"length":7,"rects":[[75.52161407470703,585.765625,119.4930191040039,19.5]],"start":187,"text":"类加载器的分类"}],"type":5},{"date":"2022-04-01 17:32:25","docid":0,"fillcolor":"ffffed99","folded":false,"id":488,"markups":[{"content":"引导类加载器：\n1、由C/C++实现\n2、获取不到，被嵌套在JVM内部\n3、用来加载Java核心类库\n4、加载扩展类加载器和系统加载器","date":"2022-04-01 17:32:37","docid":0,"fillcolor":"ffffed99","id":489,"originaltext":"启动类加载器","page":31,"textblocks":[{"first":[75.52161407470703,218.34375,12.193168640136719,15.5],"last":[136.48744201660156,218.34375,12.193161010742188,15.5],"length":6,"rects":[[75.52161407470703,218.34375,73.15898895263672,15.5]],"start":159,"text":"启动类加载器"}],"type":5},{"content":"扩展类加载器：\n1、由Java实现\n2、由引导加载器进行加载\n3、加载核心包之外的jar包","date":"2022-04-01 17:32:40","docid":0,"fillcolor":"ffffed99","id":490,"originaltext":"扩展类加载器","page":31,"textblocks":[{"first":[75.52161407470703,390.173828125,12.193168640136719,15.5],"last":[136.48744201660156,390.173828125,12.193161010742188,15.5],"length":6,"rects":[[75.52161407470703,390.173828125,73.15898895263672,15.5]],"start":452,"text":"扩展类加载器"}],"type":5},{"content":"系统类加载器：\n1、由Java实现\n2、加载我们写的Java引用","date":"2022-04-01 17:32:54","docid":0,"fillcolor":"ffffed99","id":491,"originaltext":"系统类加载器","page":31,"textblocks":[{"first":[75.52161407470703,546.24609375,12.193168640136719,15.5],"last":[136.48744201660156,546.24609375,12.193161010742188,15.5],"length":6,"rects":[[75.52161407470703,546.24609375,73.15898895263672,15.5]],"start":677,"text":"系统类加载器"}],"type":5}],"originaltext":"虚拟机自带的加载器","page":31,"textblocks":[{"first":[75.52161407470703,189.3310546875,14.631797790527344,17.5],"last":[192.5760040283203,189.3310546875,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,189.3310546875,131.6861801147461,17.5]],"start":148,"text":"虚拟机自带的加载器"}],"type":5},{"date":"2022-04-01 17:33:01","docid":0,"fillcolor":"ffffed99","folded":true,"id":492,"markups":[{"date":"2022-04-01 17:39:55","docid":0,"fillcolor":"ffffed99","folded":true,"id":493,"markups":[{"content":"框架要画的类名字都一样，这时候怕只有一个画家画错，因为同一个名字只能存在一个，那么就自己派遣一个画家去画我自己的类","date":"2022-04-01 17:41:07","docid":0,"fillcolor":"ffffed99","id":494,"originaltext":"1. 隔离加载类","page":32,"textblocks":[{"first":[87.52719116210938,696.814453125,5.57958984375,12.5],"last":[137.05020141601562,696.814453125,9.754531860351562,12.5],"length":8,"rects":[[87.52719116210938,696.814453125,59.27754211425781,12.5]],"start":121,"text":"1. 隔离加载类"}],"type":5},{"date":"2022-04-01 17:41:11","docid":0,"fillcolor":"ffffed99","id":495,"originaltext":"2. 修改类加载的方式","page":32,"textblocks":[{"first":[87.52719116210938,741.8349609375,5.57958984375,12.5],"last":[166.3137969970703,741.8349609375,9.754531860351562,12.5],"length":11,"rects":[[87.52719116210938,741.8349609375,88.5411376953125,12.5]],"start":228,"text":"2. 修改类加载的方式"}],"type":5},{"date":"2022-04-01 17:41:16","docid":0,"fillcolor":"ffffed99","id":496,"originaltext":"3. 扩展加载源","page":32,"textblocks":[{"first":[87.52719116210938,756.8427734375,5.57958984375,12.5],"last":[137.05020141601562,756.8427734375,9.754531860351562,12.5],"length":8,"rects":[[87.52719116210938,756.8427734375,59.27754211425781,12.5]],"start":240,"text":"3. 扩展加载源"}],"type":5},{"date":"2022-04-01 17:41:21","docid":0,"fillcolor":"ffffed99","id":497,"originaltext":"4. 防止源码泄漏","page":32,"textblocks":[{"first":[87.52719116210938,771.849609375,5.57958984375,12.5],"last":[146.8047332763672,771.849609375,9.754531860351562,12.5],"length":9,"rects":[[87.52719116210938,771.849609375,69.03207397460938,12.5]],"start":275,"text":"4. 防止源码泄漏"}],"type":5}],"originaltext":"什么时候需要自定义类加载器？","page":32,"textblocks":[{"first":[75.52161407470703,631.78515625,12.193168640136719,14.5],"last":[234.0327606201172,631.78515625,12.193161010742188,14.5],"length":14,"rects":[[75.52161407470703,631.78515625,170.70430755615234,14.5]],"start":20,"text":"什么时候需要自定义类加载器？"}],"type":5},{"content":"1、继承classLoader即可\n2、重写findclass()方法即可\n3、也可以更加简便继承URIClassLoader","date":"2022-04-01 17:44:17","docid":0,"fillcolor":"ffffed99","id":498,"originaltext":"如何自定义类加载器？","page":33,"textblocks":[{"first":[75.52161407470703,29.255859375,12.193168640136719,15.5],"last":[185.26010131835938,29.255859375,12.193161010742188,15.5],"length":10,"rects":[[75.52161407470703,29.255859375,121.93164825439453,15.5]],"start":0,"text":"如何自定义类加载器？"}],"type":5},{"date":"2022-04-01 17:46:24","docid":0,"fillcolor":"ffffed99","folded":true,"id":499,"markups":[{"content":"获取的加载器是系统类加载器","date":"2022-04-01 17:47:05","docid":0,"fillcolor":"ffffed99","id":500,"originaltext":"获取ClassLoader途径","page":34,"textblocks":[{"first":[75.52161407470703,659.6988525390625,12.193168640136719,14.5],"last":[185.33749389648438,659.6988525390625,12.193161010742188,14.5],"length":15,"rects":[[75.52161407470703,659.6988525390625,122.00904083251953,14.5]],"start":123,"text":"获取ClassLoader途径"}],"type":5}],"originaltext":"关于ClassLoader","page":34,"textblocks":[{"first":[75.52161407470703,34.2578125,14.631797790527344,11.5],"last":[186.02096557617188,34.2578125,6.6428375244140625,11.5],"length":13,"rects":[[75.52161407470703,34.2578125,117.1421890258789,11.5]],"start":0,"text":"关于ClassLoader"}],"type":5}],"originaltext":"用户自定义类加载器","page":32,"textblocks":[{"first":[75.52161407470703,602.7724609375,14.631797790527344,17.5],"last":[192.5760040283203,602.7724609375,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,602.7724609375,131.6861801147461,17.5]],"start":9,"text":"用户自定义类加载器"}],"type":5},{"content":"当使用的类和Java底层的类全限定类名都一样，调用用的时候还是回去调用Java的类，运用了双亲委派机制\n用来放置伪造jar包","date":"2022-04-01 17:48:24","docid":0,"fillcolor":"ffffed99","folded":true,"id":501,"markups":[{"content":"按需加载：使用的时候才会去加载对应的类\n双亲委派：\n1、当一个类加载器收到需要加载类的时候，会将请求委托给父类，父类又会委托给自己的父类，直到达到顶层。\n2、当顶层的自己无法完成加载就会让自己的子类来加载类，再一级一级传递下去\n3、如果都无法加载，就会抛出异常","date":"2022-04-01 17:49:29","docid":0,"fillcolor":"ffffed99","id":502,"originaltext":"双亲委派机制原理","page":36,"textblocks":[{"first":[75.52161407470703,31.2568359375,14.631797790527344,16.5],"last":[177.94419860839844,31.2568359375,14.631790161132812,16.5],"length":8,"rects":[[75.52161407470703,31.2568359375,117.05437469482422,16.5]],"start":0,"text":"双亲委派机制原理"}],"type":5},{"date":"2022-04-01 17:49:39","docid":0,"fillcolor":"ffffed99","id":503,"originaltext":"双亲委派机制代码演示","page":36,"textblocks":[{"first":[75.52161407470703,654.2468872070312,14.631797790527344,18.5],"last":[207.20779418945312,654.2468872070312,14.631805419921875,18.5],"length":10,"rects":[[75.52161407470703,654.2468872070312,146.31798553466797,18.5]],"start":379,"text":"双亲委派机制代码演示"}],"type":5},{"date":"2022-04-01 19:59:00","docid":0,"fillcolor":"ffffed99","id":504,"markups":[{"date":"2022-04-01 20:00:18","docid":0,"fillcolor":"ffffed99","id":505,"originaltext":"1. 避免类的重复加载","page":39,"textblocks":[{"first":[87.52719116210938,539.994140625,5.57958984375,12.5],"last":[166.3137969970703,539.994140625,9.754531860351562,12.5],"length":11,"rects":[[87.52719116210938,539.994140625,88.5411376953125,12.5]],"start":197,"text":"1. 避免类的重复加载"}],"type":5},{"date":"2022-04-01 20:00:23","docid":0,"fillcolor":"ffffed99","id":506,"originaltext":"2. 保护程序安全，防止核心API被随意篡改","page":39,"textblocks":[{"first":[87.52719116210938,558.501953125,5.57958984375,13.5],"last":[259.1152038574219,558.501953125,9.754547119140625,13.5],"length":22,"rects":[[87.52719116210938,558.501953125,181.34255981445312,13.5]],"start":209,"text":"2. 保护程序安全，防止核心API被随意篡改"}],"type":5}],"originaltext":"双亲委派机制优势","page":39,"textblocks":[{"first":[75.52161407470703,464.7109375,14.631797790527344,17.5],"last":[177.94419860839844,464.7109375,14.631790161132812,17.5],"length":8,"rects":[[75.52161407470703,464.7109375,117.05437469482422,17.5]],"start":163,"text":"双亲委派机制优势"}],"type":5}],"originaltext":"双亲委派机制","page":35,"textblocks":[{"first":[75.52161407470703,744.83984375,17.07042694091797,19.5],"last":[160.87376403808594,744.83984375,17.0704345703125,19.5],"length":6,"rects":[[75.52161407470703,744.83984375,102.4225845336914,19.5]],"start":10,"text":"双亲委派机制"}],"type":5},{"content":"因为双亲委派一路往上传递，获取到到引导类加载器，返回的是引导类加载器的类，这样就能保证加载的包一定是最底层的，而不是随便写的同名类","date":"2022-04-01 20:00:43","docid":0,"fillcolor":"ffffed99","id":507,"originaltext":"沙箱安全机制","page":39,"textblocks":[{"first":[75.52161407470703,638.291015625,17.07042694091797,20.5],"last":[160.87376403808594,638.291015625,17.0704345703125,20.5],"length":6,"rects":[[75.52161407470703,638.291015625,102.4225845336914,20.5]],"start":313,"text":"沙箱安全机制"}],"type":5},{"date":"2022-04-01 20:02:03","docid":0,"fillcolor":"ffffed99","folded":true,"id":508,"markups":[{"date":"2022-04-01 20:10:57","docid":0,"fillcolor":"ffffed99","folded":true,"id":509,"markups":[{"date":"2022-04-01 20:11:52","docid":0,"fillcolor":"ffffed99","id":510,"originaltext":"1. 类的完整类名必须一致，包括包名","page":40,"textblocks":[{"first":[87.52719116210938,82.279296875,5.57958984375,13.5],"last":[234.59552001953125,82.279296875,9.754531860351562,13.5],"length":18,"rects":[[87.52719116210938,82.279296875,156.82286071777344,13.5]],"start":53,"text":"1. 类的完整类名必须一致，包括包名"}],"type":5},{"date":"2022-04-01 20:11:57","docid":0,"fillcolor":"ffffed99","id":511,"originaltext":"2. 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同","page":40,"textblocks":[{"first":[87.52719116210938,96.98710632324219,5.57958984375,13.5],"last":[371.2828063964844,96.98710632324219,9.754547119140625,13.5],"length":42,"rects":[[87.52719116210938,96.98710632324219,293.5101623535156,13.5]],"start":72,"text":"2. 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同"}],"type":5}],"originaltext":"如何判断两个class对象是否相同？","page":40,"textblocks":[{"first":[75.52161407470703,30.7578125,14.631797790527344,17.5],"last":[286.47528076171875,30.7578125,14.631805419921875,17.5],"length":18,"rects":[[75.52161407470703,30.7578125,225.5854721069336,17.5]],"start":0,"text":"如何判断两个class对象是否相同？"}],"type":5},{"content":"哪个类加载器加载的类，方法区中的类有对引用","date":"2022-04-01 20:12:23","docid":0,"fillcolor":"ffffed99","folded":true,"id":512,"markups":[{"date":"2022-04-01 20:12:31","docid":0,"fillcolor":"ffffed99","id":513,"originaltext":"1. JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的","page":40,"textblocks":[{"first":[87.52719116210938,205.0378875732422,5.57958984375,13.5],"last":[398.131591796875,205.0378875732422,9.7545166015625,13.5],"length":36,"rects":[[87.52719116210938,205.0378875732422,320.3589172363281,13.5]],"start":224,"text":"1. JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的"}],"type":5},{"date":"2022-04-01 20:12:40","docid":0,"fillcolor":"ffffed99","id":514,"originaltext":"2. 如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中","page":40,"textblocks":[{"first":[87.52719116210938,220.34375,5.57958984375,13.5],"last":[176.06832885742188,235.3515625,9.754531860351562,13.5],"length":57,"rects":[[87.52719116210938,220.34375,429.2067565917969,13.5],[98.03207397460938,235.3515625,87.79078674316406,13.5]],"start":261,"text":"2. 如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一\n部分保存在方法区中"}],"type":5},{"date":"2022-04-01 20:12:55","docid":0,"fillcolor":"ffffed99","id":515,"originaltext":"3. 当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（后面讲）","page":40,"textblocks":[{"first":[87.52719116210938,250.0574188232422,5.57958984375,13.500015258789062],"last":[107.78660583496094,266.365234375,9.754531860351562,12.5],"length":50,"rects":[[87.52719116210938,250.0574188232422,427.6587829589844,13.500015258789062],[98.03207397460938,266.365234375,19.509063720703125,12.5]],"start":319,"text":"3. 当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（后面\n讲）"}],"type":5}],"originaltext":"对类加载器的引用","page":40,"textblocks":[{"first":[75.52161407470703,175.826171875,14.631797790527344,17.5],"last":[177.94419860839844,175.826171875,14.631790161132812,17.5],"length":8,"rects":[[75.52161407470703,175.826171875,117.05437469482422,17.5]],"start":214,"text":"对类加载器的引用"}],"type":5}],"originaltext":"其他","page":39,"textblocks":[{"first":[75.52161407470703,783.609375,17.07042694091797,20.5],"last":[92.592041015625,783.609375,17.0704345703125,20.5],"length":2,"rects":[[75.52161407470703,783.609375,34.14086151123047,20.5]],"start":505,"text":"其他"}],"type":5}],"originaltext":"第2章-类加载子系统","page":17,"textblocks":[{"first":[75.52161407470703,85.88591003417969,21.94770050048828,25.5],"last":[248.7455291748047,85.88591003417969,21.947708129882812,25.5],"length":10,"rects":[[75.52161407470703,85.88591003417969,195.17162322998047,25.5]],"start":2,"text":"第2章-类加载子系统"}],"type":5},{"content":"记住：\n1、运行时数据区存在哪里\n2、运行时数据区里面的内存结构\n3、gc垃圾回收器和OOM影响的地方\n4、运行时数据区的Runtime实例\n5、程序计数器的作用（多线程）\n6、程序计数器是否会收到gc和OOM的影响\n7、程序计数器线程是否私有？为什么？\n8、程序计数器怎么工作的\n9、程序计数器的速度\n10、本地方法接口是什么\n11、为什么要用本地方法接口\n12、本地方法接口与谁进行交互\n13、本地方法接口怎么进行交互\n14、是否受到gc或者OOM的影响\n15、线程是否私有，为什么私有\n16、本地方法接口抛出异常","date":"2022-04-01 20:16:24","docid":0,"fillcolor":"ffffed99","folded":false,"id":516,"markups":[{"date":"2022-04-01 20:17:53","folded":true,"id":519,"linecolor":"ff59c6ff","markups":[{"content":"经过上一个类加载器classloader的处理\n一个类已经被加载到方法区中\n\n厨师执行引擎开始使用方法区的材料开始做菜也就是执行","date":"2022-04-01 20:17:25","docid":0,"fillcolor":"ffffed99","id":517,"originaltext":"前言","page":41,"textblocks":[{"first":[75.52161407470703,166.82215881347656,17.07042694091797,20.5],"last":[92.592041015625,166.82215881347656,17.0704345703125,20.5],"length":2,"rects":[[75.52161407470703,166.82215881347656,34.14086151123047,20.5]],"start":57,"text":"前言"}],"type":5},{"date":"2022-04-01 20:18:48","docid":0,"fillcolor":"ffffed99","folded":true,"id":520,"markups":[{"content":"1、不同的JVM对于内存的划分方式和管理机制存在着部分差异\n2、内存相当于磁盘和CPU的桥梁，缓冲空间","date":"2022-04-01 20:51:25","docid":0,"fillcolor":"ffffed99","id":522,"originaltext":"运行时数据区与内存","page":42,"textblocks":[{"first":[75.52161407470703,431.44415283203125,14.631797790527344,17.5],"last":[192.5760040283203,431.44415283203125,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,431.44415283203125,131.6861801147461,17.5]],"start":12,"text":"运行时数据区与内存"}],"type":5},{"content":"1、栈、程序计数器线程私有\n2、堆、方法区线程共享\n\n内存优化：针对于堆、方法区，\n（gc垃圾回收期大部分工作与堆）\n\n内存溢出：除了程序计数器","date":"2022-04-01 20:52:29","docid":0,"fillcolor":"ffffed99","id":523,"originaltext":"线程的内存空间","page":43,"textblocks":[{"first":[75.52161407470703,55.0189208984375,14.631797790527344,17.5],"last":[163.31240844726562,55.0189208984375,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,55.0189208984375,102.42259979248047,17.5]],"start":2,"text":"线程的内存空间"}],"type":5},{"content":"运行环境，每个Java程序只有一个","date":"2022-04-01 20:57:44","docid":0,"fillcolor":"ffffed99","folded":true,"id":524,"markups":[{"date":"2022-04-01 20:58:10","docid":0,"fillcolor":"ffffed99","id":525,"originaltext":"每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。","page":43,"textblocks":[{"first":[75.52161407470703,576.509765625,9.754531860351562,13.5],"last":[506.77276611328125,576.509765625,9.7545166015625,13.5],"length":49,"rects":[[75.52161407470703,576.509765625,441.0056686401367,13.5]],"start":212,"text":"每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。"}],"type":5}],"originaltext":"Runtime类","page":43,"textblocks":[{"first":[75.52161407470703,551.998046875,9.656990051269531,11.5],"last":[138.24258422851562,551.998046875,14.631805419921875,11.5],"length":8,"rects":[[75.52161407470703,551.998046875,77.35277557373047,11.5]],"start":202,"text":"Runtime类"}],"type":5}],"originaltext":"运行时数据区结构","page":42,"textblocks":[{"first":[75.52161407470703,399.43023681640625,17.07042694091797,20.5],"last":[195.01463317871094,399.43023681640625,17.0704345703125,20.5],"length":8,"rects":[[75.52161407470703,399.43023681640625,136.5634536743164,20.5]],"start":2,"text":"运行时数据区结构"}],"type":5},{"date":"2022-04-01 20:18:59","docid":0,"fillcolor":"ffffed99","folded":true,"id":521,"markups":[{"content":"1、Java虚拟机支持多线程\n2、Java的线程与操作系统的线程一一对应\n3、当Java线程装备好后（栈和程序计数器装备好后），本地线程就会创建然后执行run方法","date":"2022-04-01 20:59:53","docid":0,"fillcolor":"ffffed99","id":526,"originaltext":"JVM 线程","page":44,"textblocks":[{"first":[75.52161407470703,60.72172927856445,4.8431243896484375,18.499996185302734],"last":[122.10331726074219,60.72172927856445,14.631790161132812,18.499996185302734],"length":6,"rects":[[75.52161407470703,60.72172927856445,61.21349334716797,18.499996185302734]],"start":4,"text":"JVM 线程"}],"type":5},{"date":"2022-04-01 21:03:14","docid":0,"fillcolor":"ffffed99","folded":true,"id":527,"markups":[{"date":"2022-04-01 21:03:56","docid":0,"fillcolor":"ffffed99","id":528,"originaltext":"1. 虚拟机线程","page":44,"textblocks":[{"first":[87.52719116210938,389.922607421875,5.57958984375,12.5],"last":[137.05020141601562,389.922607421875,9.754531860351562,12.5],"length":8,"rects":[[87.52719116210938,389.922607421875,59.27754211425781,12.5]],"start":393,"text":"1. 虚拟机线程"}],"type":5},{"date":"2022-04-01 21:03:58","docid":0,"fillcolor":"ffffed99","id":529,"originaltext":"2. 周期任务线程","page":44,"textblocks":[{"first":[87.52719116210938,434.943603515625,5.57958984375,12.5],"last":[146.8047332763672,434.943603515625,9.754531860351562,12.5],"length":9,"rects":[[87.52719116210938,434.943603515625,69.03207397460938,12.5]],"start":519,"text":"2. 周期任务线程"}],"type":5},{"date":"2022-04-01 21:04:01","docid":0,"fillcolor":"ffffed99","id":530,"originaltext":"3. GC线程","page":44,"textblocks":[{"first":[87.52719116210938,464.95751953125,5.57958984375,12.5],"last":[121.06572723388672,464.95751953125,9.754524230957031,12.5],"length":7,"rects":[[87.52719116210938,464.95751953125,43.293060302734375,12.5]],"start":568,"text":"3. GC线程"}],"type":5},{"date":"2022-04-01 21:04:03","docid":0,"fillcolor":"ffffed99","id":531,"originaltext":"4. 编译线程","page":44,"textblocks":[{"first":[87.52719116210938,479.96435546875,5.57958984375,12.5],"last":[127.29566955566406,479.96435546875,9.754531860351562,12.5],"length":7,"rects":[[87.52719116210938,479.96435546875,49.52301025390625,12.5]],"start":603,"text":"4. 编译线程"}],"type":5},{"date":"2022-04-01 21:04:06","docid":0,"fillcolor":"ffffed99","id":532,"originaltext":"5. 信号调度线程","page":44,"textblocks":[{"first":[87.52719116210938,494.971435546875,5.57958984375,12.5],"last":[146.8047332763672,494.971435546875,9.754531860351562,12.5],"length":9,"rects":[[87.52719116210938,494.971435546875,69.03207397460938,12.5]],"start":633,"text":"5. 信号调度线程"}],"type":5}],"originaltext":"JVM 系统线程","page":44,"textblocks":[{"first":[75.52161407470703,269.8681640625,4.8431243896484375,17.5],"last":[151.36691284179688,269.8681640625,14.631805419921875,17.5],"length":8,"rects":[[75.52161407470703,269.8681640625,90.47710418701172,17.5]],"start":233,"text":"JVM 系统线程"}],"type":5}],"originaltext":"线程","page":44,"textblocks":[{"first":[75.52161407470703,29.007568359375,17.07042694091797,19.5],"last":[92.592041015625,29.007568359375,17.0704345703125,19.5],"length":2,"rects":[[75.52161407470703,29.007568359375,34.14086151123047,19.5]],"start":0,"text":"线程"}],"type":5}],"page":-1,"title":"概述","type":7},{"content":"1、是jvm对底层物理PC寄存器的模拟\n2、记录当前方法（活动栈帧）下一条指令运行的地址\n3、不存OOM和 GC，并且空间很小\n3、线程私有\n4、当调用的是C程序的时候，程序计数器为undefned值\n5、由执行引擎来查看，然后取对应地址的指令","date":"2022-04-01 20:17:39","docid":0,"fillcolor":"ffffed99","folded":false,"id":518,"markups":[{"content":"1、是jvm对底层物理PC寄存器的模拟\n2、记录当前方法（活动栈帧）下一条指令运行的地址\n3、不存OOM和 GC，并且空间很小\n3、线程私有\n4、当调用的是C程序的时候，程序计数器为undefned值","date":"2022-04-02 08:53:31","docid":0,"fillcolor":"ffffed99","id":533,"originaltext":"PC寄存器介绍","page":44,"textblocks":[{"first":[75.52161407470703,578.3629150390625,10.720230102539062,20.5],"last":[165.39976501464844,578.3629150390625,17.0704345703125,20.5],"length":7,"rects":[[75.52161407470703,578.3629150390625,106.9485855102539,20.5]],"start":693,"text":"PC寄存器介绍"}],"type":5},{"date":"2022-04-02 08:56:44","docid":0,"fillcolor":"ffffed99","id":534,"originaltext":"PC寄存器的作用","page":45,"textblocks":[{"first":[75.52161407470703,256.36328125,10.720230102539062,19.5],"last":[182.47019958496094,256.36328125,17.0704345703125,19.5],"length":8,"rects":[[75.52161407470703,256.36328125,124.0190200805664,19.5]],"start":446,"text":"PC寄存器的作用"}],"type":5},{"date":"2022-04-02 09:07:26","docid":0,"fillcolor":"ffffed99","folded":true,"id":535,"markups":[{"content":"1、\n因为Java的多线程是微观串行，宏观并行所以在支持多线程的情况下，需要记录原有的程序执行位置\n2、\n正常执行执行引擎需要知道下一条指令的位置，由程序计数器给出","date":"2022-04-02 09:07:42","docid":0,"fillcolor":"ffffed99","id":536,"originaltext":"使用PC寄存器存储字节码指令地址有什么用呢？","page":48,"textblocks":[{"first":[75.52161407470703,570.5068359375,9.754531860351562,13.5],"last":[273.19854736328125,570.5068359375,9.7545166015625,13.5],"length":22,"rects":[[75.52161407470703,570.5068359375,207.43144989013672,13.5]],"start":72,"text":"使用PC寄存器存储字节码指令地址有什么用呢？"}],"type":5},{"content":"因为Java的多线程是微观串行，宏观并行\n所以必然会有一个线程停下，这时候需要属于这个线程的程序计数器来记录它的执行位置\n如果是线程共享，那么就失去了那个线程的执行位置","date":"2022-04-02 09:07:57","docid":0,"fillcolor":"ffffed99","id":537,"originaltext":"PC寄存器为什么被设定为私有的？","page":49,"textblocks":[{"first":[75.52161407470703,354.40673828125,6.125846862792969,13.5],"last":[214.67135620117188,354.40673828125,9.754531860351562,13.5],"length":16,"rects":[[75.52161407470703,354.40673828125,148.9042739868164,13.5]],"start":2,"text":"PC寄存器为什么被设定为私有的？"}],"type":5}],"originaltext":"两个面试题","page":48,"textblocks":[{"first":[75.52161407470703,539.9951171875,17.07042694091797,19.5],"last":[143.80332946777344,539.9951171875,17.0704345703125,19.5],"length":5,"rects":[[75.52161407470703,539.9951171875,85.3521499633789,19.5]],"start":65,"text":"两个面试题"}],"type":5},{"content":"并行串行\n并发：微观串行，宏观并行","date":"2022-04-02 09:13:41","docid":0,"fillcolor":"ffffed99","id":538,"originaltext":"CPU 时间片","page":49,"textblocks":[{"first":[75.52161407470703,552.75146484375,10.873863220214844,19.5],"last":[148.59605407714844,552.75146484375,17.0704345703125,19.5],"length":7,"rects":[[75.52161407470703,552.75146484375,90.1448745727539,19.5]],"start":354,"text":"CPU 时间片"}],"type":5}],"originaltext":"程序计数器(PC寄存器)","page":44,"textblocks":[{"first":[75.52161407470703,541.997802734375,21.94770050048828,24.5],"last":[286.307373046875,541.997802734375,7.440277099609375,24.5],"length":12,"rects":[[75.52161407470703,541.997802734375,218.22603607177734,24.5]],"start":679,"text":"程序计数器(PC寄存器)"}],"type":5},{"content":"本地方法栈：\n1、用来存储本地方法调用\n2、线程私有\n3、可拓展内存\n4、存在OOM问题\n5、当调用本地方法的时候，可以做到很多事\n\n做法：\n1、在本地方法栈中登记\n2、执行引擎根据栈执行方法的时候，去本地方法接口中加载本地方法库\n\n\n\n本地方法：\n1、用来存放非Java代码的接口\n（一个natice方法）\n2、可以看成原子操作\n（被作为操作硬件或者系统的方法）","date":"2022-04-02 09:15:49","docid":0,"fillcolor":"ffffed99","folded":true,"id":539,"markups":[{"content":"1、用来存放非Java代码的接口\n（一个natice方法）\n2、可以看成原子操作\n（被作为操作硬件或者系统的方法）","date":"2022-04-02 09:16:15","docid":0,"fillcolor":"ffffed99","id":540,"originaltext":"本地方法","page":50,"textblocks":[{"first":[75.52161407470703,29.0078125,17.07042694091797,19.5],"last":[126.73291015625,29.0078125,17.0704345703125,19.5],"length":4,"rects":[[75.52161407470703,29.0078125,68.28173065185547,19.5]],"start":0,"text":"本地方法"}],"type":5},{"content":"可以看成原子操作（非常在意时间）","date":"2022-04-02 09:18:40","docid":0,"fillcolor":"ffffed99","folded":true,"id":541,"markups":[{"content":"很多时候被作为操作硬件的方法","date":"2022-04-02 09:19:09","docid":0,"fillcolor":"ffffed99","id":542,"originaltext":"与Java环境外交互","page":51,"textblocks":[{"first":[75.52161407470703,147.7620086669922,14.631797790527344,18.5],"last":[179.5231170654297,147.7620086669922,14.631790161132812,18.5],"length":10,"rects":[[75.52161407470703,147.7620086669922,118.63329315185547,18.5]],"start":85,"text":"与Java环境外交互"}],"type":5},{"date":"2022-04-02 09:19:50","docid":0,"fillcolor":"ffffed99","id":543,"originaltext":"与操作系统的交互","page":51,"textblocks":[{"first":[75.52161407470703,256.1123046875,14.631797790527344,17.5],"last":[177.94419860839844,256.1123046875,14.631790161132812,17.5],"length":8,"rects":[[75.52161407470703,256.1123046875,117.05437469482422,17.5]],"start":235,"text":"与操作系统的交互"}],"type":5},{"date":"2022-04-02 09:21:36","docid":0,"fillcolor":"ffffed99","id":544,"originaltext":"本地方法的现状","page":51,"textblocks":[{"first":[75.52161407470703,590.5185546875,14.631797790527344,17.5],"last":[163.31240844726562,590.5185546875,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,590.5185546875,102.42259979248047,17.5]],"start":810,"text":"本地方法的现状"}],"type":5}],"originaltext":"为什么要使用 Native Method？","page":51,"textblocks":[{"first":[75.52161407470703,53.869529724121094,17.07042694091797,20.5],"last":[309.5982360839844,53.869529724121094,17.0704345703125,20.5],"length":21,"rects":[[75.52161407470703,53.869529724121094,251.14705657958984,20.5]],"start":2,"text":"为什么要使用 Native Method？"}],"type":5},{"content":"1、用来存储本地方法调用\n2、线程私有\n3、可拓展内存\n4、存在OOM问题\n5、当调用本地方法的时候，可以做到很多事\n\n做法：\n1、在本地方法栈中登记\n2、执行引擎根据栈执行方法的时候，去本地方法接口中加载本地方法库","date":"2022-04-02 09:22:02","docid":0,"fillcolor":"ffffed99","id":545,"originaltext":"本地方法栈","page":51,"textblocks":[{"first":[75.52161407470703,698.0703125,21.94770050048828,24.5],"last":[163.31240844726562,698.0703125,21.94769287109375,24.5],"length":5,"rects":[[75.52161407470703,698.0703125,109.73848724365234,24.5]],"start":951,"text":"本地方法栈"}],"type":5}],"originaltext":"本地方法接口","page":49,"textblocks":[{"first":[75.52161407470703,775.857421875,21.94770050048828,25.5],"last":[185.26010131835938,775.857421875,21.94769287109375,25.5],"length":6,"rects":[[75.52161407470703,775.857421875,131.6861801147461,25.5]],"start":513,"text":"本地方法接口"}],"type":5}],"originaltext":"运行时数据区概述及线程","page":41,"textblocks":[{"first":[75.52161407470703,130.5571746826172,21.94770050048828,24.5],"last":[294.99859619140625,130.5571746826172,21.94769287109375,24.5],"length":11,"rects":[[75.52161407470703,130.5571746826172,241.42467498779297,24.5]],"start":44,"text":"运行时数据区概述及线程"}],"title":"第3章-运行时数据区概述及线程","type":5},{"content":"记住：\n1、虚拟机栈是什么\n2、与堆进行比较\n3、虚拟机栈的作用\n4、虚拟机栈的特点","date":"2022-04-02 09:22:43","docid":0,"fillcolor":"ffffed99","folded":false,"id":546,"markups":[{"date":"2022-04-02 09:30:47","docid":0,"fillcolor":"ffffed99","folded":true,"id":547,"markups":[{"content":"栈：运行单位，主管运行\n堆：存储单位，主管存储\n\n对于基本数据类型放到栈中，对应引用数据类型，栈只放引用，实际存储还是在堆中","date":"2022-04-02 09:33:19","docid":0,"fillcolor":"ffffed99","id":550,"originaltext":"内存中的栈与堆","page":53,"textblocks":[{"first":[75.52161407470703,253.8612060546875,14.631797790527344,17.5],"last":[163.31240844726562,253.8612060546875,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,253.8612060546875,102.42259979248047,17.5]],"start":184,"text":"内存中的栈与堆"}],"type":5},{"date":"2022-04-02 09:37:06","docid":0,"fillcolor":"ffffed99","folded":false,"id":551,"markups":[{"content":"1、它是一个以栈的方式存储一个个栈帧的内存结构，\n2、栈帧对应一次方法调用，最顶层的栈帧称为活动栈帧\n3、并且线程私有","date":"2022-04-02 09:37:24","docid":0,"fillcolor":"ffffed99","id":552,"originaltext":"Java虚拟机栈是什么？","page":53,"textblocks":[{"first":[98.03207397460938,727.8291015625,2.604461669921875,12.5],"last":[184.65594482421875,727.8291015625,9.754531860351562,12.5],"length":12,"rects":[[98.03207397460938,727.8291015625,96.37840270996094,12.5]],"start":288,"text":"Java虚拟机栈是什么？"}],"type":5},{"content":"与线程的生命周期一样","date":"2022-04-02 09:39:27","docid":0,"fillcolor":"ffffed99","id":553,"originaltext":"虚拟机栈的生命周期","page":54,"textblocks":[{"first":[98.03207397460938,642.7899780273438,9.754531860351562,12.5],"last":[176.06832885742188,642.7899780273438,9.754531860351562,12.5],"length":9,"rects":[[98.03207397460938,642.7899780273438,87.79078674316406,12.5]],"start":2,"text":"虚拟机栈的生命周期"}],"type":5},{"content":"1、管理程序运行，存储局部变量、部分结果、参与方法的调用和返回","date":"2022-04-02 09:39:55","docid":0,"fillcolor":"ffffed99","id":554,"originaltext":"虚拟机栈的作用","page":54,"textblocks":[{"first":[98.03207397460938,677.3060913085938,9.754531860351562,12.5],"last":[156.55926513671875,677.3060913085938,9.754531860351562,12.5],"length":7,"rects":[[98.03207397460938,677.3060913085938,68.28172302246094,12.5]],"start":41,"text":"虚拟机栈的作用"}],"type":5}],"originaltext":"虚拟机栈基本内容","page":53,"textblocks":[{"first":[75.52161407470703,697.3172607421875,14.631797790527344,17.5],"last":[177.94419860839844,697.3172607421875,14.631790161132812,17.5],"length":8,"rects":[[75.52161407470703,697.3172607421875,117.05437469482422,17.5]],"start":278,"text":"虚拟机栈基本内容"}],"type":5},{"content":"1、速度第二（第一是程序计数器）\n2、操作只有入栈和出栈\n3、不需要GC","date":"2022-04-02 09:43:57","docid":0,"fillcolor":"ffffed99","id":555,"originaltext":"虚拟机栈的特点","page":55,"textblocks":[{"first":[75.52161407470703,30.2574462890625,14.631797790527344,17.5],"last":[163.31240844726562,30.2574462890625,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,30.2574462890625,102.42259979248047,17.5]],"start":0,"text":"虚拟机栈的特点"}],"type":5},{"content":"1、StackoverflowError\n（固定了大小的虚拟机栈抛出的是栈溢出异常）\n2、OutofMemoryError\n（对于可拓展的虚拟机栈就是OOM内存溢出异常）","date":"2022-04-02 09:46:14","docid":0,"fillcolor":"ffffed99","id":556,"originaltext":"虚拟机栈的异常","page":55,"textblocks":[{"first":[75.52161407470703,614.529296875,14.631797790527344,17.5],"last":[163.31240844726562,614.529296875,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,614.529296875,102.42259979248047,17.5]],"start":124,"text":"虚拟机栈的异常"}],"type":5},{"date":"2022-04-02 09:50:02","docid":0,"fillcolor":"ffffed99","folded":false,"id":557,"markups":[{"date":"2022-04-02 09:51:08","docid":0,"fillcolor":"ffffed99","id":559,"originaltext":"我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。","page":56,"textblocks":[{"first":[75.52161407470703,146.8095703125,9.754531860351562,12.5],"last":[509.6114807128906,146.8095703125,9.754547119140625,12.5],"length":49,"rects":[[75.52161407470703,146.8095703125,443.8444137573242,12.5]],"start":129,"text":"我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。"}],"type":5}],"originaltext":"设置栈内存大小","page":56,"textblocks":[{"first":[75.52161407470703,30.25732421875,14.631797790527344,17.5],"last":[163.31240844726562,30.25732421875,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,30.25732421875,102.42259979248047,17.5]],"start":0,"text":"设置栈内存大小"}],"type":5}],"originaltext":"简介","page":53,"textblocks":[{"first":[75.52161407470703,122.0509033203125,17.07042694091797,19.5],"last":[92.592041015625,122.0509033203125,17.0704345703125,19.5],"length":2,"rects":[[75.52161407470703,122.0509033203125,34.14086151123047,19.5]],"start":8,"text":"简介"}],"type":5},{"date":"2022-04-02 09:50:20","docid":0,"fillcolor":"ffffed99","folded":true,"id":558,"markups":[{"content":"1、存储的是栈帧\n（一个方法对应一个栈帧）","date":"2022-04-02 09:51:54","docid":0,"fillcolor":"ffffed99","id":560,"originaltext":"栈中存储什么？","page":57,"textblocks":[{"first":[75.52161407470703,418.1875,14.631797790527344,17.5],"last":[163.31240844726562,418.1875,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,418.1875,102.42259979248047,17.5]],"start":26,"text":"栈中存储什么？"}],"type":5},{"content":"1、只有入栈出栈操作\n2、最顶层的栈帧就是活动栈帧，对应的就是当前方法\n3、不同线程的栈帧不能引用\n4、出栈：return、正常处理异常\n（没有处理异常直接结束程序）","date":"2022-04-02 09:52:28","docid":0,"fillcolor":"ffffed99","id":561,"originaltext":"栈运行原理","page":57,"textblocks":[{"first":[75.52161407470703,524.4873046875,14.631797790527344,17.5],"last":[134.04879760742188,524.4873046875,14.631805419921875,17.5],"length":5,"rects":[[75.52161407470703,524.4873046875,73.15898895263672,17.5]],"start":161,"text":"栈运行原理"}],"type":5},{"date":"2022-04-02 09:54:14","docid":0,"fillcolor":"ffffed99","folded":true,"id":562,"markups":[{"date":"2022-04-02 10:05:25","docid":0,"fillcolor":"ffffed99","id":563,"originaltext":"局部变量表","page":58,"textblocks":[{"first":[98.03207397460938,520.1831665039062,9.754531860351562,13.5],"last":[137.05020141601562,520.1831665039062,9.754531860351562,13.5],"length":5,"rects":[[98.03207397460938,520.1831665039062,48.77265930175781,13.5]],"start":249,"text":"局部变量表"}],"type":5},{"date":"2022-04-02 10:05:27","docid":0,"fillcolor":"ffffed99","id":564,"originaltext":"操作数栈","page":58,"textblocks":[{"first":[98.03207397460938,534.3900146484375,9.754531860351562,14.5],"last":[127.29566955566406,534.3900146484375,9.754531860351562,14.5],"length":4,"rects":[[98.03207397460938,534.3900146484375,39.01812744140625,14.5]],"start":272,"text":"操作数栈"}],"type":5},{"date":"2022-04-02 10:05:31","docid":0,"fillcolor":"ffffed99","id":565,"originaltext":"动态链接","page":58,"textblocks":[{"first":[98.03207397460938,549.3968505859375,9.754531860351562,14.5],"last":[127.29566955566406,549.3968505859375,9.754531860351562,14.5],"length":4,"rects":[[98.03207397460938,549.3968505859375,39.01812744140625,14.5]],"start":299,"text":"动态链接"}],"type":5},{"date":"2022-04-02 10:05:34","docid":0,"fillcolor":"ffffed99","id":566,"originaltext":"方法返回地址","page":58,"textblocks":[{"first":[98.03207397460938,565.2041625976562,9.754531860351562,13.5],"last":[146.8047332763672,565.2041625976562,9.754531860351562,13.5],"length":6,"rects":[[98.03207397460938,565.2041625976562,58.527191162109375,13.5]],"start":337,"text":"方法返回地址"}],"type":5},{"date":"2022-04-02 10:05:36","docid":0,"fillcolor":"ffffed99","id":567,"originaltext":"一些附加信息","page":58,"textblocks":[{"first":[98.03207397460938,579.510986328125,9.754531860351562,13.5],"last":[146.8047332763672,579.510986328125,9.754531860351562,13.5],"length":6,"rects":[[98.03207397460938,579.510986328125,58.527191162109375,13.5]],"start":378,"text":"一些附加信息"}],"type":5}],"originaltext":"栈帧的内部结构","page":58,"textblocks":[{"first":[75.52161407470703,467.460693359375,14.631797790527344,17.5],"last":[163.31240844726562,467.460693359375,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,467.460693359375,102.42259979248047,17.5]],"start":230,"text":"栈帧的内部结构"}],"type":5}],"originaltext":"栈的存储单位","page":57,"textblocks":[{"first":[75.52161407470703,386.173583984375,17.07042694091797,19.5],"last":[160.87376403808594,386.173583984375,17.0704345703125,19.5],"length":6,"rects":[[75.52161407470703,386.173583984375,102.4225845336914,19.5]],"start":18,"text":"栈的存储单位"}],"type":5},{"content":"1、临时存储空间\n2、是执行引擎的工作区，菜板儿\n3、栈帧创建出来的时候操作数栈是空的，但是已经被创建出来了\n4、其存储的规定与局部变量表一样\n5、如果上一个栈帧有返回，会压入当前栈帧的操作数栈中","date":"2022-04-02 11:01:23","docid":0,"fillcolor":"ffffed99","folded":true,"id":574,"markups":[{"content":"1、存放临时数据，存储需要操作的数","date":"2022-04-02 11:08:13","docid":0,"fillcolor":"ffffed99","id":575,"originaltext":"操作数栈的特点","page":67,"textblocks":[{"first":[75.52161407470703,500.4765625,14.631797790527344,17.5],"last":[163.31240844726562,500.4765625,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,500.4765625,102.42259979248047,17.5]],"start":331,"text":"操作数栈的特点"}],"type":5},{"content":"1、临时存储空间\n2、是执行引擎的工作区，菜板儿\n3、栈帧创建出来的时候操作数栈是空的，但是已经被创建出来了\n4、其存储的规定与局部变量表一样\n5、如果上一个栈帧有返回，会压入当前栈帧的操作数栈中","date":"2022-04-02 11:11:03","docid":0,"fillcolor":"ffffed99","id":576,"originaltext":"操作数栈的作用","page":68,"textblocks":[{"first":[75.52161407470703,295.8798828125,14.631797790527344,17.5],"last":[163.31240844726562,295.8798828125,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,295.8798828125,102.42259979248047,17.5]],"start":6,"text":"操作数栈的作用"}],"type":5},{"date":"2022-04-02 11:20:58","docid":0,"fillcolor":"ffffed99","id":577,"originaltext":"栈顶缓存技术","page":74,"textblocks":[{"first":[75.52161407470703,786.611328125,17.07042694091797,20.5],"last":[160.87376403808594,786.611328125,17.0704345703125,20.5],"length":6,"rects":[[75.52161407470703,786.611328125,102.4225845336914,20.5]],"start":83,"text":"栈顶缓存技术"}],"type":5},{"content":"局部变量表：\n1、是一个数字数组，存储方法参数和局部变量\n2、栈中只要需要分配内存那么局部变量表上都存在\n3、线程私有，线程安全\n4、固定大小\n5、出栈即销毁\n\nslot插槽：\n1、局部变量表的存储单元就是Slot槽\n2、32位以内占一个slot，64位占两个slot\n3、slot携带指向变量的索引\n4、局部变量是值复制\n5、两个slot的索引在第一个slot中\n6、对于实例方法，会将当前对象的引用放到index为0的位置\n7、this指向index为0的为位置\n\n\n当局部变量表中不存在对堆中class的引用就会gc，是垃圾回收gc的根节点","date":"2022-04-02 10:06:27","docid":0,"fillcolor":"ffffed99","folded":true,"id":568,"markups":[{"content":"","date":"2022-04-02 10:07:45","docid":0,"fillcolor":"ffffed99","id":569,"originaltext":"认识局部变量表","page":59,"textblocks":[{"first":[75.52161407470703,478.9658203125,14.631797790527344,17.5],"last":[163.31240844726562,478.9658203125,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,478.9658203125,102.42259979248047,17.5]],"start":7,"text":"认识局部变量表"}],"type":5},{"content":"1、局部变量表的存储单元就是Slot槽\n2、32位以内占一个slot，64位占两个slot\n3、slot携带指向变量的索引\n4、局部变量是值复制\n5、两个slot的索引在第一个slot中\n6、对于实例方法，会将当前对象的引用放到index为0的位置\n7、this指向index为0的为位置","date":"2022-04-02 10:22:13","docid":0,"fillcolor":"ffffed99","id":570,"originaltext":"关于Slot的理解","page":64,"textblocks":[{"first":[75.52161407470703,30.7568359375,14.631797790527344,17.5],"last":[161.98353576660156,30.7568359375,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,30.7568359375,101.09371185302734,17.5]],"start":0,"text":"关于Slot的理解"}],"type":5},{"date":"2022-04-02 10:38:16","docid":0,"fillcolor":"ffffed99","id":571,"originaltext":"Slot的重复利用","page":66,"textblocks":[{"first":[75.52161407470703,235.6015625,8.062118530273438,17.5],"last":[161.98353576660156,235.6015625,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,235.6015625,101.09371185302734,17.5]],"start":53,"text":"Slot的重复利用"}],"type":5},{"date":"2022-04-02 10:57:31","docid":0,"fillcolor":"ffffed99","id":572,"originaltext":"静态变量与局部变量的对比","page":67,"textblocks":[{"first":[75.52161407470703,30.2568359375,14.631797790527344,17.5],"last":[236.4713897705078,30.2568359375,14.631790161132812,17.5],"length":12,"rects":[[75.52161407470703,30.2568359375,175.5815658569336,17.5]],"start":0,"text":"静态变量与局部变量的对比"}],"type":5},{"date":"2022-04-02 10:57:43","docid":0,"fillcolor":"ffffed99","id":573,"originaltext":"补充说明","page":67,"textblocks":[{"first":[75.52161407470703,347.4052734375,14.631797790527344,17.5],"last":[119.41700744628906,347.4052734375,14.631790161132812,17.5],"length":4,"rects":[[75.52161407470703,347.4052734375,58.527183532714844,17.5]],"start":202,"text":"补充说明"}],"type":5}],"originaltext":"局部变量表","page":59,"textblocks":[{"first":[75.52161407470703,446.95166015625,17.07042694091797,19.5],"last":[143.80332946777344,446.95166015625,17.0704345703125,19.5],"length":5,"rects":[[75.52161407470703,446.95166015625,85.3521499633789,19.5]],"start":0,"text":"局部变量表"}],"type":5}],"originaltext":"操作数栈","page":67,"textblocks":[{"first":[75.52161407470703,468.4619140625,17.07042694091797,20.5],"last":[126.73291015625,468.4619140625,17.0704345703125,20.5],"length":4,"rects":[[75.52161407470703,468.4619140625,68.28173065185547,20.5]],"start":325,"text":"操作数栈"}],"type":5},{"content":"常量池中有该方法的信息，动态链接指向他","date":"2022-04-02 11:21:08","docid":0,"fillcolor":"ffffed99","id":578,"originaltext":"动态链接","page":75,"textblocks":[{"first":[75.52161407470703,188.583984375,17.07042694091797,20.5],"last":[126.73291015625,188.583984375,17.0704345703125,20.5],"length":4,"rects":[[75.52161407470703,188.583984375,68.28173065185547,20.5]],"start":356,"text":"动态链接"}],"type":5},{"content":"静态和动态的实质就是编译期和执行期","date":"2022-04-02 11:49:38","docid":0,"fillcolor":"ffffed99","folded":true,"id":579,"markups":[{"content":"静态链接：编译期间确定调用的是哪个类的方法\n\n动态链接：执行期间才能确定调用的是哪个类的哪个方法","date":"2022-04-02 11:54:26","docid":0,"fillcolor":"ffffed99","id":580,"originaltext":"静态链接与动态链接","page":78,"textblocks":[{"first":[75.52161407470703,707.82421875,14.631797790527344,17.5],"last":[192.5760040283203,707.82421875,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,707.82421875,131.6861801147461,17.5]],"start":540,"text":"静态链接与动态链接"}],"type":5},{"content":"早期绑定：在编译期间就确定了调用的方法是哪个属性的方法，可以直接绑定到属性\n\n晚期绑定：只能在运行期间才能确定方法是哪个属性的方法","date":"2022-04-02 14:27:06","docid":0,"fillcolor":"ffffed99","id":584,"originaltext":"早期绑定与晚期绑定","page":79,"textblocks":[{"first":[75.52161407470703,115.798828125,14.631797790527344,17.5],"last":[192.5760040283203,115.798828125,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,115.798828125,131.6861801147461,17.5]],"start":89,"text":"早期绑定与晚期绑定"}],"type":5},{"content":"出现了多态，就需要确定方法到底是哪个类实现的方法，\n可以用早期绑定和晚期绑定的方式来分类绑定方式","date":"2022-04-02 14:37:50","docid":0,"fillcolor":"ffffed99","id":585,"originaltext":"多态与绑定","page":81,"textblocks":[{"first":[75.52161407470703,422.439453125,14.631797790527344,17.5],"last":[134.04879760742188,422.439453125,14.631805419921875,17.5],"length":5,"rects":[[75.52161407470703,422.439453125,73.15898895263672,17.5]],"start":71,"text":"多态与绑定"}],"type":5},{"content":"这些方法不用调用就能知道是哪个类的方法\n那么就是非虚方法\n\n编译期间是否能确实是哪个类的方法","date":"2022-04-02 14:37:58","docid":0,"fillcolor":"ffffed99","folded":true,"id":586,"markups":[{"date":"2022-04-02 14:41:50","docid":0,"fillcolor":"ffffed99","id":587,"originaltext":"虚方法与非虚方法的区别","page":81,"textblocks":[{"first":[75.52161407470703,594.017578125,9.754531860351562,12.5],"last":[173.0669403076172,594.017578125,9.754531860351562,12.5],"length":11,"rects":[[75.52161407470703,594.017578125,107.29985809326172,12.5]],"start":360,"text":"虚方法与非虚方法的区别"}],"type":5},{"date":"2022-04-02 14:56:41","docid":0,"fillcolor":"ffffed99","id":588,"originaltext":"虚拟机中调用方法的指令","page":81,"textblocks":[{"first":[75.52161407470703,791.359375,9.754531860351562,13.5],"last":[173.0669403076172,791.359375,9.754531860351562,13.5],"length":11,"rects":[[75.52161407470703,791.359375,107.29985809326172,13.5]],"start":513,"text":"虚拟机中调用方法的指令"}],"type":5}],"originaltext":"虚方法与非虚方法","page":81,"textblocks":[{"first":[75.52161407470703,567.255859375,12.193168640136719,15.5],"last":[160.87376403808594,567.255859375,12.193161010742188,15.5],"length":8,"rects":[[75.52161407470703,567.255859375,97.5453109741211,15.5]],"start":350,"text":"虚方法与非虚方法"}],"type":5},{"content":"执行的时候检查变量的类型还是编译的时候就检查\n\nJava是静态语言，在编译的时候检查数据类型\n而js是动态语言\n\n总结：看变量确定类型还是看值确定类型\n看变量确定类型就是静态，看值就是动态\n\n（其中拉姆达表达式就具有动态语言的特点）","date":"2022-04-02 11:54:41","docid":0,"fillcolor":"ffffed99","folded":true,"id":581,"markups":[{"date":"2022-04-02 14:24:32","docid":0,"fillcolor":"ffffed99","id":582,"originaltext":"1. 动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。","page":85,"textblocks":[{"first":[87.52719116210938,395.92578125,5.57958984375,12.5],"last":[273.6136474609375,410.93359375,9.7545166015625,12.5],"length":66,"rects":[[87.52719116210938,395.92578125,429.9497375488281,12.5],[98.03207397460938,410.93359375,185.33609008789062,12.5]],"start":15,"text":"1. 动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者\n就是静态类型语言，反之是动态类型语言。"}],"type":5}],"originaltext":"动态语言和静态语言","page":85,"textblocks":[{"first":[75.52161407470703,365.4140625,14.631797790527344,17.5],"last":[192.5760040283203,365.4140625,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,365.4140625,131.6861801147461,17.5]],"start":4,"text":"动态语言和静态语言"}],"type":5},{"date":"2022-04-02 14:26:46","docid":0,"fillcolor":"ffffed99","folded":true,"id":583,"markups":[{"content":"因为不能确定调用的方法是哪个类的方法\n所以在方法区中建立了一个虚方法表直接指向虚方法实际调用的方法是哪个类的方法","date":"2022-04-02 15:17:34","docid":0,"fillcolor":"ffffed99","id":589,"originaltext":"虚方法表","page":86,"textblocks":[{"first":[75.52161407470703,76.529296875,14.631797790527344,18.5],"last":[119.41700744628906,76.529296875,14.631790161132812,18.5],"length":4,"rects":[[75.52161407470703,76.529296875,58.527183532714844,18.5]],"start":4,"text":"虚方法表"}],"type":5}],"originaltext":"Java语言中方法重写的本质","page":85,"textblocks":[{"first":[75.52161407470703,582.765625,4.8431243896484375,17.5],"last":[238.05030822753906,582.765625,14.631790161132812,17.5],"length":14,"rects":[[75.52161407470703,582.765625,177.16048431396484,17.5]],"start":300,"text":"Java语言中方法重写的本质"}],"type":5}],"originaltext":"方法的调用","page":78,"textblocks":[{"first":[75.52161407470703,675.80859375,17.07042694091797,19.5],"last":[143.80332946777344,675.80859375,17.0704345703125,19.5],"length":5,"rects":[[75.52161407470703,675.80859375,85.3521499633789,19.5]],"start":533,"text":"方法的调用"}],"type":5},{"content":"将程序计数器的值给读取进来\n等待执行引擎读取","date":"2022-04-02 15:18:43","docid":0,"fillcolor":"ffffed99","folded":true,"id":590,"markups":[{"date":"2022-04-02 15:42:39","docid":0,"fillcolor":"ffffed99","id":592,"originaltext":"正常退出：","page":89,"textblocks":[{"first":[75.52161407470703,242.60546875,9.754531860351562,13.5],"last":[114.53974151611328,242.60546875,9.754531860351562,13.5],"length":5,"rects":[[75.52161407470703,242.60546875,48.77265930175781,13.5]],"start":305,"text":"正常退出："}],"type":5},{"date":"2022-04-02 15:42:43","docid":0,"fillcolor":"ffffed99","id":593,"originaltext":"异常退出：","page":89,"textblocks":[{"first":[75.52161407470703,476.96484375,9.754531860351562,12.5],"last":[114.53974151611328,476.96484375,9.754531860351562,12.5],"length":5,"rects":[[75.52161407470703,476.96484375,48.77265930175781,12.5]],"start":592,"text":"异常退出："}],"type":5}],"originaltext":"方法返回地址","page":88,"textblocks":[{"first":[75.52161407470703,318.39453125,17.07042694091797,20.5],"last":[160.87376403808594,318.39453125,17.0704345703125,20.5],"length":6,"rects":[[75.52161407470703,318.39453125,102.4225845336914,20.5]],"start":4,"text":"方法返回地址"}],"type":5},{"date":"2022-04-02 15:43:18","docid":0,"fillcolor":"ffffed99","id":594,"originaltext":"一些附加信息","page":90,"textblocks":[{"first":[75.52161407470703,279.375,17.07042694091797,20.5],"last":[160.87376403808594,279.375,17.0704345703125,20.5],"length":6,"rects":[[75.52161407470703,279.375,102.4225845336914,20.5]],"start":2,"text":"一些附加信息"}],"type":5},{"date":"2022-04-02 15:46:48","docid":0,"fillcolor":"ffffed99","id":595,"originaltext":"栈相关面试题","page":90,"textblocks":[{"first":[75.52161407470703,359.162109375,17.07042694091797,20.5],"last":[160.87376403808594,359.162109375,17.0704345703125,20.5],"length":6,"rects":[[75.52161407470703,359.162109375,102.4225845336914,20.5]],"start":57,"text":"栈相关面试题"}],"type":5}],"originaltext":"虚拟机栈","page":53,"textblocks":[{"first":[75.52161407470703,85.7859115600586,21.94770050048828,24.5],"last":[141.3647003173828,85.7859115600586,21.94769287109375,24.5],"length":4,"rects":[[75.52161407470703,85.7859115600586,87.79077911376953,24.5]],"start":2,"text":"虚拟机栈"}],"title":"第4章-虚拟机栈","type":5},{"date":"2022-04-02 15:53:37","docid":0,"fillcolor":"ffffed99","folded":false,"id":596,"markups":[{"date":"2022-04-06 09:27:27","docid":0,"fillcolor":"ffffed99","folded":true,"id":597,"markups":[{"content":"1、每一个进程对应一个JVM实例对应一个堆空间（线程共享堆空间）\n2、堆空间中存在一个小空间每个线程一份（TLAB缓冲区）\n3、当栈帧中的局部变量表没有引用堆中类的时候，类不会马上被回收\n4、是GC回收的重要地点\n5、只有new的时候才会，在堆空间中创建","date":"2022-04-06 09:27:30","docid":0,"fillcolor":"ffffed99","id":598,"originaltext":"堆与进程","page":93,"textblocks":[{"first":[75.52161407470703,154.06484985351562,14.631797790527344,17.5],"last":[119.41700744628906,154.06484985351562,14.631790161132812,17.5],"length":4,"rects":[[75.52161407470703,154.06484985351562,58.527183532714844,17.5]],"start":13,"text":"堆与进程"}],"type":5,"uuid":"7b663455c823bc4b6df43e68207d2bb9"},{"date":"2022-04-06 10:38:32","docid":0,"fillcolor":"ffffed99","folded":true,"id":599,"markups":[{"date":"2022-04-06 10:43:41","docid":0,"fillcolor":"ffffed99","id":600,"markups":[{"date":"2022-04-06 10:43:52","docid":0,"fillcolor":"ffffed99","id":602,"originaltext":"新生区+养老区+永久区","page":94,"textblocks":[{"first":[270.8034973144531,625.2320556640625,9.754547119140625,13.5],"last":[359.9945983886719,625.2320556640625,9.754547119140625,13.5],"length":11,"rects":[[270.8034973144531,625.2320556640625,98.94564819335938,13.5]],"start":63,"text":"新生区+养老区+永久区"}],"type":5,"uuid":"ce6330c6bec459547a87a6338ae3c58c"}],"originaltext":"1. Java7","page":94,"textblocks":[{"first":[87.52719116210938,625.2320556640625,5.57958984375,13.5],"last":[116.37059783935547,625.2320556640625,5.57958984375,13.5],"length":8,"rects":[[87.52719116210938,625.2320556640625,34.422996520996094,13.5]],"start":39,"text":"1. Java7"}],"type":5,"uuid":"c0ced6a3448d74284bad02b07f25b1ff"},{"date":"2022-04-06 10:43:48","docid":0,"fillcolor":"ffffed99","id":601,"markups":[{"date":"2022-04-06 10:43:57","docid":0,"fillcolor":"ffffed99","id":603,"originaltext":"新生区+养老区+元空间","page":94,"textblocks":[{"first":[270.8034973144531,721.0759887695312,9.754547119140625,12.5],"last":[359.9945983886719,721.0759887695312,9.754547119140625,12.5],"length":11,"rects":[[270.8034973144531,721.0759887695312,98.94564819335938,12.5]],"start":259,"text":"新生区+养老区+元空间"}],"type":5,"uuid":"e0cf31313a86c70fcd5d31bc94c56c20"}],"originaltext":"2. Java 8","page":94,"textblocks":[{"first":[87.52719116210938,721.0759887695312,5.57958984375,12.5],"last":[118.90676879882812,721.0759887695312,5.57958984375,12.5],"length":9,"rects":[[87.52719116210938,721.0759887695312,36.95916748046875,12.5]],"start":235,"text":"2. Java 8"}],"type":5,"uuid":"fba299b5a2f3622f5085e1a6f04c25ad"}],"originaltext":"堆内存细分","page":94,"textblocks":[{"first":[75.52161407470703,572.7593383789062,14.631797790527344,17.5],"last":[134.04879760742188,572.7593383789062,14.631805419921875,17.5],"length":5,"rects":[[75.52161407470703,572.7593383789062,73.15898895263672,17.5]],"start":2,"text":"堆内存细分"}],"type":5,"uuid":"7f487c3ba25a2cdffdcf2d26c16db7a8"}],"originaltext":"堆的核心概述","page":93,"textblocks":[{"first":[75.52161407470703,122.0509033203125,17.07042694091797,19.5],"last":[160.87376403808594,122.0509033203125,17.0704345703125,19.5],"length":6,"rects":[[75.52161407470703,122.0509033203125,102.4225845336914,19.5]],"start":5,"text":"堆的核心概述"}],"type":5,"uuid":"68931164154b8866ad05cfff204e3a48"},{"content":"当老年代满了，伊甸圆区也满了就会报OOM","date":"2022-04-06 10:49:37","docid":0,"fillcolor":"ffffed99","folded":false,"id":604,"markups":[{"date":"2022-04-06 10:53:34","docid":0,"fillcolor":"ffffed99","id":605,"originaltext":"设置堆内存","page":97,"textblocks":[{"first":[75.52161407470703,628.28515625,14.631797790527344,17.5],"last":[134.04879760742188,628.28515625,14.631805419921875,17.5],"length":5,"rects":[[75.52161407470703,628.28515625,73.15898895263672,17.5]],"start":26,"text":"设置堆内存"}],"type":5,"uuid":"acaa9bf374ee624d423b770481cd4623"},{"date":"2022-04-06 15:26:34","docid":0,"fillcolor":"ffffed99","id":607,"originaltext":"OOM","page":100,"textblocks":[{"first":[75.52161407470703,591.767578125,11.64691162109375,14.5],"last":[98.81544494628906,591.767578125,13.797782897949219,14.5],"length":3,"rects":[[75.52161407470703,591.767578125,37.09161376953125,14.5]],"start":209,"text":"OOM"}],"type":5,"uuid":"deab2358a75b40daf3ef9f7e9ad08e45"}],"originaltext":"设置堆内存大小与 OOM","page":97,"textblocks":[{"first":[75.52161407470703,596.271240234375,17.07042694091797,19.5],"last":[243.69949340820312,596.271240234375,16.097412109375,19.5],"length":12,"rects":[[75.52161407470703,596.271240234375,184.2752914428711,19.5]],"start":12,"text":"设置堆内存大小与 OOM"}],"type":5,"uuid":"f40f9d27f29361fa5276fd039f3f8d04"},{"content":"1、其中年轻代存放的是生命周期较短的类\n老年存储生命周期较长的类\n2、年轻代又分为伊甸园区和s0和s1区\n3、默认年轻代和老年的比例是1：2\n4、新生代中伊甸园区和s0和s1区的比例\n8：1：1（需要显示设置）","date":"2022-04-06 10:54:00","docid":0,"fillcolor":"ffffed99","folded":false,"id":606,"markups":[{"date":"2022-04-06 15:31:49","docid":0,"fillcolor":"ffffed99","id":608,"originaltext":"一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速","page":102,"textblocks":[{"first":[95.85560607910156,415.255859375,8.779075622558594,8.779083251953125],"last":[350.448974609375,415.255859375,8.779083251953125,8.779083251953125],"length":30,"rects":[[95.85560607910156,415.255859375,263.37245178222656,8.779083251953125]],"start":150,"text":"一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速"}],"type":5,"uuid":"d968a816dc4bfce6781af250fd5f5de1"},{"date":"2022-04-06 15:31:54","docid":0,"fillcolor":"ffffed99","id":609,"originaltext":"另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致","page":102,"textblocks":[{"first":[95.85560607910156,428.76171875,8.779075622558594,8.779083251953125],"last":[436.55078125,428.76171875,8.779083251953125,8.779083251953125],"length":41,"rects":[[95.85560607910156,428.76171875,349.47425842285156,8.779083251953125]],"start":183,"text":"另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致"}],"type":5,"uuid":"bfeae0237dc52ea9250796d54fd9ec70"},{"date":"2022-04-06 15:37:32","docid":0,"fillcolor":"ffffed99","id":610,"originaltext":"配置新生代与老年代在堆结构的占比","page":103,"textblocks":[{"first":[98.03207397460938,155.0634765625,9.754531860351562,12.5],"last":[244.3500518798828,155.0634765625,9.754531860351562,12.5],"length":16,"rects":[[98.03207397460938,155.0634765625,156.072509765625,12.5]],"start":0,"text":"配置新生代与老年代在堆结构的占比"}],"type":5,"uuid":"22969e0acc993a834475ed83ed00f22a"},{"date":"2022-04-06 15:37:43","docid":0,"fillcolor":"ffffed99","id":611,"originaltext":"1. 在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，","page":103,"textblocks":[{"first":[87.52719116210938,257.56134033203125,5.57958984375,13.5],"last":[421.9797058105469,257.56134033203125,9.754547119140625,13.5],"length":52,"rects":[[87.52719116210938,257.56134033203125,344.2070617675781,13.5]],"start":109,"text":"1. 在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，"}],"type":5,"uuid":"7a2c6e69f1861b4d82eb3329e2adae28"}],"originaltext":"年轻代与老年代","page":102,"textblocks":[{"first":[75.52161407470703,303.6357421875,17.07042694091797,19.5],"last":[177.94419860839844,303.6357421875,17.0704345703125,19.5],"length":7,"rects":[[75.52161407470703,303.6357421875,119.4930191040039,19.5]],"start":2,"text":"年轻代与老年代"}],"type":5,"uuid":"9e68a094a183cf809175c5bc67858e16"},{"content":"8个步骤：","date":"2022-04-06 15:38:04","docid":0,"fillcolor":"ffffed99","folded":true,"id":612,"markups":[{"date":"2022-04-06 15:40:39","docid":0,"fillcolor":"ffffed99","id":613,"originaltext":"具体过程","page":104,"textblocks":[{"first":[75.52161407470703,254.109375,9.754531860351562,12.5],"last":[104.78520965576172,254.109375,9.754531860351562,12.5],"length":4,"rects":[[75.52161407470703,254.109375,39.01812744140625,12.5]],"start":126,"text":"具体过程"}],"type":5,"uuid":"7e7cf80a6ffceb242e565cb318b4d198"},{"content":"1、对象产生会先放到伊甸园区\n2、当伊甸园区满了后会触发gc，gc会把垃圾进行回收，还存在的对象会被放到s0中，并给予你年龄\n3、再一次伊甸园区满了触发gc，gc不止会扫描伊甸园区，还会扫描s0和s1\n先扫描伊甸园区，还使用的对象会被放再空的s1中，并给予一个年龄，对于从另一个s0区出来的对象，年+1，于是不断的进行转移，年龄不断的+1\n4、当年龄达到16超过阈值的时候，就会被Promotion晋升到老年代中\n\n（只有伊甸园区才会触发gc，但是垃圾回收是整个年轻代）","date":"2022-04-06 15:42:44","docid":0,"fillcolor":"ffffed99","id":614,"originaltext":"图解对象分配（一般情况）","page":104,"textblocks":[{"first":[75.52161407470703,490.220703125,14.631797790527344,17.5],"last":[236.4713897705078,490.220703125,14.631790161132812,17.5],"length":12,"rects":[[75.52161407470703,490.220703125,175.5815658569336,17.5]],"start":553,"text":"图解对象分配（一般情况）"}],"type":5,"uuid":"ed1334aa145b9a08f9c18d486b9b698a"},{"content":"其中s0和s1的交换，是进行值的复制后交换","date":"2022-04-06 16:00:18","docid":0,"fillcolor":"ffffed99","id":616,"originaltext":"关于垃圾回收","page":105,"textblocks":[{"first":[75.52161407470703,515.9814453125,9.754531860351562,12.5],"last":[124.29427337646484,515.9814453125,9.754524230957031,12.5],"length":6,"rects":[[75.52161407470703,515.9814453125,58.527183532714844,12.5]],"start":297,"text":"关于垃圾回收"}],"type":5,"uuid":"8b796c0fd32dcda6bea6c2cf1030ac68"},{"date":"2022-04-06 15:57:49","docid":0,"fillcolor":"ffffed99","id":615,"originaltext":"特殊情况说明","page":105,"textblocks":[{"first":[75.52161407470703,541.2451171875,14.631797790527344,17.5],"last":[148.68060302734375,541.2451171875,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,541.2451171875,87.7907943725586,17.5]],"start":337,"text":"特殊情况说明"}],"type":5,"uuid":"d11e2083268a8322fcf13a08fbec7bbe"},{"date":"2022-04-06 16:10:51","docid":0,"fillcolor":"ffffed99","id":617,"originaltext":"常用调优工具","page":106,"textblocks":[{"first":[75.52161407470703,397.1767578125,14.631797790527344,17.5],"last":[148.68060302734375,397.1767578125,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,397.1767578125,87.7907943725586,17.5]],"start":0,"text":"常用调优工具"}],"type":5,"uuid":"80603799c2bfa9959e394ff3935bb5b6"}],"originaltext":"图解对象分配过程","page":104,"textblocks":[{"first":[75.52161407470703,124.3017578125,17.07042694091797,20.5],"last":[195.01463317871094,124.3017578125,17.0704345703125,20.5],"length":8,"rects":[[75.52161407470703,124.3017578125,136.5634536743164,20.5]],"start":2,"text":"图解对象分配过程"}],"type":5,"uuid":"bc22248a557dd43624e7673e36f84eb9"},{"date":"2022-04-06 16:11:01","docid":0,"fillcolor":"ffffed99","folded":true,"id":618,"markups":[{"date":"2022-04-06 16:18:01","docid":0,"fillcolor":"ffffed99","folded":true,"id":624,"markups":[{"date":"2022-04-06 16:16:46","docid":0,"fillcolor":"ffffed99","folded":true,"id":619,"markups":[{"date":"2022-04-06 16:16:59","docid":0,"fillcolor":"ffffed99","id":621,"originaltext":"新生代收集","page":106,"textblocks":[{"first":[120.54253387451172,795.5113525390625,9.754524230957031,14.5],"last":[159.56065368652344,795.5113525390625,9.754531860351562,14.5],"length":5,"rects":[[120.54253387451172,795.5113525390625,48.77265167236328,14.5]],"start":454,"text":"新生代收集"}],"type":5,"uuid":"e06915ffeb5e19714f77b80a41017bce"},{"date":"2022-04-06 16:17:02","docid":0,"fillcolor":"ffffed99","id":622,"originaltext":"老年代收集","page":107,"textblocks":[{"first":[120.54253387451172,29.7548828125,9.754524230957031,12.5],"last":[159.56065368652344,29.7548828125,9.754531860351562,12.5],"length":5,"rects":[[120.54253387451172,29.7548828125,48.77265167236328,12.5]],"start":0,"text":"老年代收集"}],"type":5,"uuid":"b6340dfed5cb4b6a7fe905e7c8eea496"},{"date":"2022-04-06 16:17:08","docid":0,"fillcolor":"ffffed99","id":623,"originaltext":"混合收集","page":107,"textblocks":[{"first":[120.54253387451172,74.7763671875,9.754524230957031,12.5],"last":[149.80612182617188,74.7763671875,9.754531860351562,12.5],"length":4,"rects":[[120.54253387451172,74.7763671875,39.01811981201172,12.5]],"start":108,"text":"混合收集"}],"type":5,"uuid":"5a449619eeca75cf38c1df6c2707b293"}],"originaltext":"部分收集","page":106,"textblocks":[{"first":[98.03207397460938,776.3515625,9.754531860351562,13.5],"last":[127.29566955566406,776.3515625,9.754531860351562,13.5],"length":4,"rects":[[98.03207397460938,776.3515625,39.01812744140625,13.5]],"start":423,"text":"部分收集"}],"type":5,"uuid":"f828c42213a12781eff7fbb897fab3ee"},{"date":"2022-04-06 16:16:54","docid":0,"fillcolor":"ffffed99","id":620,"originaltext":"整堆收集","page":107,"textblocks":[{"first":[98.03207397460938,104.7900390625,9.754531860351562,12.5],"last":[127.29566955566406,104.7900390625,9.754531860351562,12.5],"length":4,"rects":[[98.03207397460938,104.7900390625,39.01812744140625,12.5]],"start":161,"text":"整堆收集"}],"type":5,"uuid":"b44a73fead425fd30fc88789100d4868"}],"originaltext":"回收区域","page":106,"textblocks":[{"first":[281.9869079589844,714.4732666015625,9.754547119140625,14.5],"last":[311.2505187988281,714.4732666015625,9.754547119140625,14.5],"length":4,"rects":[[281.9869079589844,714.4732666015625,39.018157958984375,14.5]],"start":371,"text":"回收区域"}],"type":5,"uuid":"695d60fc09184c108b5a028fc795aec4"},{"date":"2022-04-06 16:18:19","docid":0,"fillcolor":"ffffed99","folded":true,"id":625,"markups":[{"content":"1、当年轻代空间满的时候才会触发MinorGC（特指的是年轻代中伊甸园）\n2、MinorGC触发的时候又会触发STW让其他用户的线程停止等待GC垃圾回收","date":"2022-04-06 16:18:51","docid":0,"fillcolor":"ffffed99","id":626,"originaltext":"触发机制","page":107,"textblocks":[{"first":[184.9743194580078,205.0369110107422,9.754531860351562,13.5],"last":[214.2379150390625,205.0369110107422,9.754531860351562,13.5],"length":4,"rects":[[184.9743194580078,205.0369110107422,39.01812744140625,13.5]],"start":258,"text":"触发机制"}],"type":5,"uuid":"806469045bc292bf10c624eeb92c93c3"}],"originaltext":"Young GC","page":107,"textblocks":[{"first":[75.52161407470703,176.8251953125,9.130241394042969,14.5],"last":[135.5997772216797,176.8251953125,9.320449829101562,14.5],"length":8,"rects":[[75.52161407470703,176.8251953125,69.39861297607422,14.5]],"start":232,"text":"Young GC"}],"type":5,"uuid":"5a66ccf507aed6f4d2e31df96a0fb0ba"},{"date":"2022-04-06 16:20:23","docid":0,"fillcolor":"ffffed99","folded":false,"id":627,"markups":[{"content":"1、老年代的GC有两个：Major\\FULL GC\n2、当老年代空间不足的时候会先触发一次MinorGC，后面才会触发老年代的GC\n3、远远比MinorGC慢，所以STW也慢\n4、还装不下就直接OOM","date":"2022-04-06 16:22:23","docid":0,"fillcolor":"ffffed99","id":628,"originaltext":"触发机制","page":107,"textblocks":[{"first":[179.3873748779297,711.0712890625,9.754531860351562,12.5],"last":[208.65097045898438,711.0712890625,9.754531860351562,12.5],"length":4,"rects":[[179.3873748779297,711.0712890625,39.01812744140625,12.5]],"start":565,"text":"触发机制"}],"type":5,"uuid":"6e90495555131c27d2566fa611f88e10"},{"content":"1、直接调用gc()方法\n2、老年代或者方法区中空间不足\n两种情况\n（大对象新生代放不下，直接存储老年代的时候会触发）\n（从S0或者S1到老年代，但是老年代空间放不下的时候会触发）","date":"2022-04-06 16:24:41","docid":0,"fillcolor":"ffffed99","id":629,"originaltext":"Full GC 触发机制","page":108,"textblocks":[{"first":[75.52161407470703,125.048828125,5.3552398681640625,12.5],"last":[140.85031127929688,125.048828125,9.754531860351562,12.5],"length":12,"rects":[[75.52161407470703,125.048828125,75.0832290649414,12.5]],"start":133,"text":"Full GC 触发机制"}],"type":5,"uuid":"d20b7434d1784661a6651c485fde3ab0"}],"originaltext":"Major/Full GC","page":107,"textblocks":[{"first":[75.52161407470703,657.9988403320312,13.797782897949219,18.5],"last":[165.3315887451172,657.9988403320312,9.320449829101562,18.5],"length":13,"rects":[[75.52161407470703,657.9988403320312,99.13042449951172,18.5]],"start":510,"text":"Major/Full GC"}],"type":5,"uuid":"a75d1a784b5f40be6b70e30f51727c6d"}],"originaltext":"GC分类","page":106,"textblocks":[{"first":[75.52161407470703,602.5234375,12.358993530273438,16.5],"last":[115.83050537109375,602.5234375,17.0704345703125,16.5],"length":4,"rects":[[75.52161407470703,602.5234375,57.37932586669922,16.5]],"start":161,"text":"GC分类"}],"type":5,"uuid":"04e15eec6605a9cdc8a20259b588d4bb"},{"date":"2022-04-06 16:31:29","docid":0,"fillcolor":"ffffed99","folded":true,"id":630,"markups":[{"content":"如果不分代，那么所有的对象全部存储在堆中，会出现gc垃圾回收扫描会扫描全部堆空间，产生很多无意义的扫描。发生的STW也会长很多","date":"2022-04-07 08:48:07","docid":0,"fillcolor":"ffffed99","id":631,"originaltext":"为什么要把Java堆分代？不分代就不能正常工作了吗？","page":110,"textblocks":[{"first":[75.52161407470703,51.96562576293945,9.754531860351562,13.499996185302734],"last":[298.70892333984375,51.96562576293945,9.7545166015625,13.499996185302734],"length":26,"rects":[[75.52161407470703,51.96562576293945,232.94182586669922,13.499996185302734]],"start":2,"text":"为什么要把Java堆分代？不分代就不能正常工作了吗？"}],"type":5,"uuid":"9ce5f7671e86dcd433ce70d6e4dd6b10"}],"originaltext":"堆空间分代思想","page":109,"textblocks":[{"first":[75.52161407470703,789.611328125,17.07042694091797,20.5],"last":[177.94419860839844,789.611328125,17.0704345703125,20.5],"length":7,"rects":[[75.52161407470703,789.611328125,119.4930191040039,20.5]],"start":147,"text":"堆空间分代思想"}],"type":5,"uuid":"f5677bdaa806240e85bd9a43de10d10d"},{"date":"2022-04-07 08:49:34","docid":0,"fillcolor":"ffffed99","folded":true,"id":632,"markups":[{"content":"1、优先放到伊甸园区\n2、大对象直接放到老年代\n3、长期存活的对象存放到老年代\n4、当相同年龄的大小相当于s区的一半，那么大于或者等于该年龄的对象直接进入老年代","date":"2022-04-07 09:16:21","docid":0,"fillcolor":"ffffed99","id":633,"originaltext":"针对不同年龄段的对象分配原则","page":110,"textblocks":[{"first":[75.52161407470703,759.5947265625,9.754531860351562,13.5],"last":[202.33053588867188,759.5947265625,9.754531860351562,13.5],"length":14,"rects":[[75.52161407470703,759.5947265625,136.5634536743164,13.5]],"start":581,"text":"针对不同年龄段的对象分配原则"}],"type":5,"uuid":"31dfb0fc10b7f645b7a12d0c88a6404a"}],"originaltext":"对象内存分配策略","page":110,"textblocks":[{"first":[75.52161407470703,600.7734375,17.07042694091797,19.5],"last":[195.01463317871094,600.7734375,17.0704345703125,19.5],"length":8,"rects":[[75.52161407470703,600.7734375,136.5634536743164,19.5]],"start":349,"text":"对象内存分配策略"}],"type":5,"uuid":"fc983f0235921b31b1ef267524ca3ea4"},{"date":"2022-04-07 09:48:31","docid":0,"fillcolor":"ffffed99","folded":true,"id":634,"markups":[{"content":"对于堆空间的操作是线程共享的，那么就会涉及到加锁的问题，不如建立一个小区域为线程独有，既能提高并发度，又能在特殊情况保证线程安全","date":"2022-04-07 09:49:43","docid":0,"fillcolor":"ffffed99","id":635,"originaltext":"为什么有 TLAB","page":111,"textblocks":[{"first":[75.52161407470703,244.1064453125,14.631797790527344,17.5],"last":[164.68780517578125,244.1064453125,9.832565307617188,17.5],"length":9,"rects":[[75.52161407470703,244.1064453125,98.9987564086914,17.5]],"start":260,"text":"为什么有 TLAB"}],"type":5,"uuid":"d2f6512539ba447c30720e8e61afb77f"},{"content":"这个TLAB在伊甸园区，每个线程会创建自己的TLAB，当使用完后就使用公共的伊甸园区\n（快速分配策略：可以避免非线程安全问题，同时提高快速分配）","date":"2022-04-07 09:51:28","docid":0,"fillcolor":"ffffed99","id":636,"originaltext":"什么是 TLAB","page":111,"textblocks":[{"first":[75.52161407470703,375.6669921875,14.631797790527344,14.5],"last":[150.05599975585938,375.6669921875,9.832565307617188,14.5],"length":8,"rects":[[75.52161407470703,375.6669921875,84.36695098876953,14.5]],"start":392,"text":"什么是 TLAB"}],"type":5,"uuid":"08464748c766bfe9e26911d28f936803"},{"content":"TLAB仅占伊甸园1%\n如果TLAB分配不下，才会尝试使用锁机制","date":"2022-04-07 09:54:51","docid":0,"fillcolor":"ffffed99","id":637,"markups":[{"date":"2022-04-07 09:55:34","docid":0,"fillcolor":"ffffed99","id":638,"originaltext":"JVM确实是将TLAB作为内存分配的首选。","page":112,"textblocks":[{"first":[355.0851135253906,130.0017547607422,3.228759765625,13.5],"last":[107.78660583496094,145.30859375,9.754531860351562,13.5],"length":22,"rects":[[355.0851135253906,130.0017547607422,160.26388549804688,13.5],[98.03207397460938,145.30859375,19.509063720703125,13.5]],"start":74,"text":"JVM确实是将TLAB作为内存分配的首\n选。"}],"type":5,"uuid":"63b2a8cee68981cdc4fc5b0ca33ab7f9"}],"originaltext":"TLAB再说明","page":112,"textblocks":[{"first":[75.52161407470703,78.529296875,8.471809387207031,13.5],"last":[141.450439453125,78.529296875,14.631805419921875,13.5],"length":7,"rects":[[75.52161407470703,78.529296875,80.56063079833984,13.5]],"start":32,"text":"TLAB再说明"}],"type":5,"uuid":"e33d466829506676f4eba957a27fa937"},{"date":"2022-04-07 09:56:06","docid":0,"fillcolor":"ffffed99","id":639,"originaltext":"TLAB 分配过程","page":112,"textblocks":[{"first":[75.52161407470703,376.666015625,5.6478729248046875,10.5],"last":[131.76258850097656,376.666015625,9.754531860351562,10.5],"length":9,"rects":[[75.52161407470703,376.666015625,65.9955062866211,10.5]],"start":504,"text":"TLAB 分配过程"}],"type":5,"uuid":"6a1bc49329c0af8ea553437ef3d45f8f"}],"originaltext":"TLAB为对象分配内存（保证线程安全）","page":111,"textblocks":[{"first":[75.52161407470703,212.091796875,9.883781433105469,19.5],"last":[357.28375244140625,212.091796875,17.0704345703125,19.5],"length":19,"rects":[[75.52161407470703,212.091796875,298.8325729370117,19.5]],"start":239,"text":"TLAB为对象分配内存（保证线程安全）"}],"type":5,"uuid":"8cc7ccdf0ce2b0460447f6ccb978034e"},{"date":"2022-04-07 09:58:45","docid":0,"fillcolor":"ffffed99","id":640,"originaltext":"堆空间参数设置","page":112,"textblocks":[{"first":[75.52161407470703,657.5498046875,17.07042694091797,20.5],"last":[177.94419860839844,657.5498046875,17.0704345703125,20.5],"length":7,"rects":[[75.52161407470703,657.5498046875,119.4930191040039,20.5]],"start":516,"text":"堆空间参数设置"}],"type":5,"uuid":"83816f892eb4b78afcb4d25fa1bfb34a"},{"content":"发生minorGC之前发生检查\n当老年代剩余的内存小于年轻代总的大小，\n\n如果用空间分配担保，就是显示那么多，认为他其实是历次晋升的平均大小（俗称乐观心理，赌一次）如果容的下，我就去年轻代来一次minorGC，还是放不下就FullGC，全部扫一遍\n（空间分配担保就是不想用FullGC，jdk6之后默认开启）\n\nFullGC的开启钥匙","date":"2022-04-07 09:58:53","docid":0,"fillcolor":"ffffed99","folded":true,"id":641,"markups":[{"date":"2022-04-07 10:17:32","docid":0,"fillcolor":"ffffed99","folded":true,"id":645,"markups":[{"date":"2022-04-07 10:17:38","docid":0,"fillcolor":"ffffed99","id":646,"originaltext":"新生代对象总大小","page":113,"textblocks":[{"first":[354.264404296875,592.1666259765625,9.7545166015625,14.5],"last":[422.546142578125,592.1666259765625,9.7545166015625,14.5],"length":8,"rects":[[354.264404296875,592.1666259765625,78.0362548828125,14.5]],"start":486,"text":"新生代对象总大小"}],"type":5,"uuid":"65e488065054580f1f7ffe7ebe8f1c05"},{"date":"2022-04-07 10:17:49","docid":0,"fillcolor":"ffffed99","id":647,"originaltext":"历次晋升的平均大小","page":113,"textblocks":[{"first":[451.8097229003906,592.1666259765625,9.754547119140625,14.5],"last":[107.78660583496094,607.9734497070312,9.754531860351562,13.5],"length":10,"rects":[[451.8097229003906,592.1666259765625,68.28170776367188,14.5],[98.03207397460938,607.9734497070312,19.509063720703125,13.5]],"start":496,"text":"历次晋升的平均\n大小"}],"type":5,"uuid":"f1adc63324e2e97c292b1a9bdcd1ff6a"}],"originaltext":"只要老年代的连续空间","page":113,"textblocks":[{"first":[237.21002197265625,592.1666259765625,9.754531860351562,14.5],"last":[325.0008239746094,592.1666259765625,9.754547119140625,14.5],"length":10,"rects":[[237.21002197265625,592.1666259765625,97.54534912109375,14.5]],"start":474,"text":"只要老年代的连续空间"}],"type":5,"uuid":"dfa4ea05f1f4744957b4224e078a85b3"}],"originaltext":"空间分配担保","page":113,"textblocks":[{"first":[75.52161407470703,287.6259765625,14.631797790527344,17.5],"last":[148.68060302734375,287.6259765625,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,287.6259765625,87.7907943725586,17.5]],"start":2,"text":"空间分配担保"}],"type":5,"uuid":"f9dd4279ef9959dac08d6d41698ad3d3"},{"content":"是，只要一个对象没有逃逸，那么可以直接放到栈","date":"2022-04-07 09:59:10","docid":0,"fillcolor":"ffffed99","folded":true,"id":642,"markups":[{"content":"分析对象到底放在堆中还是放在栈中","date":"2022-04-07 10:23:54","docid":0,"fillcolor":"ffffed99","folded":true,"id":648,"markups":[{"content":"创建的对象引用是否被拿到外部去了","date":"2022-04-07 10:29:46","docid":0,"fillcolor":"ffffed99","id":649,"originaltext":"逃逸分析举例","page":114,"textblocks":[{"first":[75.52161407470703,390.673828125,9.754531860351562,12.5],"last":[124.29427337646484,390.673828125,9.754524230957031,12.5],"length":6,"rects":[[75.52161407470703,390.673828125,58.527183532714844,12.5]],"start":572,"text":"逃逸分析举例"}],"type":5,"uuid":"87fe7667cca14b3a5397a0061a45010e"},{"date":"2022-04-07 10:32:19","docid":0,"fillcolor":"ffffed99","folded":true,"id":650,"markups":[{"date":"2022-04-07 10:34:03","docid":0,"fillcolor":"ffffed99","id":651,"originaltext":"1. 在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析","page":115,"textblocks":[{"first":[87.52719116210938,756.09375,5.57958984375,12.5],"last":[345.334228515625,756.09375,9.7545166015625,12.5],"length":37,"rects":[[87.52719116210938,756.09375,267.5615539550781,12.5]],"start":13,"text":"1. 在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析"}],"type":5,"uuid":"07605400dd28f0caaf32daed720bbc24"}],"originaltext":"逃逸分析参数设置","page":115,"textblocks":[{"first":[75.52161407470703,732.833984375,9.754531860351562,12.5],"last":[143.80332946777344,732.833984375,9.754531860351562,12.5],"length":8,"rects":[[75.52161407470703,732.833984375,78.03624725341797,12.5]],"start":4,"text":"逃逸分析参数设置"}],"type":5,"uuid":"6fad7a0da58d797b2181464705d066c6"},{"date":"2022-04-07 10:34:11","docid":0,"fillcolor":"ffffed99","folded":true,"id":652,"markups":[{"date":"2022-04-07 10:34:17","docid":0,"fillcolor":"ffffed99","id":653,"originaltext":"开发中能使用局部变量的，就不要使用在方法外定义。","page":116,"textblocks":[{"first":[75.52161407470703,98.037109375,9.754531860351562,12.5],"last":[299.8758544921875,98.037109375,9.7545166015625,12.5],"length":24,"rects":[[75.52161407470703,98.037109375,234.10875701904297,12.5]],"start":47,"text":"开发中能使用局部变量的，就不要使用在方法外定义。"}],"type":5,"uuid":"12cae99ee18141f52fea375342ca8026"}],"originaltext":"总结","page":116,"textblocks":[{"first":[75.52161407470703,74.52734375,9.754531860351562,13.5],"last":[85.2761459350586,74.52734375,9.754531860351562,13.5],"length":2,"rects":[[75.52161407470703,74.52734375,19.509063720703125,13.5]],"start":44,"text":"总结"}],"type":5,"uuid":"0c77f8656fec6a0eb57ca150950fa0fa"}],"originaltext":"逃逸分析","page":114,"textblocks":[{"first":[75.52161407470703,166.572265625,14.631797790527344,17.5],"last":[119.41700744628906,166.572265625,14.631790161132812,17.5],"length":4,"rects":[[75.52161407470703,166.572265625,58.527183532714844,17.5]],"start":311,"text":"逃逸分析"}],"type":5,"uuid":"19b4c7d09f0175a271aabee67bc450c7"},{"date":"2022-04-07 10:34:22","docid":0,"fillcolor":"ffffed99","folded":true,"id":654,"markups":[{"content":"当一个对象经过了逃逸分析，那么对象可以放在栈中，就可以不考虑GC","date":"2022-04-07 10:35:24","docid":0,"fillcolor":"ffffed99","id":658,"originaltext":"栈上分配","page":116,"textblocks":[{"first":[75.52161407470703,320.392578125,14.631797790527344,17.5],"last":[119.41700744628906,320.392578125,14.631790161132812,17.5],"length":4,"rects":[[75.52161407470703,320.392578125,58.527183532714844,17.5]],"start":307,"text":"栈上分配"}],"type":5,"uuid":"0eb017d173d55ee00651cce4cdab446f"},{"content":"当经历了逃逸分析过后，标识对象可以存放在栈中，也就是说可以不用加同步锁","date":"2022-04-07 10:36:54","docid":0,"fillcolor":"ffffed99","id":659,"originaltext":"同步省略（同步消除）","page":117,"textblocks":[{"first":[75.52161407470703,664.302734375,14.631797790527344,17.5],"last":[207.20779418945312,664.302734375,14.631805419921875,17.5],"length":10,"rects":[[75.52161407470703,664.302734375,146.31798553466797,17.5]],"start":219,"text":"同步省略（同步消除）"}],"type":5,"uuid":"6db6c81532932d9209ff3b217b75b1ff"},{"content":"经过逃逸分析后：\n对象是聚合量\n基本数据类型包括String类型是标量\n对对象直接肢解成标量\n那么这些标量会被放到栈的局部变量表中","date":"2022-04-07 10:40:22","docid":0,"fillcolor":"ffffed99","id":660,"originaltext":"标量替换","page":119,"textblocks":[{"first":[75.52161407470703,136.056640625,14.631797790527344,17.5],"last":[119.41700744628906,136.056640625,14.631790161132812,17.5],"length":4,"rects":[[75.52161407470703,136.056640625,58.527183532714844,17.5]],"start":55,"text":"标量替换"}],"type":5,"uuid":"c02260d3858b85ef79d3ce4ae44dd49b"}],"originaltext":"代码优化","page":116,"textblocks":[{"first":[75.52161407470703,145.5625,14.631797790527344,17.5],"last":[119.41700744628906,145.5625,14.631790161132812,17.5],"length":4,"rects":[[75.52161407470703,145.5625,58.527183532714844,17.5]],"start":74,"text":"代码优化"}],"type":5,"uuid":"e22b4c9a00cf6145a31495678bd88753"},{"content":"逃逸分析耗费性能","date":"2022-04-07 10:44:33","docid":0,"fillcolor":"ffffed99","id":661,"originaltext":"逃逸分析的不足","page":121,"textblocks":[{"first":[75.52161407470703,359.41015625,14.631797790527344,17.5],"last":[163.31240844726562,359.41015625,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,359.41015625,102.42259979248047,17.5]],"start":549,"text":"逃逸分析的不足"}],"type":5,"uuid":"cc86bb28063d7792bcbd4f3e1d9b6f70"}],"originaltext":"堆是分配对象的唯一选择么？","page":113,"textblocks":[{"first":[75.52161407470703,677.30859375,17.07042694091797,19.5],"last":[280.3667907714844,677.30859375,17.0704345703125,19.5],"length":13,"rects":[[75.52161407470703,677.30859375,221.91561126708984,19.5]],"start":566,"text":"堆是分配对象的唯一选择么？"}],"type":5,"uuid":"ff507615d061e6305d20b46535a2d370"}],"originaltext":"堆","page":93,"textblocks":[{"first":[75.52161407470703,84.7859115600586,21.94770050048828,25.5],"last":[75.52161407470703,84.7859115600586,21.94770050048828,25.5],"length":1,"rects":[[75.52161407470703,84.7859115600586,21.94770050048828,25.5]],"start":2,"text":"堆"}],"title":"第5章-堆","type":5},{"date":"2022-04-07 10:53:20","docid":0,"fillcolor":"ffffed99","folded":false,"id":662,"markups":[{"date":"2022-04-07 11:21:14","docid":0,"fillcolor":"ffffed99","folded":false,"id":663,"markups":[{"content":"栈中的引用指向堆中的对象，指向方法区中的类","date":"2022-04-07 11:21:49","docid":0,"fillcolor":"ffffed99","id":665,"originaltext":"对象的访问定位","page":123,"textblocks":[{"first":[124.29427337646484,458.95465087890625,9.754524230957031,12.5],"last":[182.82147216796875,458.95465087890625,9.754531860351562,12.5],"length":7,"rects":[[124.29427337646484,458.95465087890625,68.28173065185547,12.5]],"start":106,"text":"对象的访问定位"}],"type":5,"uuid":"39372c631f7e7a1329da4f1f05b1a642"}],"originaltext":"栈、堆、方法区的交互关系","page":123,"textblocks":[{"first":[75.52161407470703,122.0509033203125,17.07042694091797,19.5],"last":[263.2963562011719,122.0509033203125,17.0704345703125,19.5],"length":12,"rects":[[75.52161407470703,122.0509033203125,204.84517669677734,19.5]],"start":7,"text":"栈、堆、方法区的交互关系"}],"type":5,"uuid":"0d132784536e70018db94a83bc08f3c9"},{"date":"2022-04-07 11:25:10","docid":0,"fillcolor":"ffffed99","folded":false,"id":666,"markups":[{"date":"2022-04-07 11:25:18","docid":0,"fillcolor":"ffffed99","folded":true,"id":667,"markups":[{"date":"2022-04-07 11:25:44","docid":0,"fillcolor":"ffffed99","id":668,"originaltext":"方法区可以看作是一块独立于Java堆的内存空间","page":124,"textblocks":[{"first":[127.29566955566406,160.01585388183594,9.754531860351562,13.5],"last":[323.4389343261719,160.01585388183594,9.754547119140625,13.5],"length":23,"rects":[[127.29566955566406,160.01585388183594,205.89781188964844,13.5]],"start":224,"text":"方法区可以看作是一块独立于Java堆的内存空间"}],"type":5,"uuid":"4b8a5c7fabf44db9703824d5dec74338"}],"originaltext":"方法区在哪里？","page":124,"textblocks":[{"first":[75.52161407470703,85.48307800292969,14.631797790527344,18.5],"last":[163.31240844726562,85.48307800292969,14.631805419921875,18.5],"length":7,"rects":[[75.52161407470703,85.48307800292969,102.42259979248047,18.5]],"start":87,"text":"方法区在哪里？"}],"type":5,"uuid":"7fc31236e105a2c4a2869ab07f73a3db"},{"date":"2022-04-07 11:25:53","docid":0,"fillcolor":"ffffed99","folded":false,"id":669,"markups":[{"content":"来只能加载一次，加载到方法区中，当多个线程要将类加载到方法区中的时候，只有一个线程会进行加载，其他线程等待，最后使用的时候多个线程都能进行使用","date":"2022-04-07 11:26:56","docid":0,"fillcolor":"ffffed99","id":670,"originaltext":"方法区主要存放的是 Class，而堆中主要存放的是实例化的对象","page":124,"textblocks":[{"first":[75.52161407470703,413.93365478515625,9.754531860351562,12.5],"last":[336.9459228515625,413.93365478515625,9.7545166015625,12.5],"length":31,"rects":[[75.52161407470703,413.93365478515625,271.17882537841797,12.5]],"start":261,"text":"方法区主要存放的是 Class，而堆中主要存放的是实例化的对象"}],"type":5,"uuid":"ba9fea9aa892e8f818be3e6f8bcc17cc"}],"originaltext":"方法区的基本理解","page":124,"textblocks":[{"first":[75.52161407470703,383.42181396484375,14.631797790527344,17.5],"last":[177.94419860839844,383.42181396484375,14.631790161132812,17.5],"length":8,"rects":[[75.52161407470703,383.42181396484375,117.05437469482422,17.5]],"start":251,"text":"方法区的基本理解"}],"type":5,"uuid":"392e6b3a4f66d70b7512e5760d0dcfbd"},{"content":"1、jdk8使用元空间代替永久代","date":"2022-04-07 11:31:42","docid":0,"fillcolor":"ffffed99","id":671,"markups":[{"date":"2022-04-07 11:36:41","docid":0,"fillcolor":"ffffed99","id":672,"originaltext":"元空间不在虚拟机设置的内存中，而是使用本地内存。","page":126,"textblocks":[{"first":[117.5411376953125,44.76220703125,9.754531860351562,12.5],"last":[341.8953857421875,44.76220703125,9.7545166015625,12.5],"length":24,"rects":[[117.5411376953125,44.76220703125,234.1087646484375,12.5]],"start":50,"text":"元空间不在虚拟机设置的内存中，而是使用本地内存。"}],"type":5,"uuid":"8d0539aff218a7b7f388f3ce58afb2f2"}],"originaltext":"HotSpot方法区演进","page":125,"textblocks":[{"first":[75.52161407470703,609.1768798828125,11.193321228027344,19.5],"last":[193.38331604003906,609.1768798828125,14.631790161132812,19.5],"length":12,"rects":[[75.52161407470703,609.1768798828125,132.49349212646484,19.5]],"start":21,"text":"HotSpot方法区演进"}],"type":5,"uuid":"1645375633985c54b2272c58dbb7fff7"}],"originaltext":"方法区的理解","page":124,"textblocks":[{"first":[75.52161407470703,29.00762939453125,17.07042694091797,19.5],"last":[160.87376403808594,29.00762939453125,17.0704345703125,19.5],"length":6,"rects":[[75.52161407470703,29.00762939453125,102.4225845336914,19.5]],"start":0,"text":"方法区的理解"}],"type":5,"uuid":"c1f357e0261c4c6fb4ed3948c1894b3f"},{"date":"2022-04-07 11:38:23","docid":0,"fillcolor":"ffffed99","folded":true,"id":673,"markups":[{"content":"用的Java的内存\n初始20.75m\n有限制默认32位64m，64位82m","date":"2022-04-07 11:49:48","docid":0,"fillcolor":"ffffed99","id":675,"originaltext":"JDK7及以前(永久代)","page":126,"textblocks":[{"first":[75.52161407470703,432.89459228515625,4.8431243896484375,18.5],"last":[202.0137939453125,432.89459228515625,4.960174560546875,18.5],"length":12,"rects":[[75.52161407470703,432.89459228515625,131.45235443115234,18.5]],"start":200,"text":"JDK7及以前(永久代)"}],"type":5,"uuid":"7b3dcc7dcc76f76fe16c29a631284a47"},{"content":"元空间用的是本地内存初始21m，没有限制\n如果放置的类达到了21m会触发FullGC\n然后是释放的空间查看是否需要进行重置高水位线\n如果释放空间后可以存储对象，那么就不会升高，甚至进行降低\n如果释放后还是存储不下那么就会升高水位线","date":"2022-04-07 11:49:39","docid":0,"fillcolor":"ffffed99","id":674,"originaltext":"JDK8及以后(元空间)","page":127,"textblocks":[{"first":[75.52161407470703,32.25732421875,4.8431243896484375,16.5],"last":[202.0137939453125,32.25732421875,4.960174560546875,16.5],"length":12,"rects":[[75.52161407470703,32.25732421875,131.45235443115234,16.5]],"start":0,"text":"JDK8及以后(元空间)"}],"type":5,"uuid":"63f26d20f4107ebf1c0be06fd8eeea02"},{"date":"2022-04-07 11:51:23","docid":0,"fillcolor":"ffffed99","id":676,"originaltext":"方法区OOM","page":127,"textblocks":[{"first":[75.52161407470703,311.3876953125,14.631797790527344,17.5],"last":[142.71083068847656,311.3876953125,13.79779052734375,17.5],"length":6,"rects":[[75.52161407470703,311.3876953125,80.98700714111328,17.5]],"start":606,"text":"方法区OOM"}],"type":5,"uuid":"f1aad8568bc4e74fcc6596c1e3905ed0"},{"content":"1、分析到底是内存泄漏还是内存溢出\n2、内存泄漏就是对象不用，但是引用被使用，导致不能回收","date":"2022-04-07 11:57:21","docid":0,"fillcolor":"ffffed99","id":677,"originaltext":"如何解决OOM","page":128,"textblocks":[{"first":[75.52161407470703,438.14703369140625,14.631797790527344,18.5],"last":[157.34263610839844,438.14703369140625,13.79779052734375,18.5],"length":7,"rects":[[75.52161407470703,438.14703369140625,95.61881256103516,18.5]],"start":113,"text":"如何解决OOM"}],"type":5,"uuid":"482c41275af1ffa9ab5f18e53d13b0c0"}],"originaltext":"设置方法区大小与 OOM","page":126,"textblocks":[{"first":[75.52161407470703,376.5191955566406,17.07042694091797,20.5],"last":[243.69949340820312,376.5191955566406,16.097412109375,20.5],"length":12,"rects":[[75.52161407470703,376.5191955566406,184.2752914428711,20.5]],"start":155,"text":"设置方法区大小与 OOM"}],"type":5,"uuid":"4bca96c54fb48dcb25689f52b59aeae9"},{"date":"2022-04-07 12:00:12","docid":0,"fillcolor":"ffffed99","folded":false,"id":678,"markups":[{"content":"1、类型信息\n2、域信息\n3、 方法信息\n其他的还存在类加载器的信息classLoader\n而classLoader也记载了加载了哪个类","date":"2022-04-08 10:01:58","docid":0,"fillcolor":"ffffed99","folded":true,"id":679,"markups":[{"content":"存储的类信心","date":"2022-04-08 10:02:05","docid":0,"fillcolor":"ffffed99","id":680,"markups":[{"content":"1、全限定类名\n2、父类的类名\n3、修饰符\n4、实现的接口","date":"2022-04-08 10:02:35","docid":0,"fillcolor":"ffffed99","id":682,"originaltext":"类型信息","page":129,"textblocks":[{"first":[75.52161407470703,491.97021484375,9.754531860351562,12.5],"last":[104.78520965576172,491.97021484375,9.754531860351562,12.5],"length":4,"rects":[[75.52161407470703,491.97021484375,39.01812744140625,12.5]],"start":90,"text":"类型信息"}],"type":5,"uuid":"3b2be9fadebedfebab9689c28bd434a6"},{"content":"其实就是属性，将类中属性的名称、类型、修饰符存储","date":"2022-04-08 10:07:48","docid":0,"fillcolor":"ffffed99","id":683,"originaltext":"域（Field）信息","page":129,"textblocks":[{"first":[75.52161407470703,619.9797973632812,9.754531860351562,13.5],"last":[137.782958984375,619.9797973632812,9.754531860351562,13.5],"length":10,"rects":[[75.52161407470703,619.9797973632812,72.01587677001953,13.5]],"start":304,"text":"域（Field）信息"}],"type":5,"uuid":"140784e0fee10ddd8130dda29791fe8a"},{"date":"2022-04-08 10:08:45","docid":0,"fillcolor":"ffffed99","folded":true,"id":684,"markups":[{"date":"2022-04-08 17:00:49","docid":0,"fillcolor":"ffffed99","id":686,"originaltext":"1. 方法名称","page":129,"textblocks":[{"first":[87.52719116210938,764.3466796875,5.57958984375,13.5],"last":[127.29566955566406,764.3466796875,9.754531860351562,13.5],"length":7,"rects":[[87.52719116210938,764.3466796875,49.52301025390625,13.5]],"start":509,"text":"1. 方法名称"}],"type":5,"uuid":"770ed38fbd96049b07477b01a2f77757"},{"date":"2022-04-08 17:00:53","docid":0,"fillcolor":"ffffed99","id":687,"originaltext":"2. 方法的返回类型","page":129,"textblocks":[{"first":[87.52719116210938,779.0535278320312,5.57958984375,13.5],"last":[156.55926513671875,779.0535278320312,9.754531860351562,13.5],"length":10,"rects":[[87.52719116210938,779.0535278320312,78.78660583496094,13.5]],"start":517,"text":"2. 方法的返回类型"}],"type":5,"uuid":"bed58e2de1bdfa3ea1b4fde2e99b55be"},{"date":"2022-04-08 17:00:57","docid":0,"fillcolor":"ffffed99","id":688,"originaltext":"3. 方法参数的数量和类型","page":129,"textblocks":[{"first":[87.52719116210938,794.3603515625,5.57958984375,13.5],"last":[185.82286071777344,794.3603515625,9.754531860351562,13.5],"length":13,"rects":[[87.52719116210938,794.3603515625,108.05020141601562,13.5]],"start":571,"text":"3. 方法参数的数量和类型"}],"type":5,"uuid":"dd774b6540bb8f711a57a5f698e5237d"},{"date":"2022-04-08 17:01:01","docid":0,"fillcolor":"ffffed99","id":689,"originaltext":"4. 方法的修饰符","page":130,"textblocks":[{"first":[87.52719116210938,29.455371856689453,5.57958984375,13.5],"last":[146.8047332763672,29.455371856689453,9.754531860351562,13.5],"length":9,"rects":[[87.52719116210938,29.455371856689453,69.03207397460938,13.5]],"start":0,"text":"4. 方法的修饰符"}],"type":5,"uuid":"d392e4065d2909c74aadd72befbd526b"},{"date":"2022-04-08 17:01:06","docid":0,"fillcolor":"ffffed99","id":690,"originaltext":"5. 方法的字节码","page":130,"textblocks":[{"first":[87.52719116210938,59.76904296875,5.57958984375,12.5],"last":[146.8047332763672,59.76904296875,9.754531860351562,12.5],"length":9,"rects":[[87.52719116210938,59.76904296875,69.03207397460938,12.5]],"start":84,"text":"5. 方法的字节码"}],"type":5,"uuid":"da735b0b309b76e83c4845eeedaf69f3"},{"date":"2022-04-08 17:01:11","docid":0,"fillcolor":"ffffed99","id":691,"originaltext":"6. 异常表","page":130,"textblocks":[{"first":[87.52719116210938,74.77587890625,5.57958984375,12.5],"last":[117.5411376953125,74.77587890625,9.754531860351562,12.5],"length":6,"rects":[[87.52719116210938,74.77587890625,39.76847839355469,12.5]],"start":140,"text":"6. 异常表"}],"type":5,"uuid":"069c58a9b90632a92cde5a39f86a2178"}],"originaltext":"方法（Method）信息","page":129,"textblocks":[{"first":[75.52161407470703,719.0256958007812,9.754531860351562,13.5],"last":[162.1121368408203,719.0256958007812,9.754531860351562,13.5],"length":12,"rects":[[75.52161407470703,719.0256958007812,96.34505462646484,13.5]],"start":465,"text":"方法（Method）信息"}],"type":5,"uuid":"6dfda7d839495ceeed1a4e02ec4ff9a2"}],"originaltext":"概念","page":129,"textblocks":[{"first":[75.52161407470703,29.255859375,12.193168640136719,15.5],"last":[87.71477508544922,29.255859375,12.193168640136719,15.5],"length":2,"rects":[[75.52161407470703,29.255859375,24.386329650878906,15.5]],"start":0,"text":"概念"}],"type":5,"uuid":"6da66061a9decfe325cdf4524b567fb4"}],"originaltext":"方法区存储什么？","page":128,"textblocks":[{"first":[75.52161407470703,710.573486328125,14.631797790527344,17.5],"last":[177.94419860839844,710.573486328125,14.631790161132812,17.5],"length":8,"rects":[[75.52161407470703,710.573486328125,117.05437469482422,17.5]],"start":668,"text":"方法区存储什么？"}],"type":5,"uuid":"a6b18b46554776e82722aa38738264b5"},{"date":"2022-04-08 17:04:17","docid":0,"fillcolor":"ffffed99","folded":true,"id":692,"markups":[{"date":"2022-04-08 17:04:54","docid":0,"fillcolor":"ffffed99","id":693,"originaltext":"1. 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分","page":136,"textblocks":[{"first":[87.52719116210938,708.0693359375,5.57958984375,12.5],"last":[449.1952209472656,708.0693359375,9.754547119140625,12.5],"length":40,"rects":[[87.52719116210938,708.0693359375,371.4225769042969,12.5]],"start":219,"text":"1. 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分"}],"type":5,"uuid":"c7dc94a6b3da7d28edc24c281c40de49"},{"date":"2022-04-08 17:04:58","docid":0,"fillcolor":"ffffed99","id":694,"originaltext":"2. 类变量被类的所有实例共享，即使没有类实例时，你也可以访问它","page":136,"textblocks":[{"first":[87.52719116210938,723.0771484375,5.57958984375,12.5],"last":[371.1589660644531,723.0771484375,9.754547119140625,12.5],"length":32,"rects":[[87.52719116210938,723.0771484375,293.3863220214844,12.5]],"start":260,"text":"2. 类变量被类的所有实例共享，即使没有类实例时，你也可以访问它"}],"type":5,"uuid":"0d2eb19a3a0d6205b88c05bc14b361c4"},{"content":"在编译期间就分配好了","date":"2022-04-08 17:09:43","docid":0,"fillcolor":"ffffed99","folded":true,"id":695,"markups":[{"date":"2022-04-08 17:09:52","docid":0,"fillcolor":"ffffed99","id":696,"originaltext":"1. 全局常量就是使用 static final 进行修饰","page":137,"textblocks":[{"first":[87.52719116210938,436.14434814453125,5.57958984375,13.5],"last":[256.66229248046875,436.14434814453125,9.7545166015625,13.5],"length":29,"rects":[[87.52719116210938,436.14434814453125,178.88961791992188,13.5]],"start":73,"text":"1. 全局常量就是使用 static final 进行修饰"}],"type":5,"uuid":"9f4f21a8e76f821e62216127f7546de8"},{"date":"2022-04-08 17:10:00","docid":0,"fillcolor":"ffffed99","id":697,"originaltext":"2. 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。","page":137,"textblocks":[{"first":[87.52719116210938,451.15118408203125,5.57958984375,13.5],"last":[459.0926513671875,451.15118408203125,9.7545166015625,13.5],"length":44,"rects":[[87.52719116210938,451.15118408203125,381.3199768066406,13.5]],"start":103,"text":"2. 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。"}],"type":5,"uuid":"aea9cd6d16cf3d3c7927ca292a36caa4"}],"originaltext":"全局常量：static final","page":137,"textblocks":[{"first":[75.52161407470703,410.5826110839844,12.193168640136719,14.5],"last":[197.46548461914062,410.5826110839844,3.7189178466796875,14.5],"length":17,"rects":[[75.52161407470703,410.5826110839844,125.66278839111328,14.5]],"start":54,"text":"全局常量：static final"}],"type":5,"uuid":"842778663e6e0766ad739d8b8133c0db"}],"originaltext":"non-final 类型的类变量","page":136,"textblocks":[{"first":[75.52161407470703,656.5478515625,9.613090515136719,17.5],"last":[218.53172302246094,656.5478515625,14.631790161132812,17.5],"length":16,"rects":[[75.52161407470703,656.5478515625,157.64189910888672,17.5]],"start":199,"text":"non-final 类型的类变量"}],"type":5,"uuid":"e11256336a5d453c003dbc7daaeb4d11"},{"date":"2022-04-08 17:10:38","docid":0,"fillcolor":"ffffed99","id":698,"markups":[{"date":"2022-04-08 17:12:06","docid":0,"fillcolor":"ffffed99","id":699,"originaltext":"运行时常量池 VS 常量池","page":138,"textblocks":[{"first":[75.52161407470703,59.26953125,12.193168640136719,15.5],"last":[194.0417938232422,59.26953125,12.193161010742188,15.5],"length":13,"rects":[[75.52161407470703,59.26953125,130.71334075927734,15.5]],"start":8,"text":"运行时常量池 VS 常量池"}],"type":5,"uuid":"7c061d3a1185aa109310184b95635b05"},{"content":"常量池指的就是字节码文件中的常量池表部分的字节码","date":"2022-04-08 17:13:26","docid":0,"fillcolor":"ffffed99","folded":true,"id":700,"markups":[{"content":"数据的支持需要常量池","date":"2022-04-12 19:45:33","docid":0,"fillcolor":"ffffed99","id":701,"originaltext":"为什么需要常量池？","page":139,"textblocks":[{"first":[75.52161407470703,254.859375,9.754531860351562,12.5],"last":[153.557861328125,254.859375,9.754531860351562,12.5],"length":9,"rects":[[75.52161407470703,254.859375,87.79077911376953,12.5]],"start":0,"text":"为什么需要常量池？"}],"type":5,"uuid":"1c86eb0eafa56b6ec9929dcce65c7b34"},{"content":"引用变量以及基础数据类型包含Strinag","date":"2022-04-12 19:47:10","docid":0,"fillcolor":"ffffed99","id":702,"originaltext":"常量池中有啥？","page":139,"textblocks":[{"first":[75.52161407470703,612.5263671875,9.754531860351562,13.5],"last":[134.04879760742188,612.5263671875,9.754531860351562,13.5],"length":7,"rects":[[75.52161407470703,612.5263671875,68.2817153930664,13.5]],"start":373,"text":"常量池中有啥？"}],"type":5,"uuid":"fbccc71a245bbd8cc23b5a35795eabba"},{"date":"2022-04-12 19:47:40","docid":0,"fillcolor":"ffffed99","id":703,"originaltext":"常量池总结","page":140,"textblocks":[{"first":[75.52161407470703,274.369140625,9.754531860351562,12.5],"last":[114.53974151611328,274.369140625,9.754531860351562,12.5],"length":5,"rects":[[75.52161407470703,274.369140625,48.77265930175781,12.5]],"start":28,"text":"常量池总结"}],"type":5,"uuid":"6bb41ba036eaf8a5b12736541eebdae5"}],"originaltext":"常量池","page":138,"textblocks":[{"first":[75.52161407470703,519.9833984375,12.193168640136719,15.5],"last":[99.90794372558594,519.9833984375,12.193161010742188,15.5],"length":3,"rects":[[75.52161407470703,519.9833984375,36.579490661621094,15.5]],"start":285,"text":"常量池"}],"type":5,"uuid":"00f4f23e11f14a71b0b03e0937cf4761"},{"content":"1、当常量池真正读取后存在于方法区中就是运行时常量池\n2、与常量池的不同就在于其中的符号引用变化成直接引用","date":"2022-04-12 19:47:49","docid":0,"fillcolor":"ffffed99","id":704,"originaltext":"运行时常量池","page":140,"textblocks":[{"first":[75.52161407470703,358.4091796875,12.193168640136719,15.5],"last":[136.48744201660156,358.4091796875,12.193161010742188,15.5],"length":6,"rects":[[75.52161407470703,358.4091796875,73.15898895263672,15.5]],"start":88,"text":"运行时常量池"}],"type":5,"uuid":"6e37ae9739c54e35da12ecb6e4f95b1c"}],"originaltext":"运行时常量池","page":138,"textblocks":[{"first":[75.52161407470703,30.2568359375,14.631797790527344,17.5],"last":[148.68060302734375,30.2568359375,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,30.2568359375,87.7907943725586,17.5]],"start":0,"text":"运行时常量池"}],"type":5,"uuid":"20614470535f01c35a0600b00ca5c45b"}],"originaltext":"方法区的内部结构","page":128,"textblocks":[{"first":[75.52161407470703,678.559814453125,17.07042694091797,20.5],"last":[195.01463317871094,678.559814453125,17.0704345703125,20.5],"length":8,"rects":[[75.52161407470703,678.559814453125,136.5634536743164,20.5]],"start":658,"text":"方法区的内部结构"}],"type":5,"uuid":"b66671cd2cb7de721483ec08b47f8656"},{"date":"2022-04-12 20:00:27","docid":0,"fillcolor":"ffffed99","id":705,"originaltext":"方法区的使用举例","page":140,"textblocks":[{"first":[75.52161407470703,642.54296875,17.07042694091797,20.5],"last":[195.01463317871094,642.54296875,17.0704345703125,20.5],"length":8,"rects":[[75.52161407470703,642.54296875,136.5634536743164,20.5]],"start":613,"text":"方法区的使用举例"}],"type":5,"uuid":"e2a752991764e4af3c49f584f54dcbb4"},{"date":"2022-04-12 20:12:40","docid":0,"fillcolor":"ffffed99","folded":false,"id":706,"markups":[{"date":"2022-04-12 20:12:44","docid":0,"fillcolor":"ffffed99","id":707,"originaltext":"永久代演进过程","page":151,"textblocks":[{"first":[75.52161407470703,30.2578125,14.631797790527344,17.5],"last":[163.31240844726562,30.2578125,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,30.2578125,102.42259979248047,17.5]],"start":151,"text":"永久代演进过程"}],"type":5,"uuid":"e759e13c0d53694f26786f9423af223e"},{"date":"2022-04-12 20:12:56","docid":0,"fillcolor":"ffffed99","folded":true,"id":708,"markups":[{"content":"加载的类无法确定，创建小了，出现FULLGC导致STW","date":"2022-04-15 16:33:12","docid":0,"fillcolor":"ffffed99","id":711,"originaltext":"1. 为永久代设置空间大小是很难确定的。","page":152,"textblocks":[{"first":[110.03765106201172,714.57421875,5.57958984375,13.5],"last":[276.61505126953125,714.57421875,9.7545166015625,13.5],"length":20,"rects":[[110.03765106201172,714.57421875,176.33191680908203,13.5]],"start":249,"text":"1. 为永久代设置空间大小是很难确定的。"}],"type":5,"uuid":"807e4a3fe279bb42a643377855f2b980"},{"content":"优化困难","date":"2022-04-15 16:33:29","docid":0,"fillcolor":"ffffed99","id":712,"originaltext":"2. 对永久代进行调优是很困难的。","page":153,"textblocks":[{"first":[110.03765106201172,29.755859375,5.57958984375,12.5],"last":[247.35145568847656,29.755859375,9.754531860351562,12.5],"length":17,"rects":[[110.03765106201172,29.755859375,147.0683364868164,12.5]],"start":0,"text":"2. 对永久代进行调优是很困难的。"}],"type":5,"uuid":"62f381cda197c1868edd9288dff64ac0"}],"originaltext":"永久代为什么要被元空间替代？","page":152,"textblocks":[{"first":[75.52161407470703,566.0078125,14.631797790527344,17.5],"last":[265.7349853515625,566.0078125,14.631805419921875,17.5],"length":14,"rects":[[75.52161407470703,566.0078125,204.84517669677734,17.5]],"start":31,"text":"永久代为什么要被元空间替代？"}],"type":5,"uuid":"8577c44a8e365a4da1e09988bd5df8ee"},{"date":"2022-04-12 20:13:12","docid":0,"fillcolor":"ffffed99","folded":true,"id":709,"markups":[{"content":"因为StringTable放在方法区中，只有永久代空间不足的时候才会触发FullGC进行垃圾回收，放到堆中回收效率较高","date":"2022-04-12 20:13:17","docid":0,"fillcolor":"ffffed99","id":710,"originaltext":"字符串常量池 StringTable 为什么要调整位置？","page":153,"textblocks":[{"first":[75.52161407470703,231.24960327148438,9.754531860351562,14.5],"last":[272.541259765625,231.24960327148438,9.7545166015625,14.5],"length":28,"rects":[[75.52161407470703,231.24960327148438,206.77416229248047,14.5]],"start":370,"text":"字符串常量池 StringTable 为什么要调整位置？"}],"type":5,"uuid":"461bde7de96ac1d19eb95373d0602618"}],"originaltext":"字符串常量池","page":153,"textblocks":[{"first":[75.52161407470703,202.837890625,14.631797790527344,17.5],"last":[148.68060302734375,202.837890625,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,202.837890625,87.7907943725586,17.5]],"start":362,"text":"字符串常量池"}],"type":5,"uuid":"90a40dd3a1df2f61f6dfdfdc1524f186"},{"date":"2022-04-15 16:42:24","docid":0,"fillcolor":"ffffed99","folded":true,"id":713,"markups":[{"content":"1、创建的对象都放在堆中\n2、引用存放在不同的地方","date":"2022-04-15 16:46:21","docid":0,"fillcolor":"ffffed99","id":714,"originaltext":"对象实体在哪里放着？","page":153,"textblocks":[{"first":[75.52161407470703,354.158203125,12.193168640136719,15.5],"last":[185.26010131835938,354.158203125,12.193161010742188,15.5],"length":10,"rects":[[75.52161407470703,354.158203125,121.93164825439453,15.5]],"start":573,"text":"对象实体在哪里放着？"}],"type":5,"uuid":"f23a0d2022d324879908a7e58949389c"},{"date":"2022-04-15 16:53:33","docid":0,"fillcolor":"ffffed99","folded":false,"id":715,"markups":[{"content":"1.6情况下变量名放在方法区中也就是永久代实现，这个时候StringTable也放在了方法区永久代中\n实际的空间存储在堆空间中\n\n1.7、1.8情况下静态变量名和实际存储空间放在堆空间中，StringTbale也在其中\n只不过1.8情况下永久代正式叛逃jvm虚拟机只留下职位，更名为元空间","date":"2022-04-15 16:54:00","docid":0,"fillcolor":"ffffed99","id":716,"originaltext":"JDK6环境下","page":155,"textblocks":[{"first":[75.52161407470703,208.0398406982422,3.2287521362304688,13.5],"last":[117.52611541748047,208.0398406982422,9.754531860351562,13.5],"length":7,"rects":[[75.52161407470703,208.0398406982422,51.759033203125,13.5]],"start":0,"text":"JDK6环境下"}],"type":5,"uuid":"e46aa56bd0a41876b8b83b09175a6e06"}],"originaltext":"变量(名)存放在哪里？","page":154,"textblocks":[{"first":[75.52161407470703,545.5980224609375,12.193168640136719,15.5],"last":[181.33065795898438,545.5980224609375,12.193161010742188,15.5],"length":11,"rects":[[75.52161407470703,545.5980224609375,118.00220489501953,15.5]],"start":17,"text":"变量(名)存放在哪里？"}],"type":5,"uuid":"e1653173ee36d7a4beedeb4ad95df340"}],"originaltext":"静态变量放在哪里","page":153,"textblocks":[{"first":[75.52161407470703,325.14453125,14.631797790527344,17.5],"last":[177.94419860839844,325.14453125,14.631790161132812,17.5],"length":8,"rects":[[75.52161407470703,325.14453125,117.05437469482422,17.5]],"start":563,"text":"静态变量放在哪里"}],"type":5,"uuid":"6349211df11ad1510e8d508cb2628013"}],"originaltext":"方法区演进细节","page":150,"textblocks":[{"first":[75.52161407470703,693.068359375,17.07042694091797,19.5],"last":[177.94419860839844,693.068359375,17.0704345703125,19.5],"length":7,"rects":[[75.52161407470703,693.068359375,119.4930191040039,19.5]],"start":161,"text":"方法区演进细节"}],"type":5,"uuid":"0e7ea256da09d90cf9f7f19f97fc69a8"},{"content":"因为类的信息都会存在于方法区中，所以需要收集类的垃圾的时候我们称为类的卸载","date":"2022-04-15 16:58:06","docid":0,"fillcolor":"ffffed99","folded":true,"id":717,"markups":[{"date":"2022-04-15 17:03:02","docid":0,"fillcolor":"ffffed99","folded":true,"id":718,"markups":[{"date":"2022-04-15 17:03:13","docid":0,"fillcolor":"ffffed99","folded":true,"id":719,"markups":[{"date":"2022-04-15 17:03:25","docid":0,"fillcolor":"ffffed99","folded":true,"id":721,"markups":[{"date":"2022-04-15 17:03:32","docid":0,"fillcolor":"ffffed99","id":722,"originaltext":"字面量","page":156,"textblocks":[{"first":[332.1408386230469,203.0859375,9.754547119140625,12.5],"last":[351.64990234375,203.0859375,9.7545166015625,12.5],"length":3,"rects":[[332.1408386230469,203.0859375,29.263580322265625,12.5]],"start":355,"text":"字面量"}],"type":5,"uuid":"b86a854601be38c4d5f0bd65ef828d39"},{"date":"2022-04-15 17:03:34","docid":0,"fillcolor":"ffffed99","id":723,"originaltext":"符号引用","page":156,"textblocks":[{"first":[371.1589660644531,203.0859375,9.754547119140625,12.5],"last":[400.4225769042969,203.0859375,9.754547119140625,12.5],"length":4,"rects":[[371.1589660644531,203.0859375,39.018157958984375,12.5]],"start":359,"text":"符号引用"}],"type":5,"uuid":"eeb8ec5d3e2d8f8e9e27073be778c8fe"}],"originaltext":"两大类常量","page":156,"textblocks":[{"first":[273.6136474609375,203.0859375,9.7545166015625,12.5],"last":[312.63177490234375,203.0859375,9.7545166015625,12.5],"length":5,"rects":[[273.6136474609375,203.0859375,48.77264404296875,12.5]],"start":349,"text":"两大类常量"}],"type":5,"uuid":"6e4e1bddd26bd8395a0b6fadd0b03152"}],"originaltext":"常量池中废弃的常量","page":156,"textblocks":[{"first":[273.6136474609375,134.8046875,9.7545166015625,12.5],"last":[351.64990234375,134.8046875,9.7545166015625,12.5],"length":9,"rects":[[273.6136474609375,134.8046875,87.790771484375,12.5]],"start":305,"text":"常量池中废弃的常量"}],"type":5,"uuid":"5ca527f16c3ad157de7818862fd04d4c"},{"date":"2022-04-15 17:03:15","docid":0,"fillcolor":"ffffed99","folded":true,"id":720,"markups":[{"content":"满足条件的情况下也只是可能被回收","date":"2022-04-15 17:06:38","docid":0,"fillcolor":"ffffed99","folded":true,"id":724,"markups":[{"date":"2022-04-15 17:06:45","docid":0,"fillcolor":"ffffed99","folded":true,"id":725,"markups":[{"date":"2022-04-15 17:06:52","docid":0,"fillcolor":"ffffed99","id":726,"originaltext":"该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。","page":156,"textblocks":[{"first":[98.03207397460938,438.447265625,9.754531860351562,13.5],"last":[457.7828369140625,438.447265625,9.7545166015625,13.5],"length":40,"rects":[[98.03207397460938,438.447265625,369.5052795410156,13.5]],"start":649,"text":"该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。"}],"type":5,"uuid":"b6b8b82e823e60f3b16fe4e80a6e55ed"},{"date":"2022-04-15 17:07:05","docid":0,"fillcolor":"ffffed99","id":727,"originaltext":"加载该类的类加载器已经被回收，","page":156,"textblocks":[{"first":[98.03207397460938,453.453125,9.754531860351562,13.5],"last":[234.59552001953125,453.453125,9.754531860351562,13.5],"length":15,"rects":[[98.03207397460938,453.453125,146.31797790527344,13.5]],"start":690,"text":"加载该类的类加载器已经被回收，"}],"type":5,"uuid":"d3fb29321729b04a4640041c4aa1468d"},{"date":"2022-04-15 17:07:11","docid":0,"fillcolor":"ffffed99","id":728,"originaltext":"该类对应的java.lang.Class对象没有在任何地方被引用，","page":156,"textblocks":[{"first":[98.03207397460938,483.466796875,9.754531860351562,13.5],"last":[329.830810546875,483.466796875,9.7545166015625,13.5],"length":33,"rects":[[98.03207397460938,483.466796875,241.55325317382812,13.5]],"start":758,"text":"该类对应的java.lang.Class对象没有在任何地方被引用，"}],"type":5,"uuid":"237a39f790be067c55a0acda5c0dd203"}],"originaltext":"满足下面三个条件","page":156,"textblocks":[{"first":[153.557861328125,415.88555908203125,9.754531860351562,13.5],"last":[221.839599609375,415.88555908203125,9.754531860351562,13.5],"length":8,"rects":[[153.557861328125,415.88555908203125,78.03627014160156,13.5]],"start":639,"text":"满足下面三个条件"}],"type":5,"uuid":"798bd132e46c15ba776616e628dd0200"}],"originaltext":"类卸载","page":156,"textblocks":[{"first":[124.29427337646484,378.66796875,9.754524230957031,12.5],"last":[143.80332946777344,378.66796875,9.754531860351562,12.5],"length":3,"rects":[[124.29427337646484,378.66796875,29.263587951660156,12.5]],"start":578,"text":"类卸载"}],"type":5,"uuid":"9a18a99d2a56dc6396f1b7993fb4c797"}],"originaltext":"不再使用的类型","page":156,"textblocks":[{"first":[371.1589660644531,134.8046875,9.754547119140625,12.5],"last":[429.6861572265625,134.8046875,9.7545166015625,12.5],"length":7,"rects":[[371.1589660644531,134.8046875,68.28170776367188,12.5]],"start":315,"text":"不再使用的类型"}],"type":5,"uuid":"9be407cf0e65b660767acb08eb09db5a"}],"originaltext":" 方法区的垃圾收集主要回收两部分内容","page":156,"textblocks":[{"first":[95.37433624267578,134.8046875,2.5361785888671875,12.5],"last":[254.10458374023438,134.8046875,9.754547119140625,12.5],"length":18,"rects":[[95.37433624267578,134.8046875,168.48479461669922,12.5]],"start":286,"text":" 方法区的垃圾收集主要回收两部分内容"}],"type":5,"uuid":"8470c3328d4e9e799fe5ad73d33b389a"}],"originaltext":"方法区的垃圾回收","page":155,"textblocks":[{"first":[75.52161407470703,738.837890625,17.07042694091797,19.5],"last":[195.01463317871094,738.837890625,17.0704345703125,19.5],"length":8,"rects":[[75.52161407470703,738.837890625,136.5634536743164,19.5]],"start":606,"text":"方法区的垃圾回收"}],"type":5,"uuid":"460d26b93a7f127874ede2f3b1008fff"},{"date":"2022-04-15 17:09:30","docid":0,"fillcolor":"ffffed99","id":729,"originaltext":"运行时数据区总结","page":156,"textblocks":[{"first":[75.52161407470703,654.048828125,17.07042694091797,19.5],"last":[195.01463317871094,654.048828125,17.0704345703125,19.5],"length":8,"rects":[[75.52161407470703,654.048828125,136.5634536743164,19.5]],"start":1107,"text":"运行时数据区总结"}],"type":5,"uuid":"e8125c579c4ccd285813e68e65454978"},{"date":"2022-04-15 17:14:01","docid":0,"fillcolor":"ffffed99","folded":true,"id":730,"markups":[{"content":"一般访问直接内存的速度比访问堆的速度高","date":"2022-04-15 17:14:06","docid":0,"fillcolor":"ffffed99","id":731,"originaltext":"直接内存概述","page":157,"textblocks":[{"first":[75.52161407470703,319.892578125,14.631797790527344,17.5],"last":[148.68060302734375,319.892578125,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,319.892578125,87.7907943725586,17.5]],"start":8,"text":"直接内存概述"}],"type":5,"uuid":"4cbdc09195fa7edf28d1e8e19b8a4135"},{"date":"2022-04-15 17:14:47","docid":0,"fillcolor":"ffffed99","folded":true,"id":732,"markups":[{"date":"2022-04-15 17:15:06","docid":0,"fillcolor":"ffffed99","id":733,"originaltext":"非直接缓存区（BIO）","page":158,"textblocks":[{"first":[75.52161407470703,345.654296875,9.754531860351562,12.5],"last":[161.35006713867188,345.654296875,9.754531860351562,12.5],"length":11,"rects":[[75.52161407470703,345.654296875,95.5829849243164,12.5]],"start":28,"text":"非直接缓存区（BIO）"}],"type":5,"uuid":"e5b7e992dcfb10159a4daf74e64c7cda"},{"content":"直接没有内核空间和用户空间的转换\n直接通过一个物理内存转换数据","date":"2022-04-15 17:15:30","docid":0,"fillcolor":"ffffed99","id":734,"originaltext":"直接缓冲区（NIO）","page":158,"textblocks":[{"first":[75.52161407470703,622.9832153320312,9.754531860351562,13.5],"last":[152.97203063964844,622.9832153320312,9.754531860351562,13.5],"length":10,"rects":[[75.52161407470703,622.9832153320312,87.20494842529297,13.5]],"start":75,"text":"直接缓冲区（NIO）"}],"type":5,"uuid":"7ff04e40ff56cf271c8e44651d9ade9e"}],"originaltext":"BIO 与 NIO","page":158,"textblocks":[{"first":[75.52161407470703,318.142578125,9.832565307617188,13.5],"last":[140.8173828125,318.142578125,11.64691162109375,13.5],"length":9,"rects":[[75.52161407470703,318.142578125,76.94268035888672,13.5]],"start":17,"text":"BIO 与 NIO"}],"type":5,"uuid":"84a345fc65599bb4d0e774ec40fa7e63"},{"content":"存在OOM，回收成本高","date":"2022-04-15 17:17:47","docid":0,"fillcolor":"ffffed99","id":735,"originaltext":"直接内存与 OOM","page":159,"textblocks":[{"first":[75.52161407470703,277.623046875,14.631797790527344,17.5],"last":[175.77870178222656,277.623046875,13.79779052734375,17.5],"length":9,"rects":[[75.52161407470703,277.623046875,114.05487823486328,17.5]],"start":0,"text":"直接内存与 OOM"}],"type":5,"uuid":"117db0706da469d474b7aaeedfd0cbd8"}],"originaltext":"直接内存","page":157,"textblocks":[{"first":[75.52161407470703,287.87890625,17.07042694091797,19.5],"last":[126.73291015625,287.87890625,17.0704345703125,19.5],"length":4,"rects":[[75.52161407470703,287.87890625,68.28173065185547,19.5]],"start":2,"text":"直接内存"}],"type":5,"uuid":"153a1ddd2093281f81a5e737076c717e"},{"date":"2022-04-15 17:20:34","docid":0,"fillcolor":"ffffed99","id":736,"originaltext":"常见面试题","page":160,"textblocks":[{"first":[75.52161407470703,586.517578125,17.07042694091797,19.5],"last":[143.80332946777344,586.517578125,17.0704345703125,19.5],"length":5,"rects":[[75.52161407470703,586.517578125,85.3521499633789,19.5]],"start":10,"text":"常见面试题"}],"type":5,"uuid":"a9787aa32d87939e6f50860dccd99b77"}],"originaltext":"方法区","page":123,"textblocks":[{"first":[75.52161407470703,85.88591003417969,21.94770050048828,25.5],"last":[119.41700744628906,85.88591003417969,21.94769287109375,25.5],"length":3,"rects":[[75.52161407470703,85.88591003417969,65.84308624267578,25.5]],"start":2,"text":"方法区"}],"title":"第6章-方法区","type":5,"uuid":"b2f604bffc447cf8b64687f8f8ff084e"},{"date":"2022-04-15 17:20:48","docid":0,"fillcolor":"ffffed99","folded":false,"id":737,"markups":[{"date":"2022-04-15 17:23:37","docid":0,"fillcolor":"ffffed99","folded":false,"id":738,"markups":[{"content":"其中的new有变形，工厂方法将new私有化到静态类中","date":"2022-04-27 20:21:34","docid":0,"fillcolor":"ffffed99","id":739,"originaltext":"对象创建的方式","page":162,"textblocks":[{"first":[75.52161407470703,577.261474609375,14.631797790527344,17.5],"last":[163.31240844726562,577.261474609375,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,577.261474609375,102.42259979248047,17.5]],"start":97,"text":"对象创建的方式"}],"type":5,"uuid":"c28a9693de598671ef2971bc072c6262"},{"date":"2022-04-27 20:22:10","docid":0,"fillcolor":"ffffed99","folded":false,"id":740,"markups":[{"content":"new关键字会触发去方法区运行时常量池中寻找对应的类是否有被加载链接初始化，有直接就创建实例，没有就使用双亲委派机制加载，还是找不到直接抛出异常","date":"2022-04-27 20:28:49","docid":0,"fillcolor":"ffffed99","id":741,"originaltext":"1、判断对象对应的类是否加载、链接、初始化","page":163,"textblocks":[{"first":[75.52161407470703,504.47625732421875,5.5698394775390625,13.5],"last":[266.42559814453125,504.47625732421875,9.7545166015625,13.5],"length":21,"rects":[[75.52161407470703,504.47625732421875,200.65850067138672,13.5]],"start":27,"text":"1、判断对象对应的类是否加载、链接、初始化"}],"type":5,"uuid":"6be58248dcf7f6993bd11252b4a8d8dd"},{"content":"划分到堆中有两种分配空间方式，但不管如何都会先进行 计算占用空间大小，划分堆空间给新对象","date":"2022-04-27 20:30:34","docid":0,"fillcolor":"ffffed99","folded":true,"id":742,"markups":[{"content":"若这个对象是引用对象，直接划分变量空间4字节给它","date":"2022-04-28 20:44:07","docid":0,"fillcolor":"ffffed99","id":747,"originaltext":"1","page":163,"textblocks":[{"first":[87.52719116210938,672.0536499023438,5.57958984375,12.5],"last":[87.52719116210938,672.0536499023438,5.57958984375,12.5],"length":1,"rects":[[87.52719116210938,672.0536499023438,5.57958984375,12.5]],"start":303,"text":"1"}],"type":5,"uuid":"224d2c55af1935f05609d710f1920e44"},{"content":"如果不是引用对象\n堆中内存规整（占用面积是整整一块的不会交错）：\n指针碰撞分配内存\n","date":"2022-04-28 20:44:10","docid":0,"fillcolor":"ffffed99","id":748,"originaltext":"2","page":163,"textblocks":[{"first":[87.52719116210938,705.5696411132812,5.57958984375,13.5],"last":[87.52719116210938,705.5696411132812,5.57958984375,13.5],"length":1,"rects":[[87.52719116210938,705.5696411132812,5.57958984375,13.5]],"start":371,"text":"2"}],"type":5,"uuid":"75ef33112452ba173218775ec8a89c9d"},{"content":"若是堆中不规整（占用的和空闲的内存交错放置，所以需要定制一个空闲列表表示空闲内存在哪）：\n使用空闲列表的方式分配内存，找到一块足够大的空闲内存存储","date":"2022-04-28 20:48:23","docid":0,"fillcolor":"ffffed99","id":749,"originaltext":"3","page":164,"textblocks":[{"first":[87.52719116210938,74.7762451171875,5.57958984375,12.5],"last":[87.52719116210938,74.7762451171875,5.57958984375,12.5],"length":1,"rects":[[87.52719116210938,74.7762451171875,5.57958984375,12.5]],"start":115,"text":"3"}],"type":5,"uuid":"ab68226723608f26fa8bc628ea32ae43"}],"originaltext":"2、为对象分配内存","page":163,"textblocks":[{"first":[75.52161407470703,648.5431518554688,5.5698394775390625,13.5],"last":[149.37123107910156,648.5431518554688,9.754531860351562,13.5],"length":9,"rects":[[75.52161407470703,648.5431518554688,83.6041488647461,13.5]],"start":293,"text":"2、为对象分配内存"}],"type":5,"uuid":"54468a4504c2341a9e8aab609191e5a0"},{"content":"在伊甸园区创建TLAB放置对象\n如果TLAB满了使用cas\n","date":"2022-04-28 20:30:54","docid":0,"fillcolor":"ffffed99","id":743,"originaltext":"3、处理并发问题","page":164,"textblocks":[{"first":[75.52161407470703,245.1053466796875,5.5698394775390625,12.5],"last":[139.61669921875,245.1053466796875,9.754531860351562,12.5],"length":8,"rects":[[75.52161407470703,245.1053466796875,73.84961700439453,12.5]],"start":360,"text":"3、处理并发问题"}],"type":5,"uuid":"77164729e17014aec0b7b43f68d9a9e7"},{"content":"初始化所有的属性，对属性分配所需的空间以及设置默认值","date":"2022-04-28 20:30:58","docid":0,"fillcolor":"ffffed99","id":744,"originaltext":"4、初始化分配到的空间","page":164,"textblocks":[{"first":[75.52161407470703,342.4010009765625,5.5698394775390625,13.5],"last":[168.8802947998047,342.4010009765625,9.754531860351562,13.5],"length":11,"rects":[[75.52161407470703,342.4010009765625,103.11321258544922,13.5]],"start":463,"text":"4、初始化分配到的空间"}],"type":5,"uuid":"163f93e37e0613ebc2c448854e9a1608"},{"content":"也就是对对象设置它的元数据，就是对象头，包括（在JUC中有讲）","date":"2022-04-28 20:32:53","docid":0,"fillcolor":"ffffed99","id":745,"originaltext":"5、设置对象的对象头","page":164,"textblocks":[{"first":[75.52161407470703,479.9644775390625,5.5698394775390625,12.5],"last":[159.12576293945312,479.9644775390625,9.754531860351562,12.5],"length":10,"rects":[[75.52161407470703,479.9644775390625,93.35868072509766,12.5]],"start":576,"text":"5、设置对象的对象头"}],"type":5,"uuid":"e6004205fc2f4b230aca2475eb6a3380"},{"content":"代码块中的初始化和构造器中的初始化","date":"2022-04-28 20:32:57","docid":0,"fillcolor":"ffffed99","id":746,"originaltext":"6、执行init方法进行初始化","page":164,"textblocks":[{"first":[75.52161407470703,562.9531860351562,5.5698394775390625,13.5],"last":[185.4792022705078,562.9531860351562,9.754531860351562,13.5],"length":15,"rects":[[75.52161407470703,562.9531860351562,119.71212005615234,13.5]],"start":666,"text":"6、执行init方法进行初始化"}],"type":5,"uuid":"74f88ed2002a33dcf76e5125a03dfc24"}],"originaltext":"对象创建的步骤","page":163,"textblocks":[{"first":[75.52161407470703,30.25732421875,14.631797790527344,17.5],"last":[163.31240844726562,30.25732421875,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,30.25732421875,102.42259979248047,17.5]],"start":0,"text":"对象创建的步骤"}],"type":5,"uuid":"8a33a839baf6880e94563a42bc91d397"}],"originaltext":"对象的实例化","page":162,"textblocks":[{"first":[75.52161407470703,122.0509033203125,17.07042694091797,19.5],"last":[160.87376403808594,122.0509033203125,17.0704345703125,19.5],"length":6,"rects":[[75.52161407470703,122.0509033203125,102.4225845336914,19.5]],"start":19,"text":"对象的实例化"}],"type":5,"uuid":"da1a19f5f4be7204b3afdbc560f88c14"},{"content":"总共三部分：对象头、实例数据、对齐填充\n\n对象头分为两部分：\nMarkWord和KlassWord\nMarkWord存储对象元数据信息\n（包括哈希值、分带年龄、锁状态、持有锁、线程ID、时间戳）\nKlassWord存储指向类元数据，用来确定所属类型，也就是这个对象是哪个类的实例对象\n（对象是数组的情况下还会携带对象的长度）\n\n\n实例数据：定义的各种类型的字段数据\n（父类的字段排在子类之前并且按同大小分一起）\n\n对齐填充：不是必须的，占位符\n","date":"2022-04-28 21:46:38","docid":0,"fillcolor":"ffffed99","folded":true,"id":750,"markups":[{"date":"2022-04-29 15:32:13","docid":0,"fillcolor":"ffffed99","id":751,"originaltext":"图解内存布局","page":166,"textblocks":[{"first":[75.52161407470703,592.9668579101562,9.754531860351562,13.5],"last":[124.29427337646484,592.9668579101562,9.754524230957031,13.5],"length":6,"rects":[[75.52161407470703,592.9668579101562,58.527183532714844,13.5]],"start":11,"text":"图解内存布局"}],"type":5,"uuid":"bd8e410eed0d30ce8abf3d7d52ec64b5"}],"originaltext":"对象的内存布局","page":165,"textblocks":[{"first":[75.52161407470703,683.311767578125,17.07042694091797,19.5],"last":[177.94419860839844,683.311767578125,17.0704345703125,19.5],"length":7,"rects":[[75.52161407470703,683.311767578125,119.4930191040039,19.5]],"start":115,"text":"对象的内存布局"}],"type":5,"uuid":"79defa9c596abfef2446384df80af0b8"},{"content":"就是栈帧的引用怎么找到堆空间的对象，而对象又怎么找到方法区中的类\n使用访问定位","date":"2022-04-29 15:38:52","docid":0,"fillcolor":"ffffed99","folded":true,"id":752,"markups":[{"date":"2022-04-29 15:40:30","docid":0,"fillcolor":"ffffed99","id":753,"markups":[{"content":"堆空间里面创建一个句柄池\n即指向堆空间中对应的实例数据，又指向方法区的类","date":"2022-04-29 15:41:38","docid":0,"fillcolor":"ffffed99","id":754,"originaltext":"1、句柄访问","page":167,"textblocks":[{"first":[75.52161407470703,651.043701171875,5.5698394775390625,12.5],"last":[120.10763549804688,651.043701171875,9.754531860351562,12.5],"length":6,"rects":[[75.52161407470703,651.043701171875,54.340553283691406,12.5]],"start":80,"text":"1、句柄访问"}],"type":5,"uuid":"d5c15e15ba95b61a547f440b48621dd4"},{"content":"对象实体中创建一个直接指针指向方法区中的对象类型数据","date":"2022-04-29 15:42:09","docid":0,"fillcolor":"ffffed99","id":755,"originaltext":"2、直接指针","page":168,"textblocks":[{"first":[75.52161407470703,330.2955017089844,5.5698394775390625,14.5],"last":[120.10763549804688,330.2955017089844,9.754531860351562,14.5],"length":6,"rects":[[75.52161407470703,330.2955017089844,54.340553283691406,14.5]],"start":2,"text":"2、直接指针"}],"type":5,"uuid":"7d3a4fc356e690051fbc7cf081dd79c4"}],"originaltext":"对象的两种访问方式","page":167,"textblocks":[{"first":[75.52161407470703,627.782958984375,9.754531860351562,12.5],"last":[153.557861328125,627.782958984375,9.754531860351562,12.5],"length":9,"rects":[[75.52161407470703,627.782958984375,87.79077911376953,12.5]],"start":60,"text":"对象的两种访问方式"}],"type":5,"uuid":"54b909de44610d3a3a2c051391e303ac"}],"originaltext":"对象的访问定位","page":167,"textblocks":[{"first":[75.52161407470703,290.128662109375,17.07042694091797,19.5],"last":[177.94419860839844,290.128662109375,17.0704345703125,19.5],"length":7,"rects":[[75.52161407470703,290.128662109375,119.4930191040039,19.5]],"start":2,"text":"对象的访问定位"}],"type":5,"uuid":"4e6490ef727bda3c604b01af38db72da"}],"originaltext":"对象的实例化内存布局与访问定位","page":162,"textblocks":[{"first":[75.52161407470703,85.88591003417969,21.94770050048828,25.5],"last":[382.78936767578125,85.88591003417969,21.94769287109375,25.5],"length":15,"rects":[[75.52161407470703,85.88591003417969,329.21544647216797,25.5]],"start":2,"text":"对象的实例化内存布局与访问定位"}],"title":"第7章-对象的实例化内存布局与访问定位","type":5,"uuid":"d3af1279a1813b2a3e747f7b08ce92f1"},{"date":"2022-04-29 15:47:24","docid":0,"fillcolor":"ffffed99","folded":false,"id":756,"markups":[{"content":"执行引起：对二进制字节码文件进行后端编译，分为解释执行、编译执行","date":"2022-04-29 16:10:34","docid":0,"fillcolor":"ffffed99","folded":true,"id":757,"markups":[{"content":"执行引擎通过PC寄存器寻找需要执行的代码地址\n对虚拟机栈的栈帧操作里面的操作数栈和局部变量表进行操作\n局部变量表指向堆","date":"2022-04-29 16:21:47","docid":0,"fillcolor":"ffffed99","id":758,"originaltext":"执行引擎工作过程","page":170,"textblocks":[{"first":[75.52161407470703,310.88763427734375,14.631797790527344,17.5],"last":[177.94419860839844,310.88763427734375,14.631790161132812,17.5],"length":8,"rects":[[75.52161407470703,310.88763427734375,117.05437469482422,17.5]],"start":75,"text":"执行引擎工作过程"}],"type":5,"uuid":"88e5f5de52818c86f3770d1dc0d7cf83"}],"originaltext":"执行引擎概述","page":169,"textblocks":[{"first":[75.52161407470703,122.0509033203125,17.07042694091797,19.5],"last":[160.87376403808594,122.0509033203125,17.0704345703125,19.5],"length":6,"rects":[[75.52161407470703,122.0509033203125,102.4225845336914,19.5]],"start":8,"text":"执行引擎概述"}],"type":5,"uuid":"b547bded1fdace6577b2c32687c46df8"},{"date":"2022-04-29 16:44:40","docid":0,"fillcolor":"ffffed99","folded":true,"id":759,"markups":[{"date":"2022-04-29 16:44:47","docid":0,"fillcolor":"ffffed99","id":760,"originaltext":"解释执行和即时编译","page":171,"textblocks":[{"first":[75.52161407470703,487.9700927734375,14.631797790527344,17.5],"last":[192.5760040283203,487.9700927734375,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,487.9700927734375,131.6861801147461,17.5]],"start":17,"text":"解释执行和即时编译"}],"type":5,"uuid":"e280454a1c63db322d9c141caac6ec3e"},{"date":"2022-04-29 16:49:08","docid":0,"fillcolor":"ffffed99","folded":true,"id":761,"markups":[{"content":"对字节码逐条翻译并执行","date":"2022-04-29 16:49:51","docid":0,"fillcolor":"ffffed99","id":762,"originaltext":"1. 解释器","page":172,"textblocks":[{"first":[87.52719116210938,719.0256958007812,5.57958984375,13.5],"last":[117.5411376953125,719.0256958007812,9.754531860351562,13.5],"length":6,"rects":[[87.52719116210938,719.0256958007812,39.76847839355469,13.5]],"start":91,"text":"1. 解释器"}],"type":5,"uuid":"7019ece61b2638c4e8b263af69748bc8"},{"content":"对字节码一次性翻译所有，然后执行，可以对指令进行缓存，中间可以对代码进行优化","date":"2022-04-29 16:49:57","docid":0,"fillcolor":"ffffed99","id":763,"originaltext":"2. JIT（Just In Time Compiler）编译器","page":172,"textblocks":[{"first":[87.52719116210938,748.2396240234375,5.57958984375,14.5],"last":[244.66441345214844,748.2396240234375,9.754531860351562,14.5],"length":32,"rects":[[87.52719116210938,748.2396240234375,166.89175415039062,14.5]],"start":167,"text":"2. JIT（Just In Time Compiler）编译器"}],"type":5,"uuid":"7dbafd73475fcd4d59124b0f4d676ac3"}],"originaltext":"什么是解释器？什么是JIT编译器？","page":172,"textblocks":[{"first":[75.52161407470703,689.813720703125,14.631797790527344,17.5],"last":[283.8961181640625,689.813720703125,14.631805419921875,17.5],"length":17,"rects":[[75.52161407470703,689.813720703125,223.00630950927734,17.5]],"start":72,"text":"什么是解释器？什么是JIT编译器？"}],"type":5,"uuid":"bba2259f7142da2e271107b4329f9825"},{"content":"因为Java底层存在解释器和编译器，有两种选择","date":"2022-04-29 16:53:41","docid":0,"fillcolor":"ffffed99","id":764,"originaltext":"为什么Java是半编译半解释型语言？","page":173,"textblocks":[{"first":[75.52161407470703,29.755126953125,9.754531860351562,12.5],"last":[222.8922119140625,29.755126953125,9.754531860351562,12.5],"length":18,"rects":[[75.52161407470703,29.755126953125,157.12512969970703,12.5]],"start":0,"text":"为什么Java是半编译半解释型语言？"}],"type":5,"uuid":"eacdec7679eb7469d6b7fa299b8a5d58"}],"originaltext":"Java代码编译和执行过程","page":171,"textblocks":[{"first":[75.52161407470703,457.9561767578125,5.6503143310546875,19.5],"last":[248.0679931640625,457.9561767578125,17.0704345703125,19.5],"length":13,"rects":[[75.52161407470703,457.9561767578125,189.61681365966797,19.5]],"start":2,"text":"Java代码编译和执行过程"}],"type":5,"uuid":"b10e83a260c0cd098c65ac60b0ed8cc8"},{"date":"2022-04-29 16:56:54","docid":0,"fillcolor":"ffffed99","folded":true,"id":765,"markups":[{"date":"2022-04-29 16:57:03","docid":0,"fillcolor":"ffffed99","id":766,"originaltext":"机器码","page":173,"textblocks":[{"first":[75.52161407470703,455.2041015625,14.631797790527344,16.5],"last":[104.78520965576172,455.2041015625,14.631797790527344,16.5],"length":3,"rects":[[75.52161407470703,455.2041015625,43.89539337158203,16.5]],"start":232,"text":"机器码"}],"type":5,"uuid":"717813ad6e03a1d7e73eabd73268730f"},{"date":"2022-04-29 16:57:07","docid":0,"fillcolor":"ffffed99","id":767,"originaltext":"指令和指令集","page":173,"textblocks":[{"first":[75.52161407470703,644.792724609375,14.631797790527344,17.5],"last":[148.68060302734375,644.792724609375,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,644.792724609375,87.7907943725586,17.5]],"start":441,"text":"指令和指令集"}],"type":5,"uuid":"051d6aec895ced36d602171fc6cb37f0"},{"date":"2022-04-29 16:57:14","docid":0,"fillcolor":"ffffed99","id":768,"originaltext":"汇编语言","page":174,"textblocks":[{"first":[75.52161407470703,153.314453125,14.631797790527344,17.5],"last":[119.41700744628906,153.314453125,14.631790161132812,17.5],"length":4,"rects":[[75.52161407470703,153.314453125,58.527183532714844,17.5]],"start":105,"text":"汇编语言"}],"type":5,"uuid":"50618f6874bdba477e409e6dd0cde28d"},{"date":"2022-04-29 17:09:02","docid":0,"fillcolor":"ffffed99","id":769,"originaltext":"高级语言","page":174,"textblocks":[{"first":[75.52161407470703,328.895751953125,14.631797790527344,17.5],"last":[119.41700744628906,328.895751953125,14.631790161132812,17.5],"length":4,"rects":[[75.52161407470703,328.895751953125,58.527183532714844,17.5]],"start":319,"text":"高级语言"}],"type":5,"uuid":"c3c5bb9f46b83466fb7b9299d595e4c0"},{"date":"2022-04-29 17:09:06","docid":0,"fillcolor":"ffffed99","id":770,"originaltext":"字节码","page":175,"textblocks":[{"first":[75.52161407470703,30.25732421875,14.631797790527344,17.5],"last":[104.78520965576172,30.25732421875,14.631797790527344,17.5],"length":3,"rects":[[75.52161407470703,30.25732421875,43.89539337158203,17.5]],"start":0,"text":"字节码"}],"type":5,"uuid":"9c85b33c8c4754d4d0511fe953199915"},{"date":"2022-04-29 17:09:10","docid":0,"fillcolor":"ffffed99","id":771,"originaltext":"C、C++源程序执行过程","page":175,"textblocks":[{"first":[75.52161407470703,228.34912109375,9.320457458496094,17.5],"last":[213.29486083984375,228.34912109375,14.631805419921875,17.5],"length":12,"rects":[[75.52161407470703,228.34912109375,152.4050521850586,17.5]],"start":191,"text":"C、C++源程序执行过程"}],"type":5,"uuid":"4c1573953baaf067f8713224be03c781"}],"originaltext":"机器码 指令 汇编语言","page":173,"textblocks":[{"first":[75.52161407470703,422.190185546875,17.07042694091797,19.5],"last":[220.9536895751953,422.190185546875,17.0704345703125,19.5],"length":11,"rects":[[75.52161407470703,422.190185546875,162.50251007080078,19.5]],"start":219,"text":"机器码 指令 汇编语言"}],"type":5,"uuid":"b74bb79fc9bd895f618860ffa913f4b3"},{"date":"2022-04-29 17:09:28","docid":0,"fillcolor":"ffffed99","folded":true,"id":772,"markups":[{"content":"跨平台的特性需要解释器","date":"2022-05-05 11:40:13","docid":0,"fillcolor":"ffffed99","id":774,"originaltext":"为什么要有解释器","page":176,"textblocks":[{"first":[75.52161407470703,61.021484375,14.631797790527344,17.5],"last":[177.94419860839844,61.021484375,14.631790161132812,17.5],"length":8,"rects":[[75.52161407470703,61.021484375,117.05437469482422,17.5]],"start":5,"text":"为什么要有解释器"}],"type":5,"uuid":"8531527b223b3471359a95d554990f7c"},{"date":"2022-05-05 11:40:49","docid":0,"fillcolor":"ffffed99","folded":true,"id":775,"markups":[{"date":"2022-05-05 11:40:53","docid":0,"fillcolor":"ffffed99","id":776,"originaltext":"字节码解释器","page":176,"textblocks":[{"first":[340.72296142578125,478.16387939453125,9.7545166015625,13.5],"last":[389.49560546875,478.16387939453125,9.7545166015625,13.5],"length":6,"rects":[[340.72296142578125,478.16387939453125,58.52716064453125,13.5]],"start":295,"text":"字节码解释器"}],"type":5,"uuid":"a116aff16dfd6c8c0a45e6d0b4b3ac95"},{"date":"2022-05-05 11:41:00","docid":0,"fillcolor":"ffffed99","id":777,"originaltext":"模板解释器","page":176,"textblocks":[{"first":[477.2864074707031,478.16387939453125,9.754547119140625,13.5],"last":[98.03207397460938,493.470703125,9.754531860351562,12.5],"length":6,"rects":[[477.2864074707031,478.16387939453125,39.018157958984375,13.5],[98.03207397460938,493.470703125,9.754531860351562,12.5]],"start":309,"text":"模板解释\n器"}],"type":5,"uuid":"428c2e65601a13e088efc871f401de57"}],"originaltext":"解释器的分类","page":176,"textblocks":[{"first":[75.52161407470703,425.69091796875,14.631797790527344,17.5],"last":[148.68060302734375,425.69091796875,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,425.69091796875,87.7907943725586,17.5]],"start":255,"text":"解释器的分类"}],"type":5,"uuid":"efd50e1753d88d3d061d499e03c144ff"},{"content":"低效率","date":"2022-05-05 11:41:08","docid":0,"fillcolor":"ffffed99","id":778,"originaltext":"解释器的现状","page":176,"textblocks":[{"first":[75.52161407470703,618.53076171875,14.631797790527344,16.5],"last":[148.68060302734375,618.53076171875,14.631805419921875,16.5],"length":6,"rects":[[75.52161407470703,618.53076171875,87.7907943725586,16.5]],"start":523,"text":"解释器的现状"}],"type":5,"uuid":"10ee27249b7e36516bf32962702422a4"}],"originaltext":"解释器","page":176,"textblocks":[{"first":[75.52161407470703,29.0078125,17.07042694091797,19.5],"last":[109.6624755859375,29.0078125,17.0704345703125,19.5],"length":3,"rects":[[75.52161407470703,29.0078125,51.21129608154297,19.5]],"start":0,"text":"解释器"}],"type":5,"uuid":"8c96c7e67fa0008fd0fa4de017f087cd"},{"date":"2022-04-29 17:09:43","docid":0,"fillcolor":"ffffed99","folded":true,"id":773,"markups":[{"content":"解释器和即时编译器\n其中HotSpot是解释器和即时编译器并存的架构\n使用的话视情况使用","date":"2022-05-05 11:41:28","docid":0,"fillcolor":"ffffed99","id":779,"originaltext":"Java 代码执行的分类","page":177,"textblocks":[{"first":[75.52161407470703,86.783203125,4.8431243896484375,17.5],"last":[197.9557647705078,86.783203125,14.631790161132812,17.5],"length":12,"rects":[[75.52161407470703,86.783203125,137.0659408569336,17.5]],"start":10,"text":"Java 代码执行的分类"}],"type":5,"uuid":"a53a0f77eb38211b27ecd06f9cd96160"},{"date":"2022-05-05 11:42:43","docid":0,"fillcolor":"ffffed99","folded":false,"id":780,"markups":[{"content":"解释器响应速度快而编译器需要先翻译成机器码需要时间，但是执行效率高","date":"2022-05-05 11:54:24","docid":0,"fillcolor":"ffffed99","id":781,"originaltext":"首先明确两点","page":177,"textblocks":[{"first":[75.52161407470703,411.68310546875,9.754531860351562,12.5],"last":[124.29427337646484,411.68310546875,9.754524230957031,12.5],"length":6,"rects":[[75.52161407470703,411.68310546875,58.527183532714844,12.5]],"start":561,"text":"首先明确两点"}],"type":5,"uuid":"67a556d0ab7cc546110c5e7ac6e156ff"},{"content":"解释器和编译器的配合，只有热点代码才会被直接编译成机器码，然后越来越多的热点代码被编译成机器码，如此提高程序执行效率\n\n对流量处理就热机状态和冷机状态的转换","date":"2022-05-05 12:00:10","docid":0,"fillcolor":"ffffed99","id":782,"originaltext":"当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。","page":177,"textblocks":[{"first":[98.03207397460938,677.306640625,9.754531860351562,13.5],"last":[449.1952209472656,707.3203125,9.754547119140625,13.5],"length":125,"rects":[[98.03207397460938,677.306640625,419.4448547363281,13.5],[98.03207397460938,692.0134887695312,419.4448547363281,13.5],[98.03207397460938,707.3203125,360.9176940917969,13.5]],"start":962,"text":"当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这\n样可以省去许多不必要的编译时间。随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热\n点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。"}],"type":5,"uuid":"563dfebf5fddffb78814be823a5f5762"}],"originaltext":"为啥我们还需要解释器呢？","page":177,"textblocks":[{"first":[75.52161407470703,283.87548828125,14.631797790527344,17.5],"last":[236.4713897705078,283.87548828125,14.631790161132812,17.5],"length":12,"rects":[[75.52161407470703,283.87548828125,175.5815658569336,17.5]],"start":325,"text":"为啥我们还需要解释器呢？"}],"type":5,"uuid":"cc0a46ab7451bbbc67ca4e56ba6e9147"},{"content":"编译器可以指整段的编译期称为静态提前编译器\n也可以指前端编译期间生成class字节码部分称为前端编译器\n也可以指后端编译期间生成机器码部分称为后端运行期编译器","date":"2022-05-05 13:51:36","docid":0,"fillcolor":"ffffed99","id":783,"originaltext":"JIT编译器相关概念","page":179,"textblocks":[{"first":[75.52161407470703,276.3720703125,4.8431243896484375,17.5],"last":[181.4735565185547,276.3720703125,14.631790161132812,17.5],"length":10,"rects":[[75.52161407470703,276.3720703125,120.58373260498047,17.5]],"start":2,"text":"JIT编译器相关概念"}],"type":5,"uuid":"75b5f6baf835764cc2042cddc6db1450"}],"originaltext":"JIT编译器","page":177,"textblocks":[{"first":[75.52161407470703,31.0078125,5.6503143310546875,19.5],"last":[130.85047912597656,31.0078125,17.0704345703125,19.5],"length":6,"rects":[[75.52161407470703,31.0078125,72.39929962158203,19.5]],"start":0,"text":"JIT编译器"}],"type":5,"uuid":"403fd74cee451bfa3e3a65077535e350"},{"content":"对一部分class字节码翻译成机器码的执行频率进行计算\n如果较高则这部分处理class字节码被收集成热点代码，下次运行直接使用即时编译器做深度优化，叫做栈上替换\n\n发现这段代码为热点代码的技术就是：\n基于计数器热点探测","date":"2022-05-05 13:53:31","docid":0,"fillcolor":"ffffed99","folded":false,"id":784,"markups":[{"date":"2022-05-05 14:01:01","docid":0,"fillcolor":"ffffed99","folded":true,"id":785,"markups":[{"date":"2022-05-05 14:05:36","docid":0,"fillcolor":"ffffed99","id":789,"originaltext":"1. 方法调用计数器用于统计方法的调用次数","page":180,"textblocks":[{"first":[110.03765106201172,65.021484375,5.57958984375,12.5],"last":[286.36956787109375,65.021484375,9.7545166015625,12.5],"length":21,"rects":[[110.03765106201172,65.021484375,186.08643341064453,12.5]],"start":106,"text":"1. 方法调用计数器用于统计方法的调用次数"}],"type":5,"uuid":"320c59380122fc83e42e86ec71e62955"},{"date":"2022-05-05 14:05:44","docid":0,"fillcolor":"ffffed99","id":790,"originaltext":"2. 回边计数器则用于统计循环体执行的循环次数","page":180,"textblocks":[{"first":[110.03765106201172,80.0283203125,5.57958984375,12.5],"last":[305.8786315917969,80.0283203125,9.754547119140625,12.5],"length":23,"rects":[[110.03765106201172,80.0283203125,205.59552764892578,12.5]],"start":128,"text":"2. 回边计数器则用于统计循环体执行的循环次数"}],"type":5,"uuid":"31db766b5e1a35aac2828dd50dec43de"}],"originaltext":"基于计数器的热点探测","page":180,"textblocks":[{"first":[117.5411376953125,29.7548828125,9.754531860351562,12.5],"last":[205.33192443847656,29.7548828125,9.754531860351562,12.5],"length":10,"rects":[[117.5411376953125,29.7548828125,97.54531860351562,12.5]],"start":5,"text":"基于计数器的热点探测"}],"type":5,"uuid":"42a1d4e5f551055720ab661d5cb8f8c0"},{"date":"2022-05-05 14:01:09","docid":0,"fillcolor":"ffffed99","id":786,"originaltext":"方法调用计数器","page":180,"textblocks":[{"first":[75.52161407470703,126.80078125,12.193168640136719,14.5],"last":[148.68060302734375,126.80078125,12.193161010742188,14.5],"length":7,"rects":[[75.52161407470703,126.80078125,85.3521499633789,14.5]],"start":154,"text":"方法调用计数器"}],"type":5,"uuid":"59f94784366de6749784d69a440d6511"},{"content":"一段时间不用就会衰减一半，时间就是半衰周期","date":"2022-05-05 14:01:23","docid":0,"fillcolor":"ffffed99","id":787,"originaltext":"热度衰减","page":181,"textblocks":[{"first":[75.52161407470703,29.255859375,12.193168640136719,15.5],"last":[112.10111236572266,29.255859375,12.193168640136719,15.5],"length":4,"rects":[[75.52161407470703,29.255859375,48.772666931152344,15.5]],"start":0,"text":"热度衰减"}],"type":5,"uuid":"16c93adec39d1de1911e9f1ae7a9b85a"},{"date":"2022-05-05 14:01:27","docid":0,"fillcolor":"ffffed99","id":788,"originaltext":"回边计数器","page":181,"textblocks":[{"first":[75.52161407470703,246.1064453125,12.193168640136719,15.5],"last":[124.29427337646484,246.1064453125,12.193168640136719,15.5],"length":5,"rects":[[75.52161407470703,246.1064453125,60.96582794189453,15.5]],"start":423,"text":"回边计数器"}],"type":5,"uuid":"fb6c47db6034cd68a4cc45c4da568c35"}],"originaltext":"热点代码及探测方式","page":179,"textblocks":[{"first":[75.52161407470703,550.2490234375,14.631797790527344,17.5],"last":[192.5760040283203,550.2490234375,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,550.2490234375,131.6861801147461,17.5]],"start":401,"text":"热点代码及探测方式"}],"type":5,"uuid":"9469b015378279d6544eaa46442365ed"},{"content":"设置成纯解释器、纯编译器或者混合","date":"2022-05-05 14:11:48","docid":0,"fillcolor":"ffffed99","folded":true,"id":791,"markups":[{"date":"2022-05-05 14:13:09","docid":0,"fillcolor":"ffffed99","id":793,"originaltext":"结论：只用解释器执行是真的慢","page":183,"textblocks":[{"first":[75.52161407470703,208.337890625,9.754531860351562,12.5],"last":[202.33053588867188,208.337890625,9.754531860351562,12.5],"length":14,"rects":[[75.52161407470703,208.337890625,136.5634536743164,12.5]],"start":0,"text":"结论：只用解释器执行是真的慢"}],"type":5,"uuid":"df9c1e7caf9e12f66cfaf0d87022e2de"}],"originaltext":"HotSpotVM可以设置程序执行方法","page":182,"textblocks":[{"first":[75.52161407470703,29.156835556030273,11.193321228027344,19.500001907348633],"last":[289.8474426269531,29.156835556030273,14.631805419921875,19.500001907348633],"length":19,"rects":[[75.52161407470703,29.156835556030273,228.95763397216797,19.500001907348633]],"start":0,"text":"HotSpotVM可以设置程序执行方法"}],"type":5,"uuid":"45a16f5523e201d20f6ac2f398741a1d"},{"content":"即时编译器有两种一种是客户端一种是服务端简称为C1和C2\n\nc1优化低所以开始编译快后面效率一样\nc2优化快优化后的执行效率高","date":"2022-05-05 14:13:06","docid":0,"fillcolor":"ffffed99","id":792,"originaltext":"HotSpotVM JIT 分类","page":183,"textblocks":[{"first":[75.52161407470703,234.6015625,11.193321228027344,13.5],"last":[198.55589294433594,234.6015625,14.631790161132812,13.5],"length":16,"rects":[[75.52161407470703,234.6015625,137.66606903076172,13.5]],"start":15,"text":"HotSpotVM JIT 分类"}],"type":5,"uuid":"bd736459ad583aa448f94122ea85c7a5"},{"content":"","date":"2022-05-05 14:14:45","docid":0,"fillcolor":"ffffed99","folded":true,"id":794,"markups":[{"date":"2022-05-05 14:19:19","docid":0,"fillcolor":"ffffed99","id":795,"markups":[{"date":"2022-05-05 14:19:42","docid":0,"fillcolor":"ffffed99","id":797,"originaltext":"方法内联，去虚拟化、元余消除","page":183,"textblocks":[{"first":[343.87200927734375,494.220703125,9.7545166015625,12.5],"last":[470.680908203125,494.220703125,9.7545166015625,12.5],"length":14,"rects":[[343.87200927734375,494.220703125,136.56341552734375,12.5]],"start":381,"text":"方法内联，去虚拟化、元余消除"}],"type":5,"uuid":"7565571c00872c5fdd0ab9d8222a887c"}],"originaltext":"C1","page":183,"textblocks":[{"first":[263.8591003417969,494.220703125,6.155120849609375,12.5],"last":[270.01422119140625,494.220703125,5.57958984375,12.5],"length":2,"rects":[[263.8591003417969,494.220703125,11.734710693359375,12.5]],"start":372,"text":"C1"}],"type":5,"uuid":"fcf810af4c07c754f40e311580472a30"},{"date":"2022-05-05 14:19:34","docid":0,"fillcolor":"ffffed99","id":796,"markups":[{"date":"2022-05-05 14:19:53","docid":0,"fillcolor":"ffffed99","id":798,"originaltext":"逃逸分析","page":183,"textblocks":[{"first":[226.81761169433594,573.7578125,9.754531860351562,12.5],"last":[256.0812072753906,573.7578125,9.754547119140625,12.5],"length":4,"rects":[[226.81761169433594,573.7578125,39.01814270019531,12.5]],"start":502,"text":"逃逸分析"}],"type":5,"uuid":"454306db8671947d4d0c9bac8f5d45b0"}],"originaltext":"C2","page":183,"textblocks":[{"first":[98.03207397460938,573.7578125,6.1551055908203125,12.5],"last":[104.18718719482422,573.7578125,5.57958984375,12.5],"length":2,"rects":[[98.03207397460938,573.7578125,11.734703063964844,12.5]],"start":488,"text":"C2"}],"type":5,"uuid":"95925ec66a15e68f83df64d5d75230ac"}],"originaltext":"C1和C2编译器不同的优化策略","page":183,"textblocks":[{"first":[75.52161407470703,464.708984375,9.320457458496094,17.5],"last":[257.19024658203125,464.708984375,14.631805419921875,17.5],"length":15,"rects":[[75.52161407470703,464.708984375,196.3004379272461,17.5]],"start":335,"text":"C1和C2编译器不同的优化策略"}],"type":5,"uuid":"7d951a60c0718f413b45b2d9803c91a6"},{"date":"2022-05-05 14:20:13","docid":0,"fillcolor":"ffffed99","folded":true,"id":799,"markups":[{"content":"当前都是使用C1和C2进行协作的方式执行，以性能监控信息为准是否使用C2\n\nC2启动慢，但是启动后乱杀","date":"2022-05-05 14:21:07","docid":0,"fillcolor":"ffffed99","id":800,"originaltext":"分层编译（Tiered Compilation）策略","page":183,"textblocks":[{"first":[98.03207397460938,723.8271484375,9.754531860351562,12.5],"last":[252.8614501953125,723.8271484375,9.7545166015625,12.5],"length":26,"rects":[[98.03207397460938,723.8271484375,164.58389282226562,12.5]],"start":664,"text":"分层编译（Tiered Compilation）策略"}],"type":5,"uuid":"33a6777c3127b5072a6cd2d759cd8e1c"}],"originaltext":"分层编译策略","page":183,"textblocks":[{"first":[75.52161407470703,671.8056640625,14.631797790527344,17.5],"last":[148.68060302734375,671.8056640625,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,671.8056640625,87.7907943725586,17.5]],"start":651,"text":"分层编译策略"}],"type":5,"uuid":"f2f3172197d423fcc2dbd2730de88277"}],"originaltext":"执行引擎","page":169,"textblocks":[{"first":[75.52161407470703,85.7859115600586,21.94770050048828,24.5],"last":[141.3647003173828,85.7859115600586,21.94769287109375,24.5],"length":4,"rects":[[75.52161407470703,85.7859115600586,87.79077911376953,24.5]],"start":2,"text":"执行引擎"}],"title":"第8章-执行引擎","type":5,"uuid":"fc62baf4df24c94639da95e21d743dd3"},{"date":"2022-05-05 14:32:18","docid":0,"fillcolor":"ffffed99","folded":true,"id":801,"markups":[{"date":"2022-05-05 14:32:57","docid":0,"fillcolor":"ffffed99","id":802,"originaltext":"String的基本特性","page":185,"textblocks":[{"first":[75.52161407470703,121.35090637207031,9.405807495117188,21.5],"last":[194.43951416015625,121.35090637207031,17.0704345703125,21.5],"length":11,"rects":[[75.52161407470703,121.35090637207031,135.98833465576172,21.5]],"start":23,"text":"String的基本特性"}],"type":5,"uuid":"5b2d501177e8774c64a737bdd6a72681"},{"content":"因为发现大多数字符串对象存储的是拉丁字符而拉丁字符只需要一个字节就可以了，但是char占两个字节很浪费\n\n直接编程byte[]+编码标识符来组成字符串来节省空间，相应的基于String的数据结构也做出了修改","date":"2022-05-05 14:35:03","docid":0,"fillcolor":"ffffed99","folded":true,"id":803,"markups":[{"date":"2022-05-05 14:35:15","docid":0,"fillcolor":"ffffed99","folded":true,"id":804,"markups":[{"date":"2022-05-05 14:54:48","docid":0,"fillcolor":"ffffed99","id":806,"originaltext":"不可变性","page":185,"textblocks":[{"first":[270.9273376464844,723.8276977539062,9.754547119140625,12.5],"last":[300.1909484863281,723.8276977539062,9.754547119140625,12.5],"length":4,"rects":[[270.9273376464844,723.8276977539062,39.018157958984375,12.5]],"start":763,"text":"不可变性"}],"type":5,"uuid":"764481beaf2aa76a558ef79d9bc1436e"}],"originaltext":"String 的基本特性","page":185,"textblocks":[{"first":[75.52161407470703,671.5054321289062,8.062118530273438,18.5],"last":[181.2520751953125,671.5054321289062,14.631805419921875,18.5],"length":12,"rects":[[75.52161407470703,671.5054321289062,120.36226654052734,18.5]],"start":726,"text":"String 的基本特性"}],"type":5,"uuid":"9c8f54af9cff28471294e07a4fb890b8"},{"date":"2022-05-05 14:35:23","docid":0,"fillcolor":"ffffed99","folded":true,"id":805,"markups":[{"content":"因为底层是一个Hashtable，并且不会扩容","date":"2022-05-05 15:00:07","docid":0,"fillcolor":"ffffed99","id":807,"originaltext":"字符串常量池是不会存储相同内容的字符串的","page":187,"textblocks":[{"first":[75.52161407470703,398.176513671875,9.754531860351562,12.5],"last":[260.85772705078125,398.176513671875,9.7545166015625,12.5],"length":20,"rects":[[75.52161407470703,398.176513671875,195.09062957763672,12.5]],"start":88,"text":"字符串常量池是不会存储相同内容的字符串的"}],"type":5,"uuid":"0c6fc47c3947d182a85ac97d69df8d02"}],"originaltext":"String 的底层结构","page":187,"textblocks":[{"first":[75.52161407470703,344.3038024902344,8.062118530273438,19.5],"last":[181.2520751953125,344.3038024902344,14.631805419921875,19.5],"length":12,"rects":[[75.52161407470703,344.3038024902344,120.36226654052734,19.5]],"start":72,"text":"String 的底层结构"}],"type":5,"uuid":"0d8112683164b272ea819140b44df63e"}],"originaltext":"为什么 JDK9 改变了 String 的结构","page":185,"textblocks":[{"first":[75.52161407470703,322.4443054199219,17.07042694091797,21.5],"last":[319.82550048828125,322.4443054199219,17.0704345703125,21.5],"length":23,"rects":[[75.52161407470703,322.4443054199219,261.3743209838867,21.5]],"start":228,"text":"为什么 JDK9 改变了 String 的结构"}],"type":5,"uuid":"7cf935aefef764907652f3a76b454430"},{"date":"2022-05-05 15:02:00","docid":0,"fillcolor":"ffffed99","folded":true,"id":808,"markups":[{"content":"直接使用双引号包围的会放到常量池中\n\n使用new创建对象的方式的字符串不会放到常量池中，除非使用intern()方法打到常量池中\n\n字符串常量池放在了堆空间中","date":"2022-05-05 15:05:42","docid":0,"fillcolor":"ffffed99","id":810,"originaltext":"String类型的常量池","page":189,"textblocks":[{"first":[482.86932373046875,381.4189453125,5.355224609375,13.5],"last":[137.05020141601562,396.426025390625,9.754531860351562,13.5],"length":13,"rects":[[482.86932373046875,381.4189453125,36.33184814453125,13.5],[98.03207397460938,396.426025390625,48.77265930175781,13.5]],"start":218,"text":"String类\n型的常量池"}],"type":5,"uuid":"628bebaa2e7560b5cc7fa06ac1a0fce8"},{"content":"1、永久代默认空间较小容易报OOM\n2、回收效率较低","date":"2022-05-05 15:05:28","docid":0,"fillcolor":"ffffed99","id":809,"originaltext":"StringTable 为什么要调整？","page":190,"textblocks":[{"first":[75.52161407470703,545.3968505859375,8.062118530273438,19.5],"last":[250.1958465576172,545.3968505859375,14.631790161132812,19.5],"length":19,"rects":[[75.52161407470703,545.3968505859375,189.30602264404297,19.5]],"start":4,"text":"StringTable 为什么要调整？"}],"type":5,"uuid":"b1a0da8c0067c569d0f14a096f378d3e"}],"originaltext":"String 的内存分配","page":189,"textblocks":[{"first":[75.52161407470703,268.369384765625,9.405807495117188,22.5],"last":[198.8738250732422,268.369384765625,17.0704345703125,22.5],"length":12,"rects":[[75.52161407470703,268.369384765625,140.42264556884766,22.5]],"start":77,"text":"String 的内存分配"}],"type":5,"uuid":"b0918b95fd03b8217c9beba28104f521"},{"date":"2022-05-05 15:14:08","docid":0,"fillcolor":"ffffed99","folded":true,"id":811,"markups":[{"content":"包含同一份马甸序列的常量必须指向同一个String类实例","date":"2022-05-05 15:16:07","docid":0,"fillcolor":"ffffed99","id":813,"originaltext":"Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。","page":191,"textblocks":[{"first":[75.52161407470703,547.9461059570312,2.604461669921875,13.5],"last":[287.4350280761719,562.1529541015625,9.754547119140625,14.5],"length":77,"rects":[[75.52161407470703,547.9461059570312,436.3104782104492,13.5],[75.52161407470703,562.1529541015625,221.66796112060547,14.5]],"start":46,"text":"Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序\n列的常量），并且必须是指向同一个String类实例。"}],"type":5,"uuid":"f99a02d2450ccab5a1379be8531b6ff2"},{"content":"直接使用字符串拼接会导致创建很多的StringBuilder对象，不如直接创建一个StringBuilder对象自己调用append方法","date":"2022-05-05 16:05:58","docid":0,"fillcolor":"ffffed99","id":826,"originaltext":"1. 体会执行效率","page":201,"textblocks":[{"first":[87.52719116210938,311.8857421875,5.57958984375,12.5],"last":[146.8047332763672,311.8857421875,9.754531860351562,12.5],"length":9,"rects":[[87.52719116210938,311.8857421875,69.03207397460938,12.5]],"start":2,"text":"1. 体会执行效率"}],"type":5,"uuid":"67f1c1e281f197a38cb6129cfc74b6a0"}],"originaltext":"String 的基本操作","page":191,"textblocks":[{"first":[75.52161407470703,491.9736328125,9.405807495117188,22.5],"last":[198.8738250732422,491.9736328125,17.0704345703125,22.5],"length":12,"rects":[[75.52161407470703,491.9736328125,140.42264556884766,22.5]],"start":30,"text":"String 的基本操作"}],"type":5,"uuid":"f24e6ce678d1201608ff21764cfbf139"},{"date":"2022-05-05 15:15:48","docid":0,"fillcolor":"ffffed99","folded":true,"id":812,"markups":[{"date":"2022-05-05 15:20:06","docid":0,"fillcolor":"ffffed99","folded":true,"id":814,"markups":[{"date":"2022-05-05 15:20:23","docid":0,"fillcolor":"ffffed99","id":815,"originaltext":"1. 常量与常量的拼接结果在常量池，原理是编译期优化","page":194,"textblocks":[{"first":[87.52719116210938,642.54052734375,5.57958984375,13.5],"last":[312.63177490234375,642.54052734375,9.7545166015625,13.5],"length":26,"rects":[[87.52719116210938,642.54052734375,234.85910034179688,13.5]],"start":68,"text":"1. 常量与常量的拼接结果在常量池，原理是编译期优化"}],"type":5,"uuid":"54b63cc364bd61e4dae2a9c7101f59b6"},{"date":"2022-05-05 15:20:28","docid":0,"fillcolor":"ffffed99","id":816,"originaltext":"2. 常量池中不会存在相同内容的变量","page":194,"textblocks":[{"first":[87.52719116210938,663.80029296875,5.57958984375,12.5],"last":[234.59552001953125,663.80029296875,9.754531860351562,12.5],"length":18,"rects":[[87.52719116210938,663.80029296875,156.82286071777344,12.5]],"start":95,"text":"2. 常量池中不会存在相同内容的变量"}],"type":5,"uuid":"8c0eee1d3c0b1a4ffc0b96aa0dd919dc"},{"content":"只要有一个是变量那么拼接出来的字符串就不在常量池中","date":"2022-05-05 15:20:51","docid":0,"fillcolor":"ffffed99","id":817,"originaltext":"3. 拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder","page":194,"textblocks":[{"first":[87.52719116210938,682.2091064453125,5.57958984375,14.5],"last":[455.7015075683594,682.2091064453125,3.9798583984375,14.5],"length":47,"rects":[[87.52719116210938,682.2091064453125,372.1541748046875,14.5]],"start":114,"text":"3. 拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder"}],"type":5,"uuid":"13d32f91e12a7ce6303237e257a7cb70"},{"date":"2022-05-05 15:21:02","docid":0,"fillcolor":"ffffed99","id":818,"originaltext":"4. 如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在","page":194,"textblocks":[{"first":[87.52719116210938,702.568359375,5.57958984375,13.5],"last":[384.761962890625,702.568359375,9.7545166015625,13.5],"length":38,"rects":[[87.52719116210938,702.568359375,306.9892883300781,13.5]],"start":162,"text":"4. 如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在"}],"type":5,"uuid":"02f8e1ac15fb516a041b1c178ade1b71"}],"originaltext":"结论","page":194,"textblocks":[{"first":[104.78520965576172,590.5185546875,14.631797790527344,18.5],"last":[119.41700744628906,590.5185546875,14.631790161132812,18.5],"length":2,"rects":[[104.78520965576172,590.5185546875,29.263587951660156,18.5]],"start":62,"text":"结论"}],"type":5,"uuid":"f08ec2d99a0a8694325d0933e9e72747"}],"originaltext":"字符串拼接操作","page":194,"textblocks":[{"first":[75.52161407470703,558.50439453125,17.07042694091797,20.5],"last":[177.94419860839844,558.50439453125,17.0704345703125,20.5],"length":7,"rects":[[75.52161407470703,558.50439453125,119.4930191040039,20.5]],"start":51,"text":"字符串拼接操作"}],"type":5,"uuid":"4b289457fde7715c27f97b838d10ac17"},{"content":"总结起来就是\n1.6如果没有就创建对应的常量字符串放到常量池中返回新的引用\n之后如果没有就放当前指向字符串的引用放到常量池中，并返回这个引用","date":"2022-05-05 15:26:10","docid":0,"fillcolor":"ffffed99","folded":false,"id":819,"markups":[{"date":"2022-05-05 15:26:20","docid":0,"fillcolor":"ffffed99","folded":false,"id":820,"markups":[{"date":"2022-05-05 15:29:51","docid":0,"fillcolor":"ffffed99","id":821,"originaltext":"1. intern是一个native方法，调用的是底层C的方法","page":201,"textblocks":[{"first":[87.52719116210938,727.3291015625,5.57958984375,12.5],"last":[295.77093505859375,727.3291015625,9.7545166015625,12.5],"length":31,"rects":[[87.52719116210938,727.3291015625,217.99826049804688,12.5]],"start":452,"text":"1. intern是一个native方法，调用的是底层C的方法"}],"type":5,"uuid":"7d6feeb8fb54a9ccc1f1c03adb63a8f9"},{"content":"不管有没有返回的都是常量池中的地址\n\n\n有就返回常量池的地址，1.6没有就创建一份一样的  字符串 在常量池中返回引用，1.7之后就把堆中的   字符串引用   放入，然后返回常量池中字符串的地址\n\n如果拼接的变量都使用final修饰变成常量\n进行拼接得到的引用和常量池的引用一样\n也就是不会使用StringBuilder进行拼接\n\nnew String(\"a\") 创建字符串对象的时候会创建两个对象一个\"a\"常量池对象，一个是new String()对象","date":"2022-05-05 15:30:17","docid":0,"fillcolor":"ffffed99","id":822,"originaltext":"2. 字符串常量池池最初是空的，由String类私有地维护。","page":201,"textblocks":[{"first":[87.52719116210938,745.2379150390625,5.57958984375,14.5],"last":[319.70001220703125,745.2379150390625,9.7545166015625,14.5],"length":30,"rects":[[87.52719116210938,745.2379150390625,241.92733764648438,14.5]],"start":484,"text":"2. 字符串常量池池最初是空的，由String类私有地维护。"}],"type":5,"uuid":"5c6976e8ff69213f85beeab54c148591"}],"originaltext":"intern() 方法的说明","page":201,"textblocks":[{"first":[75.52161407470703,611.5263671875,4.462699890136719,17.5],"last":[193.1046905517578,611.5263671875,14.631790161132812,17.5],"length":14,"rects":[[75.52161407470703,611.5263671875,132.2148666381836,17.5]],"start":432,"text":"intern() 方法的说明"}],"type":5,"uuid":"a13cf462bab8f9f4c68d7a6ddf9e77bf"},{"date":"2022-05-05 15:43:05","docid":0,"fillcolor":"ffffed99","id":824,"originaltext":"new String(“ab”)会创建几个对象？","page":202,"textblocks":[{"first":[75.52161407470703,276.92108154296875,8.010910034179688,16.5],"last":[260.0563659667969,276.92108154296875,12.19317626953125,16.5],"length":24,"rects":[[75.52161407470703,276.92108154296875,196.7279281616211,16.5]],"start":318,"text":"new String(“ab”)会创建几个对象？"}],"type":5,"uuid":"0b4d92b058f7aceecead79748480ef97"},{"date":"2022-05-05 15:42:54","docid":0,"fillcolor":"ffffed99","id":823,"originaltext":"new String(“a”) + new String(“b”) 会创建几个对象？","page":203,"textblocks":[{"first":[75.52161407470703,28.555858612060547,8.010910034179688,16.5],"last":[360.6202087402344,28.555858612060547,12.19317626953125,16.5],"length":42,"rects":[[75.52161407470703,28.555858612060547,297.2917709350586,16.5]],"start":0,"text":"new String(“a”) + new String(“b”) 会创建几个对象？"}],"type":5,"uuid":"dd136b4c3d43f2df9f3d4248bcdd2985"}],"originaltext":"intern() 的使用","page":201,"textblocks":[{"first":[75.52161407470703,579.1126708984375,5.20648193359375,20.5],"last":[178.56100463867188,579.1126708984375,17.0704345703125,20.5],"length":12,"rects":[[75.52161407470703,579.1126708984375,120.10982513427734,20.5]],"start":418,"text":"intern() 的使用"}],"type":5,"uuid":"8b3a729fcd64ca7881968d5e470a2236"},{"date":"2022-05-05 15:47:20","docid":0,"fillcolor":"ffffed99","id":825,"originaltext":"有点难的面试题","page":204,"textblocks":[{"first":[75.52161407470703,304.884765625,14.631797790527344,17.5],"last":[163.31240844726562,304.884765625,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,304.884765625,102.42259979248047,17.5]],"start":4,"text":"有点难的面试题"}],"type":5,"uuid":"a111779a60d1bc9cace90e87fcce7fc0"},{"date":"2022-05-05 16:22:39","docid":0,"fillcolor":"ffffed99","id":827,"originaltext":"intern() 方法的练习","page":206,"textblocks":[{"first":[75.52161407470703,423.14141845703125,4.462699890136719,18.5],"last":[193.1046905517578,423.14141845703125,14.631790161132812,18.5],"length":14,"rects":[[75.52161407470703,423.14141845703125,132.2148666381836,18.5]],"start":14,"text":"intern() 方法的练习"}],"type":5,"uuid":"5573d5ce405b9777aa3c24e573c66687"},{"date":"2022-05-05 16:29:32","docid":0,"fillcolor":"ffffed99","folded":true,"id":828,"markups":[{"date":"2022-05-05 16:29:52","docid":0,"fillcolor":"ffffed99","id":830,"originaltext":"结论","page":210,"textblocks":[{"first":[75.52161407470703,630.03515625,9.754531860351562,12.5],"last":[85.2761459350586,630.03515625,9.754531860351562,12.5],"length":2,"rects":[[75.52161407470703,630.03515625,19.509063720703125,12.5]],"start":78,"text":"结论"}],"type":5,"uuid":"3d9573c7daecff02c7c129474911aec8"}],"originaltext":"intern() 的效率测试（空间角度）","page":209,"textblocks":[{"first":[75.52161407470703,55.51953125,4.462699890136719,17.5],"last":[280.8954772949219,55.51953125,14.631805419921875,17.5],"length":20,"rects":[[75.52161407470703,55.51953125,220.00566864013672,17.5]],"start":2,"text":"intern() 的效率测试（空间角度）"}],"type":5,"uuid":"647a4d0b671a2f2c4d0a68c47f433270"},{"date":"2022-05-05 16:30:12","docid":0,"fillcolor":"ffffed99","id":831,"originaltext":"StringTable 的垃圾回收","page":210,"textblocks":[{"first":[75.52161407470703,720.080078125,9.405807495117188,22.5],"last":[245.1673583984375,720.080078125,17.0704345703125,22.5],"length":17,"rects":[[75.52161407470703,720.080078125,186.71617889404297,22.5]],"start":231,"text":"StringTable 的垃圾回收"}],"type":5,"uuid":"a64d6fa112693a2e5ddff769f65661ca"},{"content":"说String重复不是说常量池中字符串的重复\n\n多个对象都是指向常量池中相同的字符串，这些对象需要去冲","date":"2022-05-05 16:38:51","docid":0,"fillcolor":"ffffed99","folded":false,"id":832,"markups":[{"content":"使用hashTable达到去重的效果，默认不开启","date":"2022-05-05 16:40:06","docid":0,"fillcolor":"ffffed99","id":833,"originaltext":"String 去重的的实现","page":212,"textblocks":[{"first":[75.52161407470703,230.50155639648438,5.374748229980469,14.5],"last":[155.76312255859375,230.50155639648438,9.754531860351562,14.5],"length":13,"rects":[[75.52161407470703,230.50155639648438,89.99604034423828,14.5]],"start":354,"text":"String 去重的的实现"}],"type":5,"uuid":"1e0aab313eed41aea09837eb61e6413d"}],"originaltext":"G1 中的 String 去重操作","page":211,"textblocks":[{"first":[75.52161407470703,738.087890625,12.358993530273438,22.5],"last":[246.91773986816406,738.087890625,17.070419311523438,22.5],"length":17,"rects":[[75.52161407470703,738.087890625,188.46654510498047,22.5]],"start":114,"text":"G1 中的 String 去重操作"}],"type":5,"uuid":"5f7186cb242d2022af3ed8a36f7178e7"}],"originaltext":"StringTable（字符串常量池）","page":185,"textblocks":[{"first":[75.52161407470703,84.2859115600586,12.093177795410156,27.5],"last":[353.7794189453125,84.2859115600586,21.94769287109375,27.5],"length":19,"rects":[[75.52161407470703,84.2859115600586,300.2054977416992,27.5]],"start":2,"text":"StringTable（字符串常量池）"}],"title":"第9章-StringTable（字符串常量池）","type":5,"uuid":"79b9a089b03b8eae54d6246049354e9d"},{"date":"2022-05-05 16:45:30","docid":0,"fillcolor":"ffffed99","folded":false,"id":834,"markups":[{"date":"2022-05-06 14:40:36","folded":true,"id":850,"linecolor":"ff59c6ff","markups":[{"date":"2022-05-06 14:08:29","docid":0,"fillcolor":"ffffed99","id":836,"originaltext":"大厂面试题","page":213,"textblocks":[{"first":[75.52161407470703,755.4451293945312,17.07042694091797,20.5],"last":[143.80332946777344,755.4451293945312,17.0704345703125,20.5],"length":5,"rects":[[75.52161407470703,755.4451293945312,85.3521499633789,20.5]],"start":311,"text":"大厂面试题"}],"type":5,"uuid":"275e90a9e583a4f4b6dc7d2f9ae0ef43"},{"date":"2022-05-06 14:08:20","docid":0,"fillcolor":"ffffed99","folded":true,"id":835,"markups":[{"content":"就是对于这个对象已经没有引用了\n如果不及时清除就会导致内存溢出问题","date":"2022-05-06 14:08:36","docid":0,"fillcolor":"ffffed99","id":837,"originaltext":"垃圾是指在运行程序中没有任何指针指向的对象","page":214,"textblocks":[{"first":[98.03207397460938,789.6087036132812,9.754531860351562,13.5],"last":[293.1227111816406,789.6087036132812,9.754547119140625,13.5],"length":21,"rects":[[98.03207397460938,789.6087036132812,204.84518432617188,13.5]],"start":607,"text":"垃圾是指在运行程序中没有任何指针指向的对象"}],"type":5,"uuid":"9417f56de110e04cd03b57151cab97e2"}],"originaltext":"什么是垃圾？","page":214,"textblocks":[{"first":[75.52161407470703,759.0968627929688,17.07042694091797,19.5],"last":[160.87376403808594,759.0968627929688,17.0704345703125,19.5],"length":6,"rects":[[75.52161407470703,759.0968627929688,102.4225845336914,19.5]],"start":596,"text":"什么是垃圾？"}],"type":5,"uuid":"931a00236ebef854a97132f18f695fd4"},{"content":"1、内存空间不GC会被消耗完\n2、空出空间分配给新的对象\n3、保证程序的正常进行","date":"2022-05-06 14:09:09","docid":0,"fillcolor":"ffffed99","id":838,"originaltext":"为什么需要GC？","page":215,"textblocks":[{"first":[75.52161407470703,416.2876281738281,17.07042694091797,20.5],"last":[184.1122283935547,416.2876281738281,17.0704345703125,20.5],"length":8,"rects":[[75.52161407470703,416.2876281738281,125.66104888916016,20.5]],"start":209,"text":"为什么需要GC？"}],"type":5,"uuid":"9cf35bf20a905d74baa1fa0c10464f87"},{"content":"C/C++手动申请内存以及手动释放\n导致频繁的申请与释放容易产生内存泄漏\n\n内存泄漏：对某些对象已经不进行引用了，但是垃圾回收不到这些对象，过多的内存泄漏就会导致OOM应用程序崩溃","date":"2022-05-06 14:28:54","docid":0,"fillcolor":"ffffed99","id":839,"originaltext":"早期垃圾回收","page":215,"textblocks":[{"first":[75.52161407470703,592.51953125,17.07042694091797,19.5],"last":[160.87376403808594,592.51953125,17.0704345703125,19.5],"length":6,"rects":[[75.52161407470703,592.51953125,102.4225845336914,19.5]],"start":486,"text":"早期垃圾回收"}],"type":5,"uuid":"4a61e172c410b13a70d9253fb973ae0b"},{"date":"2022-05-06 14:34:37","docid":0,"fillcolor":"ffffed99","folded":false,"id":840,"markups":[{"date":"2022-05-06 14:34:45","docid":0,"fillcolor":"ffffed99","folded":true,"id":841,"markups":[{"content":"1、无需手动参与垃圾回收，降低内存泄漏的风险\n2、更专注于开发","date":"2022-05-06 14:35:03","docid":0,"fillcolor":"ffffed99","id":843,"originaltext":"自动内存管理的优点","page":216,"textblocks":[{"first":[75.52161407470703,305.133056640625,9.754531860351562,13.5],"last":[153.557861328125,305.133056640625,9.754531860351562,13.5],"length":9,"rects":[[75.52161407470703,305.133056640625,87.79077911376953,13.5]],"start":280,"text":"自动内存管理的优点"}],"type":5,"uuid":"3720b37122e9cee7904cecbd60e82558"},{"content":"过于依赖自动内存管理","date":"2022-05-06 14:35:51","docid":0,"fillcolor":"ffffed99","id":844,"originaltext":"关于自动内存管理的担忧","page":216,"textblocks":[{"first":[75.52161407470703,402.428955078125,9.754531860351562,13.5],"last":[173.0669403076172,402.428955078125,9.754531860351562,13.5],"length":11,"rects":[[75.52161407470703,402.428955078125,107.29985809326172,13.5]],"start":430,"text":"关于自动内存管理的担忧"}],"type":5,"uuid":"563a24e453f19fe7db08b9fadfcf7f88"}],"originaltext":"自动内存管理","page":216,"textblocks":[{"first":[75.52161407470703,207.339599609375,14.631797790527344,17.5],"last":[148.68060302734375,207.339599609375,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,207.339599609375,87.7907943725586,17.5]],"start":187,"text":"自动内存管理"}],"type":5,"uuid":"2d109cfdb3fae1ab0e299ee5acf5e1fb"},{"date":"2022-05-06 14:34:53","docid":0,"fillcolor":"ffffed99","folded":true,"id":842,"markups":[{"date":"2022-05-06 14:38:25","docid":0,"fillcolor":"ffffed99","id":845,"markups":[{"date":"2022-05-06 14:38:54","docid":0,"fillcolor":"ffffed99","id":846,"originaltext":"频繁收集Young区","page":217,"textblocks":[{"first":[120.54253387451172,426.3399353027344,9.754524230957031,14.5],"last":[188.23365783691406,426.3399353027344,9.754531860351562,14.5],"length":10,"rects":[[120.54253387451172,426.3399353027344,77.4456558227539,14.5]],"start":77,"text":"频繁收集Young区"}],"type":5,"uuid":"cbb1afeae4f4019f4d8df993f6512824"},{"date":"2022-05-06 14:38:58","docid":0,"fillcolor":"ffffed99","id":847,"originaltext":"较少收集Old区","page":217,"textblocks":[{"first":[120.54253387451172,442.14678955078125,9.754524230957031,13.5],"last":[175.602294921875,442.14678955078125,9.754531860351562,13.5],"length":8,"rects":[[120.54253387451172,442.14678955078125,64.81429290771484,13.5]],"start":91,"text":"较少收集Old区"}],"type":5,"uuid":"233bb7fb9ebb413acdf00e1b94a29aa6"},{"date":"2022-05-06 14:39:02","docid":0,"fillcolor":"ffffed99","id":848,"originaltext":"基本不收集Perm区（元空间）","page":217,"textblocks":[{"first":[120.54253387451172,457.15386962890625,9.754524230957031,13.5],"last":[242.4884796142578,457.15386962890625,9.754531860351562,13.5],"length":15,"rects":[[120.54253387451172,457.15386962890625,131.70047760009766,13.5]],"start":103,"text":"基本不收集Perm区（元空间）"}],"type":5,"uuid":"8133cd5e96a5172a00a864377e3451c2"}],"originaltext":"Java堆是垃圾收集器的工作重点","page":217,"textblocks":[{"first":[127.29566955566406,387.67138671875,3.2287445068359375,12.5],"last":[255.15719604492188,387.67138671875,9.754547119140625,12.5],"length":16,"rects":[[127.29566955566406,387.67138671875,137.61607360839844,12.5]],"start":47,"text":"Java堆是垃圾收集器的工作重点"}],"type":5,"uuid":"0349abcf44d7b181ea08d29583b085bb"}],"originaltext":"应该关心哪些区域的回收？","page":216,"textblocks":[{"first":[75.52161407470703,541.9951171875,14.631797790527344,17.5],"last":[236.4713897705078,541.9951171875,14.631790161132812,17.5],"length":12,"rects":[[75.52161407470703,541.9951171875,175.5815658569336,17.5]],"start":712,"text":"应该关心哪些区域的回收？"}],"type":5,"uuid":"c23ae98276385893eeb81a650bed6d4e"}],"originaltext":"Java 垃圾回收机制","page":216,"textblocks":[{"first":[75.52161407470703,174.6256866455078,5.6503143310546875,21.5],"last":[201.291015625,174.6256866455078,17.0704345703125,21.5],"length":11,"rects":[[75.52161407470703,174.6256866455078,142.83983612060547,21.5]],"start":174,"text":"Java 垃圾回收机制"}],"type":5,"uuid":"ddc7ebfdbaee0f9b40b89e77b08ac0d3"}],"page":-1,"title":"垃圾回收概述","type":7,"uuid":"e2fe6b98a3f77e04808834d2550e4b3e"},{"date":"2022-05-06 14:39:58","docid":0,"fillcolor":"ffffed99","folded":false,"id":849,"markups":[{"date":"2022-05-06 14:43:15","docid":0,"fillcolor":"ffffed99","folded":true,"id":851,"markups":[{"content":"判断哪些对象应该被回收，哪些对象不应该被回收\n\n简单来讲当一个对象不在被任何一个存活对象继续引用的时候就可以认为死亡","date":"2022-05-06 14:51:13","docid":0,"fillcolor":"ffffed99","folded":true,"id":852,"markups":[{"date":"2022-05-06 14:51:20","docid":0,"fillcolor":"ffffed99","id":853,"originaltext":"主要是为了判断对象是否存活","page":217,"textblocks":[{"first":[143.80332946777344,624.781494140625,9.754531860351562,12.5],"last":[260.85772705078125,624.781494140625,9.7545166015625,12.5],"length":13,"rects":[[143.80332946777344,624.781494140625,126.80891418457031,12.5]],"start":162,"text":"主要是为了判断对象是否存活"}],"type":5,"uuid":"1c1ecc40c88bc7352f5e7b02b7c427e3"}],"originaltext":"标记阶段的目的","page":217,"textblocks":[{"first":[75.52161407470703,595.269775390625,14.631797790527344,17.5],"last":[163.31240844726562,595.269775390625,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,595.269775390625,102.42259979248047,17.5]],"start":146,"text":"标记阶段的目的"}],"type":5,"uuid":"f2536613685a20b9bcdad1af12ab5b6b"},{"content":"优点：简单高效\n缺点：需要存储空间，加减法操作需要时间，无法解决循环引用","date":"2022-05-06 14:51:54","docid":0,"fillcolor":"ffffed99","id":854,"originaltext":"引用计数算法","page":218,"textblocks":[{"first":[75.52161407470703,30.257080078125,14.631797790527344,17.5],"last":[148.68060302734375,30.257080078125,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,30.257080078125,87.7907943725586,17.5]],"start":0,"text":"引用计数算法"}],"type":5,"uuid":"d4764518fa03ba84203bad09b5c93595"}],"originaltext":"标记阶段：引用计数算法","page":217,"textblocks":[{"first":[75.52161407470703,563.3558349609375,17.07042694091797,20.5],"last":[246.22592163085938,563.3558349609375,17.0704345703125,20.5],"length":11,"rects":[[75.52161407470703,563.3558349609375,187.77474212646484,20.5]],"start":133,"text":"标记阶段：引用计数算法"}],"type":5,"uuid":"14c1a9e60d43e2d29aa9b50e7c9d467c"},{"date":"2022-05-06 14:59:46","docid":0,"fillcolor":"ffffed99","folded":true,"id":855,"markups":[{"content":"以根对象集合（GCRoots）为起点，引用链为路径，不可达的对象需要被回收","date":"2022-05-06 15:18:48","docid":0,"fillcolor":"ffffed99","id":857,"originaltext":"可达性分析实现思路","page":221,"textblocks":[{"first":[75.52161407470703,386.67333984375,14.631797790527344,17.5],"last":[192.5760040283203,386.67333984375,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,386.67333984375,131.6861801147461,17.5]],"start":466,"text":"可达性分析实现思路"}],"type":5,"uuid":"11807c2f39fd3c4c7d85ec4da900432a"},{"content":"一般除了堆空间之外的地点指向堆空间的对象都可以作为GCRoot对象\n\n也就说对哪一块进行垃圾回收，那么那个垃圾回收区域的对象就不能作为GCRoot","date":"2022-05-06 15:20:04","docid":0,"fillcolor":"ffffed99","folded":true,"id":858,"markups":[{"date":"2022-05-06 15:22:54","docid":0,"fillcolor":"ffffed99","id":859,"originaltext":"1. 虚拟机栈中引用的对象","page":222,"textblocks":[{"first":[87.52719116210938,446.94921875,5.57958984375,12.5],"last":[185.82286071777344,446.94921875,9.754531860351562,12.5],"length":13,"rects":[[87.52719116210938,446.94921875,108.05020141601562,12.5]],"start":20,"text":"1. 虚拟机栈中引用的对象"}],"type":5,"uuid":"e00b8db47e82869377616ef01023b63e"},{"date":"2022-05-06 15:22:59","docid":0,"fillcolor":"ffffed99","id":860,"originaltext":"2. 本地方法栈内JNI（通常说的本地方法）引用的对象","page":222,"textblocks":[{"first":[87.52719116210938,482.2158203125,5.57958984375,12.5],"last":[305.80169677734375,482.2158203125,9.7545166015625,12.5],"length":27,"rects":[[87.52719116210938,482.2158203125,228.02902221679688,12.5]],"start":62,"text":"2. 本地方法栈内JNI（通常说的本地方法）引用的对象"}],"type":5,"uuid":"05d3da2b7dceb88570253fe763fb3c3b"},{"date":"2022-05-06 15:23:05","docid":0,"fillcolor":"ffffed99","id":861,"originaltext":"3. 方法区中类静态属性引用的对象","page":222,"textblocks":[{"first":[87.52719116210938,501.724609375,5.57958984375,12.5],"last":[224.8409881591797,501.724609375,9.754531860351562,12.5],"length":17,"rects":[[87.52719116210938,501.724609375,147.06832885742188,12.5]],"start":90,"text":"3. 方法区中类静态属性引用的对象"}],"type":5,"uuid":"a8e5b9765f3e9825fd4e47bbc66c363c"},{"date":"2022-05-06 15:23:11","docid":0,"fillcolor":"ffffed99","id":862,"originaltext":"4. 方法区中常量引用的对象","page":222,"textblocks":[{"first":[87.52719116210938,536.9912109375,5.57958984375,12.5],"last":[195.577392578125,536.9912109375,9.754531860351562,12.5],"length":14,"rects":[[87.52719116210938,536.9912109375,117.80473327636719,12.5]],"start":126,"text":"4. 方法区中常量引用的对象"}],"type":5,"uuid":"9e38afe849338ad921fdc755ba8690c9"},{"date":"2022-05-06 15:23:23","docid":0,"fillcolor":"ffffed99","id":863,"originaltext":"5. 所有被同步锁synchronized持有的对象","page":222,"textblocks":[{"first":[87.52719116210938,570.4073486328125,5.57958984375,14.5],"last":[256.1050109863281,570.4073486328125,9.754547119140625,14.5],"length":26,"rects":[[87.52719116210938,570.4073486328125,178.33236694335938,14.5]],"start":168,"text":"5. 所有被同步锁synchronized持有的对象"}],"type":5,"uuid":"62376db84b21fe7902ab8545012b86dc"},{"date":"2022-05-06 15:23:29","docid":0,"fillcolor":"ffffed99","id":864,"originaltext":"6. Java虚拟机内部的引用。","page":222,"textblocks":[{"first":[87.52719116210938,592.7666015625,5.57958984375,12.5],"last":[194.4104766845703,592.7666015625,9.754531860351562,12.5],"length":16,"rects":[[87.52719116210938,592.7666015625,116.6378173828125,12.5]],"start":195,"text":"6. Java虚拟机内部的引用。"}],"type":5,"uuid":"c86e3b71c651b869e8033f7c0a81ba79"},{"date":"2022-05-06 15:23:36","docid":0,"fillcolor":"ffffed99","id":865,"originaltext":"7. 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。","page":222,"textblocks":[{"first":[87.52719116210938,640.1895751953125,5.57958984375,14.5],"last":[425.6805114746094,640.1895751953125,9.754547119140625,14.5],"length":45,"rects":[[87.52719116210938,640.1895751953125,347.9078674316406,14.5]],"start":289,"text":"7. 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。"}],"type":5,"uuid":"bbbd89af1c31367fc43aa144e9864610"}],"originaltext":"GC Roots可以是哪些元素？","page":222,"textblocks":[{"first":[75.52161407470703,417.9375,10.593421936035156,17.5],"last":[243.06570434570312,417.9375,14.631805419921875,17.5],"length":16,"rects":[[75.52161407470703,417.9375,182.17589569091797,17.5]],"start":2,"text":"GC Roots可以是哪些元素？"}],"type":5,"uuid":"8a3b5350c213a25acf4c268c1dd68aaf"},{"content":"一个引用指针指向堆内存中的对象，又不保存在堆中就是一个root","date":"2022-05-06 15:25:48","docid":0,"fillcolor":"ffffed99","id":866,"originaltext":"小技巧","page":223,"textblocks":[{"first":[75.52161407470703,570.0068359375,9.754531860351562,12.5],"last":[95.03067779541016,570.0068359375,9.754531860351562,12.5],"length":3,"rects":[[75.52161407470703,570.0068359375,29.263595581054688,12.5]],"start":338,"text":"小技巧"}],"type":5,"uuid":"1b0e09651bb150f92982392498404a05"}],"originaltext":"标记阶段：可达性分析算法","page":221,"textblocks":[{"first":[75.52161407470703,239.10546875,17.07042694091797,19.5],"last":[263.2963562011719,239.10546875,17.0704345703125,19.5],"length":12,"rects":[[75.52161407470703,239.10546875,204.84517669677734,19.5]],"start":254,"text":"标记阶段：可达性分析算法"}],"type":5,"uuid":"c0eb8ed1d6f09e2466a34e56fc7171fe"},{"date":"2022-05-06 15:27:55","docid":0,"fillcolor":"ffffed99","folded":true,"id":867,"markups":[{"content":"一个对象处理后事，通常进行资源的释放\n\n注意：\n永远不能主动去调用finalize()方法：\n1、可能会导致对象复活\n2、优先级较低，调用也不会回收\n3、影响GC","date":"2022-05-06 15:33:34","docid":0,"fillcolor":"ffffed99","id":869,"originaltext":"finalize() 方法机制","page":224,"textblocks":[{"first":[75.52161407470703,29.956836700439453,5.662506103515625,18.5],"last":[186.43179321289062,29.956836700439453,14.631805419921875,18.5],"length":15,"rects":[[75.52161407470703,29.956836700439453,125.54198455810547,18.5]],"start":0,"text":"finalize() 方法机制"}],"type":5,"uuid":"6911e068d64a515264f8512e7507c949"},{"content":"由于finalize()方法的存在，对象有三种状态：\n1、可触及\n2、可复活（finalize()）\n3、不可触及","date":"2022-05-06 15:34:01","docid":0,"fillcolor":"ffffed99","folded":true,"id":870,"markups":[{"date":"2022-05-06 15:43:47","docid":0,"fillcolor":"ffffed99","id":871,"originaltext":"1. 可触及的","page":224,"textblocks":[{"first":[110.03765106201172,597.7685546875,5.57958984375,12.5],"last":[149.80612182617188,597.7685546875,9.754531860351562,12.5],"length":7,"rects":[[110.03765106201172,597.7685546875,49.52300262451172,12.5]],"start":834,"text":"1. 可触及的"}],"type":5,"uuid":"91c0f27722cbef48d64636d306e23c4a"},{"content":"有可能刀下留人成功","date":"2022-05-06 15:43:52","docid":0,"fillcolor":"ffffed99","id":872,"originaltext":"2. 可复活的","page":224,"textblocks":[{"first":[110.03765106201172,612.775390625,5.57958984375,12.5],"last":[149.80612182617188,612.775390625,9.754531860351562,12.5],"length":7,"rects":[[110.03765106201172,612.775390625,49.52300262451172,12.5]],"start":859,"text":"2. 可复活的"}],"type":5,"uuid":"e20692f7a07751e85bd9277ab854b5ab"},{"content":"只能被调用一次","date":"2022-05-06 15:43:57","docid":0,"fillcolor":"ffffed99","id":873,"originaltext":"3. 不可触及的","page":224,"textblocks":[{"first":[110.03765106201172,627.7822265625,5.57958984375,12.5],"last":[159.56065368652344,627.7822265625,9.754531860351562,12.5],"length":8,"rects":[[110.03765106201172,627.7822265625,59.27753448486328,12.5]],"start":902,"text":"3. 不可触及的"}],"type":5,"uuid":"8dde3c8865809ae84c0864b4ccc6e9e8"}],"originaltext":"生存还是死亡？","page":224,"textblocks":[{"first":[75.52161407470703,479.4658203125,14.631797790527344,17.5],"last":[163.31240844726562,479.4658203125,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,479.4658203125,102.42259979248047,17.5]],"start":630,"text":"生存还是死亡？"}],"type":5,"uuid":"2dd1d761adec11c2c8518dc4631fc1be"},{"content":"有两次可达性分析算法标记的机会，如果finalize()方法中成功与一个GCRoot联系上，那么就是可复活状态，之后又被标记就直接不可触及","date":"2022-05-06 15:44:15","docid":0,"fillcolor":"ffffed99","id":874,"originaltext":"具体过程","page":225,"textblocks":[{"first":[75.52161407470703,30.2568359375,14.631797790527344,17.5],"last":[119.41700744628906,30.2568359375,14.631790161132812,17.5],"length":4,"rects":[[75.52161407470703,30.2568359375,58.527183532714844,17.5]],"start":0,"text":"具体过程"}],"type":5,"uuid":"e3b77871c957dd743e856235ddce6894"}],"originaltext":"对象的 finalization 机制","page":223,"textblocks":[{"first":[75.52161407470703,778.0054931640625,17.07042694091797,19.5],"last":[249.4849853515625,778.0054931640625,17.0704345703125,19.5],"length":19,"rects":[[75.52161407470703,778.0054931640625,191.03380584716797,19.5]],"start":573,"text":"对象的 finalization 机制"}],"type":5,"uuid":"7061217c7cf2fa838816e5d9549e8ae8"},{"content":"正常的使用，但是需要进行碎片整理","date":"2022-05-06 15:58:58","docid":0,"fillcolor":"ffffed99","folded":true,"id":875,"markups":[{"date":"2022-05-06 15:59:18","docid":0,"fillcolor":"ffffed99","folded":true,"id":876,"markups":[{"date":"2022-05-06 15:59:42","docid":0,"fillcolor":"ffffed99","id":877,"originaltext":"1. 标记-清除算法（Mark-Sweep）","page":238,"textblocks":[{"first":[87.52719116210938,182.47811889648438,5.57958984375,14.5],"last":[225.788818359375,182.47811889648438,9.754531860351562,14.5],"length":22,"rects":[[87.52719116210938,182.47811889648438,148.0161590576172,14.5]],"start":123,"text":"1. 标记-清除算法（Mark-Sweep）"}],"type":5,"uuid":"7c0eef44ef79111b5ced43ed920bd563"},{"date":"2022-05-06 15:59:46","docid":0,"fillcolor":"ffffed99","id":878,"originaltext":"2. 复制算法（Copying）","page":238,"textblocks":[{"first":[87.52719116210938,197.48593139648438,5.57958984375,14.5],"last":[183.54141235351562,197.48593139648438,9.754531860351562,14.5],"length":16,"rects":[[87.52719116210938,197.48593139648438,105.76875305175781,14.5]],"start":146,"text":"2. 复制算法（Copying）"}],"type":5,"uuid":"25d4ec4ca81be252404cafb80dfa3b32"},{"date":"2022-05-06 15:59:48","docid":0,"fillcolor":"ffffed99","id":879,"originaltext":"3. 标记-压缩算法（Mark-Compact）","page":238,"textblocks":[{"first":[87.52719116210938,212.49179077148438,5.57958984375,14.5],"last":[236.53404235839844,212.49179077148438,9.754531860351562,14.5],"length":24,"rects":[[87.52719116210938,212.49179077148438,158.76138305664062,14.5]],"start":163,"text":"3. 标记-压缩算法（Mark-Compact）"}],"type":5,"uuid":"a03d7d7d86ff071d7871b035c664e1e9"}],"originaltext":"垃圾清除阶段","page":238,"textblocks":[{"first":[75.52161407470703,107.79296875,9.754531860351562,12.5],"last":[124.29427337646484,107.79296875,9.754524230957031,12.5],"length":6,"rects":[[75.52161407470703,107.79296875,58.527183532714844,12.5]],"start":18,"text":"垃圾清除阶段"}],"type":5,"uuid":"23d93bbb44d4f6d3ef2eec46bdc096a7"},{"content":"执行gc的时候会停止整个程序\n1、标记：标记的是可达对象，不是垃圾\n（是否是可达对象，记录在对象头中）\n2、清除：进行线性遍历，只要在头像头中发现不是可达对象就直接回收","date":"2022-05-06 15:59:57","docid":0,"fillcolor":"ffffed99","id":880,"originaltext":"执行过程","page":238,"textblocks":[{"first":[75.52161407470703,365.912109375,9.754531860351562,12.5],"last":[104.78520965576172,365.912109375,9.754531860351562,12.5],"length":4,"rects":[[75.52161407470703,365.912109375,39.01812744140625,12.5]],"start":272,"text":"执行过程"}],"type":5,"uuid":"a0b7797cfd4f57316fdf27865374c00a"},{"content":"缺点：\n1、效率居中\n2、不是异步\n3、清除出来的空间不连续，所以需要维护空闲列表\n（空闲列表在创建对象的时候需要进行使用）","date":"2022-05-06 16:00:05","docid":0,"fillcolor":"ffffed99","id":881,"originaltext":"标记-清除算法的缺点","page":239,"textblocks":[{"first":[75.52161407470703,419.9375,9.754531860351562,12.5],"last":[156.6966552734375,419.9375,9.754531860351562,12.5],"length":10,"rects":[[75.52161407470703,419.9375,90.92957305908203,12.5]],"start":2,"text":"标记-清除算法的缺点"}],"type":5,"uuid":"202257035680f1ca07683727f60cb91e"},{"content":"注意：清除不是真的清除，只是将占用区域放到空闲列表中，以便下一次存储直接覆盖，其实就是逻辑删除","date":"2022-05-06 16:00:09","docid":0,"fillcolor":"ffffed99","id":882,"originaltext":"注意：何为清除？","page":239,"textblocks":[{"first":[75.52161407470703,494.97265625,9.754531860351562,12.5],"last":[143.80332946777344,494.97265625,9.754531860351562,12.5],"length":8,"rects":[[75.52161407470703,494.97265625,78.03624725341797,12.5]],"start":98,"text":"注意：何为清除？"}],"type":5,"uuid":"5cc3f394852c2cc6fd667a94741ba863"}],"originaltext":"清除阶段：标记-清除算法","page":238,"textblocks":[{"first":[75.52161407470703,53.771484375,17.07042694091797,19.5],"last":[251.71881103515625,53.771484375,17.0704345703125,19.5],"length":12,"rects":[[75.52161407470703,53.771484375,193.26763153076172,19.5]],"start":2,"text":"清除阶段：标记-清除算法"}],"type":5,"uuid":"ef615fab0152f44e96e3fd880647bfb7"},{"content":"一般用于新生代","date":"2022-05-06 16:31:11","docid":0,"fillcolor":"ffffed99","folded":true,"id":883,"markups":[{"content":"将活着的内存空间分为两块内存空间\n使用新生代区域中的from、to区域对对象的分配思想\n每次清除都进行复制到新的区域，原区域逻辑删除","date":"2022-05-07 13:55:46","docid":0,"fillcolor":"ffffed99","id":884,"originaltext":"核心思想","page":240,"textblocks":[{"first":[75.52161407470703,90.53515625,9.754531860351562,12.5],"last":[104.78520965576172,90.53515625,9.754531860351562,12.5],"length":4,"rects":[[75.52161407470703,90.53515625,39.01812744140625,12.5]],"start":90,"text":"核心思想"}],"type":5,"uuid":"fa5822493d1967e3eb3dca4cfaf7e5dd"},{"date":"2022-05-07 14:00:04","docid":0,"fillcolor":"ffffed99","folded":true,"id":885,"markups":[{"content":"1、运行高效\n2、空间整洁，不会出现碎片","date":"2022-05-07 14:01:39","docid":0,"fillcolor":"ffffed99","id":886,"originaltext":"优点","page":240,"textblocks":[{"first":[75.52161407470703,527.98828125,9.754531860351562,12.5],"last":[85.2761459350586,527.98828125,9.754531860351562,12.5],"length":2,"rects":[[75.52161407470703,527.98828125,19.509063720703125,12.5]],"start":240,"text":"优点"}],"type":5,"uuid":"174d295be8aa6aabd1e370865df300b1"},{"content":"1、需要占用两倍的内存空间\n2、栈空间中的引用指向由于堆中存储位置的改变需要维护，开销较大\n\n如果全部对象都是活着，垃圾较少，那么","date":"2022-05-07 14:01:44","docid":0,"fillcolor":"ffffed99","id":887,"originaltext":"缺点","page":240,"textblocks":[{"first":[75.52161407470703,612.02734375,9.754531860351562,12.5],"last":[85.2761459350586,612.02734375,9.754531860351562,12.5],"length":2,"rects":[[75.52161407470703,612.02734375,19.509063720703125,12.5]],"start":298,"text":"缺点"}],"type":5,"uuid":"6d3726a863f95e97726b4febc62810f3"}],"originaltext":"复制算法的优缺点","page":240,"textblocks":[{"first":[75.52161407470703,504.478515625,9.754531860351562,13.5],"last":[143.80332946777344,504.478515625,9.754531860351562,13.5],"length":8,"rects":[[75.52161407470703,504.478515625,78.03624725341797,13.5]],"start":231,"text":"复制算法的优缺点"}],"type":5,"uuid":"c6888b9706e58fa74007899c836b95fe"},{"content":"如果全部对象都是活着，垃圾较少，那么性价比非常低\n所以对于新生代中的对象清除复制算法非常适用","date":"2022-05-07 14:04:28","docid":0,"fillcolor":"ffffed99","id":888,"originaltext":"复制算法的应用场景","page":240,"textblocks":[{"first":[75.52161407470703,710.32421875,9.754531860351562,13.5],"last":[153.557861328125,710.32421875,9.754531860351562,13.5],"length":9,"rects":[[75.52161407470703,710.32421875,87.79077911376953,13.5]],"start":407,"text":"复制算法的应用场景"}],"type":5,"uuid":"437121fac852410cb00f4258be540eab"}],"originaltext":"清除阶段：复制算法","page":239,"textblocks":[{"first":[75.52161407470703,717.828125,17.07042694091797,19.5],"last":[212.08506774902344,717.828125,17.0704345703125,19.5],"length":9,"rects":[[75.52161407470703,717.828125,153.6338882446289,19.5]],"start":281,"text":"清除阶段：复制算法"}],"type":5,"uuid":"396cc5769a05b588282c047e5304f75f"},{"content":"一般用于老年代","date":"2022-05-07 14:07:21","docid":0,"fillcolor":"ffffed99","folded":false,"id":889,"markups":[{"content":"1、使用可达性分析算法标记被引用的对象\n2、将标记的对象压缩到内存的一端","date":"2022-05-07 14:13:48","docid":0,"fillcolor":"ffffed99","id":890,"originaltext":"执行过程","page":241,"textblocks":[{"first":[75.52161407470703,524.984375,9.754531860351562,12.5],"last":[104.78520965576172,524.984375,9.754531860351562,12.5],"length":4,"rects":[[75.52161407470703,524.984375,39.01812744140625,12.5]],"start":380,"text":"执行过程"}],"type":5,"uuid":"e355575de0770dec7ac8b8149cc3a1b3"},{"content":"1、相当于使用标记清除算法后进行一次碎片整理\n2、移动式算法，栈中的引用需要重新进行指向\n3、节省维护成本","date":"2022-05-07 14:15:53","docid":0,"fillcolor":"ffffed99","id":894,"originaltext":"标记-压缩算法与标记-清除算法的比较","page":242,"textblocks":[{"first":[75.52161407470703,423.689453125,9.754531860351562,12.5],"last":[228.11717224121094,423.689453125,9.754531860351562,12.5],"length":18,"rects":[[75.52161407470703,423.689453125,162.35009002685547,12.5]],"start":2,"text":"标记-压缩算法与标记-清除算法的比较"}],"type":5,"uuid":"25a693816c83bfaa331922dbbf5898e4"},{"date":"2022-05-07 14:13:58","docid":0,"fillcolor":"ffffed99","id":891,"markups":[{"content":"1、整理了内存空间\n2、解决了复制算法内存减半的问题","date":"2022-05-07 14:14:00","docid":0,"fillcolor":"ffffed99","id":892,"originaltext":"优点","page":242,"textblocks":[{"first":[75.52161407470703,627.783203125,9.754531860351562,12.5],"last":[85.2761459350586,627.783203125,9.754531860351562,12.5],"length":2,"rects":[[75.52161407470703,627.783203125,19.509063720703125,12.5]],"start":302,"text":"优点"}],"type":5,"uuid":"d0ffe0af6e0ecd22d9ac08ec631788c4"},{"content":"1、效率低于复制算法\n2、内存移位需要重新指向（内存移位需要暂停应用程序，也就是STW）","date":"2022-05-07 14:14:06","docid":0,"fillcolor":"ffffed99","id":893,"originaltext":"缺点","page":242,"textblocks":[{"first":[75.52161407470703,726.080078125,9.754531860351562,12.5],"last":[85.2761459350586,726.080078125,9.754531860351562,12.5],"length":2,"rects":[[75.52161407470703,726.080078125,19.509063720703125,12.5]],"start":393,"text":"缺点"}],"type":5,"uuid":"65d542207b824ea8fa278fe9890d5351"}],"originaltext":"标记-压缩算法的优缺点","page":242,"textblocks":[{"first":[75.52161407470703,582.013671875,9.754531860351562,12.5],"last":[166.45118713378906,582.013671875,9.754531860351562,12.5],"length":11,"rects":[[75.52161407470703,582.013671875,100.6841049194336,12.5]],"start":288,"text":"标记-压缩算法的优缺点"}],"type":5,"uuid":"ab71260ece82cc4610a49af94a7c0653"}],"originaltext":"清除阶段：标记-压缩算法","page":241,"textblocks":[{"first":[75.52161407470703,274.4710998535156,17.07042694091797,20.5],"last":[251.71881103515625,274.4710998535156,17.0704345703125,20.5],"length":12,"rects":[[75.52161407470703,274.4710998535156,193.26763153076172,20.5]],"start":2,"text":"清除阶段：标记-压缩算法"}],"type":5,"uuid":"2a5a010a20a4e011d04174d9fa0b0b97"},{"content":"复制算法最快空间规整，牺牲了内存空间大小，移动对象\n\n压缩算法最慢，空间上大并且规整，移动对象，相当于清除加整理\n\n清除算法中等但是内存不规整","date":"2022-05-07 14:32:06","docid":0,"fillcolor":"ffffed99","id":895,"originaltext":"垃圾回收算法小结","page":243,"textblocks":[{"first":[75.52161407470703,29.0078125,17.07042694091797,19.5],"last":[195.01463317871094,29.0078125,17.0704345703125,19.5],"length":8,"rects":[[75.52161407470703,29.0078125,136.5634536743164,19.5]],"start":79,"text":"垃圾回收算法小结"}],"type":5,"uuid":"d27e9fb9852b498aa3cdd3662d1e2ef0"},{"content":"选择合适的算法\n使用分代收集算法配合复制、清除、压缩算法\n\n对于新生代结合特点使用复制算法\n对于老年代结合特点使用压缩算法或者清除算法\n\n（因为老年代和新生代的比例是2:1\n而新生代中的s0，s1和伊甸园区域比例是1:1:8，也就是说复制算法最终浪费的区域只是1/30\n）\n\nCMS对老年代使用标记清除算法，其中的随便整理，只有到了碎片到了一定的程度，才会触发FullGC进行压缩算法","date":"2022-05-07 14:42:07","docid":0,"fillcolor":"ffffed99","id":896,"originaltext":"分代收集算法","page":243,"textblocks":[{"first":[75.52161407470703,350.158203125,17.07042694091797,20.5],"last":[160.87376403808594,350.158203125,17.0704345703125,20.5],"length":6,"rects":[[75.52161407470703,350.158203125,102.4225845336914,20.5]],"start":225,"text":"分代收集算法"}],"type":5,"uuid":"c4e6d7aababc0b64c711cf3f6c9f1c0c"},{"content":"都是为了降低STW的时间\n增量收集：时间上调和线程运行\n分区：空间上分割小区域回收","date":"2022-05-07 14:42:13","docid":0,"fillcolor":"ffffed99","folded":true,"id":897,"markups":[{"content":"使用并发调和两个线程的运行\n解决由于标记算法执行期间导致的STW\n（就是所有应用程序暂停一切工作挂起）","date":"2022-05-07 14:50:28","docid":0,"fillcolor":"ffffed99","folded":true,"id":898,"markups":[{"content":"将垃圾回收线程和应用程序线程并发执行\n垃圾回收线程每次只回收一个小区域","date":"2022-05-07 14:52:55","docid":0,"fillcolor":"ffffed99","id":900,"originaltext":"增量收集算法基本思想","page":244,"textblocks":[{"first":[75.52161407470703,515.982421875,9.754531860351562,12.5],"last":[163.31240844726562,515.982421875,9.754531860351562,12.5],"length":10,"rects":[[75.52161407470703,515.982421875,97.54532623291016,12.5]],"start":741,"text":"增量收集算法基本思想"}],"type":5,"uuid":"2ffd860d3c00fc7ac962cb765d3e2db5"},{"content":"线程上下文切换","date":"2022-05-07 14:56:15","docid":0,"fillcolor":"ffffed99","id":901,"originaltext":"增量收集算法的缺点","page":244,"textblocks":[{"first":[75.52161407470703,644.29296875,9.754531860351562,13.5],"last":[153.557861328125,644.29296875,9.754531860351562,13.5],"length":9,"rects":[[75.52161407470703,644.29296875,87.79077911376953,13.5]],"start":944,"text":"增量收集算法的缺点"}],"type":5,"uuid":"f4d5bb8cc385f27e5c398b001b43bac5"}],"originaltext":"增量收集算法","page":244,"textblocks":[{"first":[75.52161407470703,371.41796875,14.631797790527344,17.5],"last":[148.68060302734375,371.41796875,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,371.41796875,87.7907943725586,17.5]],"start":527,"text":"增量收集算法"}],"type":5,"uuid":"2ca71b32fe142920badd9b5d0994c49d"},{"content":"对堆空间进行分区，做到只回收一个小区域，来限制STW耗费的时间\n\n分区算法对标的就是分代算法","date":"2022-05-07 14:50:37","docid":0,"fillcolor":"ffffed99","id":899,"originaltext":"分区算法","page":245,"textblocks":[{"first":[75.52161407470703,30.2578125,14.631797790527344,17.5],"last":[119.41700744628906,30.2578125,14.631790161132812,17.5],"length":4,"rects":[[75.52161407470703,30.2578125,58.527183532714844,17.5]],"start":0,"text":"分区算法"}],"type":5,"uuid":"17333b11d21ae67601f876474510fe2f"}],"originaltext":"增量收集算法和分区算法","page":244,"textblocks":[{"first":[75.52161407470703,339.404296875,17.07042694091797,20.5],"last":[246.22592163085938,339.404296875,17.0704345703125,20.5],"length":11,"rects":[[75.52161407470703,339.404296875,187.77474212646484,20.5]],"start":514,"text":"增量收集算法和分区算法"}],"type":5,"uuid":"ffe7f92376e83129637f4c2dbe80720c"}],"originaltext":"垃圾回收相关算法","page":217,"textblocks":[{"first":[75.52161407470703,526.99072265625,21.94770050048828,24.5],"last":[229.15550231933594,526.99072265625,21.94769287109375,24.5],"length":8,"rects":[[75.52161407470703,526.99072265625,175.58158111572266,24.5]],"start":123,"text":"垃圾回收相关算法"}],"type":5,"uuid":"850819575c3028bd5a9be46612bbfe0c"}],"originaltext":"垃圾回收概述","page":213,"textblocks":[{"first":[75.52161407470703,84.7859115600586,21.94770050048828,24.5],"last":[185.26010131835938,84.7859115600586,21.94769287109375,24.5],"length":6,"rects":[[75.52161407470703,84.7859115600586,131.6861801147461,24.5]],"start":2,"text":"垃圾回收概述"}],"title":"第10章-垃圾回收概述和相关算法","type":5,"uuid":"f103fb073aa46523dadafe92be0f6091"},{"date":"2022-05-07 15:06:47","docid":0,"fillcolor":"ffffed99","folded":false,"id":902,"markups":[{"content":"提醒JVM需要调用Full GC，但是无法确保立即生效\n\n（对新生代老年代回收，尝试对堆和方法区进行回收）\n\n一般情况不手动触发","date":"2022-05-07 15:07:06","docid":0,"fillcolor":"ffffed99","id":903,"originaltext":"System.gc() 的理解","page":246,"textblocks":[{"first":[75.52161407470703,121.35090637207031,9.405807495117188,21.5],"last":[210.80978393554688,121.35090637207031,17.0704345703125,21.5],"length":15,"rects":[[75.52161407470703,121.35090637207031,152.35860443115234,21.5]],"start":12,"text":"System.gc() 的理解"}],"type":5,"uuid":"a0c945097f5a5a7a78ddf02958cb18be"},{"date":"2022-05-07 15:32:29","docid":0,"fillcolor":"ffffed99","folded":true,"id":904,"markups":[{"content":"大致情况就是内存泄漏导致内存溢出OOM","date":"2022-05-07 15:55:11","docid":0,"fillcolor":"ffffed99","id":905,"originaltext":"内存溢出","page":253,"textblocks":[{"first":[75.52161407470703,30.25732421875,14.631797790527344,17.5],"last":[119.41700744628906,30.25732421875,14.631790161132812,17.5],"length":4,"rects":[[75.52161407470703,30.25732421875,58.527183532714844,17.5]],"start":0,"text":"内存溢出"}],"type":5,"uuid":"7effaea5f31d535392843d8d53db2626"},{"content":"没有引用堆中的对象，但是GC又不能回收他们","date":"2022-05-07 15:55:53","docid":0,"fillcolor":"ffffed99","folded":true,"id":906,"markups":[{"date":"2022-05-07 16:03:08","docid":0,"fillcolor":"ffffed99","id":907,"originaltext":"内存泄露官方例子","page":254,"textblocks":[{"first":[75.52161407470703,119.5478515625,9.754531860351562,13.5],"last":[143.80332946777344,119.5478515625,9.754531860351562,13.5],"length":8,"rects":[[75.52161407470703,119.5478515625,78.03624725341797,13.5]],"start":142,"text":"内存泄露官方例子"}],"type":5,"uuid":"a829683882b7563b1847c06a22fb86bf"},{"date":"2022-05-07 16:03:12","docid":0,"fillcolor":"ffffed99","id":908,"originaltext":"常见例子","page":254,"textblocks":[{"first":[75.52161407470703,474.21142578125,9.754531860351562,12.5],"last":[104.78520965576172,474.21142578125,9.754531860351562,12.5],"length":4,"rects":[[75.52161407470703,474.21142578125,39.01812744140625,12.5]],"start":285,"text":"常见例子"}],"type":5,"uuid":"f0f4c1467121cd2c43eedfc6a2508e7d"}],"originaltext":"内存泄漏","page":253,"textblocks":[{"first":[75.52161407470703,677.0576171875,14.631797790527344,17.5],"last":[119.41700744628906,677.0576171875,14.631790161132812,17.5],"length":4,"rects":[[75.52161407470703,677.0576171875,58.527183532714844,17.5]],"start":1088,"text":"内存泄漏"}],"type":5,"uuid":"bfc0e6e88727d2a8bc51131bba250bb7"}],"originaltext":"内存溢出与内存泄漏","page":252,"textblocks":[{"first":[75.52161407470703,759.0966796875,17.07042694091797,19.5],"last":[212.08506774902344,759.0966796875,17.0704345703125,19.5],"length":9,"rects":[[75.52161407470703,759.0966796875,153.6338882446289,19.5]],"start":53,"text":"内存溢出与内存泄漏"}],"type":5,"uuid":"e02867d65f47057cf77e69cc32796c9e"},{"content":"停下所有的用户线程，所有的GC执行可达性分析算法的时候都会执行\n只能不断地削弱STW，但不能消失","date":"2022-05-07 16:08:13","docid":0,"fillcolor":"ffffed99","id":909,"originaltext":"Stop the World","page":254,"textblocks":[{"first":[75.52161407470703,627.8861083984375,9.405807495117188,20.5],"last":[191.32742309570312,627.8861083984375,10.805587768554688,20.5],"length":14,"rects":[[75.52161407470703,627.8861083984375,126.61139678955078,20.5]],"start":469,"text":"Stop the World"}],"type":5,"uuid":"4a1139b4511becfeb86120c18ddabb29"},{"date":"2022-05-07 16:10:45","docid":0,"fillcolor":"ffffed99","folded":true,"id":910,"markups":[{"date":"2022-05-07 16:10:58","docid":0,"fillcolor":"ffffed99","id":911,"originaltext":"并发的概念","page":256,"textblocks":[{"first":[75.52161407470703,586.265625,14.631797790527344,17.5],"last":[134.04879760742188,586.265625,14.631805419921875,17.5],"length":5,"rects":[[75.52161407470703,586.265625,73.15898895263672,17.5]],"start":125,"text":"并发的概念"}],"type":5,"uuid":"bc80e2eb397adfb7b6c6c5a15d30b416"},{"date":"2022-05-07 16:11:03","docid":0,"fillcolor":"ffffed99","id":912,"originaltext":"并行的概念","page":257,"textblocks":[{"first":[75.52161407470703,343.15234375,14.631797790527344,17.5],"last":[134.04879760742188,343.15234375,14.631805419921875,17.5],"length":5,"rects":[[75.52161407470703,343.15234375,73.15898895263672,17.5]],"start":2,"text":"并行的概念"}],"type":5,"uuid":"eec92a4b0177cd274fd006241e7618a6"},{"content":"整体：垃圾回收线程和用户线程串行地情况，不管怎样垃圾回收线程地时候用户线程都会STW","date":"2022-05-07 16:11:09","docid":0,"fillcolor":"ffffed99","folded":true,"id":913,"markups":[{"content":"多条垃圾回收线程同一时刻运行","date":"2022-05-07 16:12:56","docid":0,"fillcolor":"ffffed99","id":914,"originaltext":"1. 并行（Parallel）","page":258,"textblocks":[{"first":[87.52719116210938,145.0085906982422,5.57958984375,13.5],"last":[160.87449645996094,145.0085906982422,9.754531860351562,13.5],"length":15,"rects":[[87.52719116210938,145.0085906982422,83.10183715820312,13.5]],"start":72,"text":"1. 并行（Parallel）"}],"type":5,"uuid":"ed31fd4b70e9de6f7d7ba253ec4520c0"},{"content":"单条垃圾回收线程运行","date":"2022-05-07 16:15:01","docid":0,"fillcolor":"ffffed99","id":915,"originaltext":"2. 串行（Serial）","page":258,"textblocks":[{"first":[87.52719116210938,180.3251953125,5.57958984375,12.5],"last":[152.46311950683594,180.3251953125,9.754531860351562,12.5],"length":13,"rects":[[87.52719116210938,180.3251953125,74.69046020507812,12.5]],"start":157,"text":"2. 串行（Serial）"}],"type":5,"uuid":"2e13db5c1278e5fc40a85d4c57821029"},{"content":"同一时间段垃圾回收线程和用户线程一起运行","date":"2022-05-07 16:15:45","docid":0,"fillcolor":"ffffed99","id":916,"originaltext":"1. 并发（Concurrent）","page":258,"textblocks":[{"first":[87.52719116210938,424.13848876953125,5.57958984375,13.5],"last":[178.82608032226562,424.13848876953125,9.754531860351562,13.5],"length":17,"rects":[[87.52719116210938,424.13848876953125,101.05342102050781,13.5]],"start":256,"text":"1. 并发（Concurrent）"}],"type":5,"uuid":"59f5d4e95dd9ab725d97aa34648aeccd"}],"originaltext":"垃圾回收的并发与并行","page":258,"textblocks":[{"first":[75.52161407470703,91.5361328125,14.631797790527344,17.5],"last":[207.20779418945312,91.5361328125,14.631805419921875,17.5],"length":10,"rects":[[75.52161407470703,91.5361328125,146.31798553466797,17.5]],"start":58,"text":"垃圾回收的并发与并行"}],"type":5,"uuid":"c05811e10c1c86e3ba2a3fae8a2a92bc"}],"originaltext":"垃圾回收的并行与并发","page":256,"textblocks":[{"first":[75.52161407470703,554.251953125,17.07042694091797,20.5],"last":[229.15550231933594,554.251953125,17.0704345703125,20.5],"length":10,"rects":[[75.52161407470703,554.251953125,170.7043228149414,20.5]],"start":113,"text":"垃圾回收的并行与并发"}],"type":5,"uuid":"f17803139c79d8be1a9c8914fe7e6b0c"},{"date":"2022-05-07 16:18:12","docid":0,"fillcolor":"ffffed99","folded":true,"id":917,"markups":[{"date":"2022-05-07 16:35:40","docid":0,"fillcolor":"ffffed99","id":923,"originaltext":"根节点枚举","page":259,"textblocks":[{"first":[75.52161407470703,30.2568359375,14.631797790527344,17.5],"last":[134.04879760742188,30.2568359375,14.631805419921875,17.5],"length":5,"rects":[[75.52161407470703,30.2568359375,73.15898895263672,17.5]],"start":0,"text":"根节点枚举"}],"type":5,"uuid":"aa66d7a4d22d10c02b5decbc73d42086"},{"date":"2022-05-07 16:18:51","docid":0,"fillcolor":"ffffed99","folded":false,"id":918,"markups":[{"content":"不是任何的时候都能进行GC，需要等到一个特定的安全点才能进行GC，这个特定的时间点就是安全点\n\n1、太多的安全点导致STW频繁影响性能，太少STW持续时间过长\n\n所以一般选择方法调用、循环跳转设置安全点","date":"2022-05-07 16:19:21","docid":0,"fillcolor":"ffffed99","folded":false,"id":919,"markups":[{"content":"1、抢占式中断：直接中断所有线程，不在安全点就恢复线程知道安全点\n（当前不使用）\n2、主动式专断：设置主动轮询中断标志，为真就进行中断","date":"2022-05-07 16:23:18","docid":0,"fillcolor":"ffffed99","id":920,"originaltext":"如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？","page":259,"textblocks":[{"first":[75.52161407470703,657.0458984375,9.754531860351562,12.5],"last":[352.173095703125,657.0458984375,9.7545166015625,12.5],"length":30,"rects":[[75.52161407470703,657.0458984375,286.40599822998047,12.5]],"start":1371,"text":"如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？"}],"type":5,"uuid":"4613a6981c0c96f194899460a00bf692"}],"originaltext":"安全点（Safepoint）","page":259,"textblocks":[{"first":[75.52161407470703,528.4363403320312,9.754531860351562,13.5],"last":[161.17860412597656,528.4363403320312,9.754531860351562,13.5],"length":14,"rects":[[75.52161407470703,528.4363403320312,95.4115219116211,13.5]],"start":1137,"text":"安全点（Safepoint）"}],"type":5,"uuid":"1ff061c77ef231f56c58aba876b03dac"},{"content":"针对不能走到安全点的线程设置安全区域\n（一般陷入Blocker或者sleep的线程）\n\n安全区域：在一段代码片段中引用关系不会发生任何改变，就是安全区域","date":"2022-05-07 16:25:25","docid":0,"fillcolor":"ffffed99","id":921,"markups":[{"content":"1、线程进入安全区域会标识已经进入安全区域，并让JVM忽略这个线程\n2、线程需要离开安全区域的时候会检查是否完成可达性分析，没有就等待","date":"2022-05-07 16:27:49","docid":0,"fillcolor":"ffffed99","id":922,"originaltext":"安全区域的执行流程","page":260,"textblocks":[{"first":[75.52161407470703,164.568359375,9.754531860351562,13.5],"last":[153.557861328125,164.568359375,9.754531860351562,13.5],"length":9,"rects":[[75.52161407470703,164.568359375,87.79077911376953,13.5]],"start":270,"text":"安全区域的执行流程"}],"type":5,"uuid":"68ec4fb581a1ae4fbaf946eb1ece3b29"}],"originaltext":"安全区域（Safe Region）","page":259,"textblocks":[{"first":[75.52161407470703,769.2486572265625,9.754531860351562,14.5],"last":[180.7733917236328,769.2486572265625,9.754531860351562,14.5],"length":17,"rects":[[75.52161407470703,769.2486572265625,115.00630950927734,14.5]],"start":1532,"text":"安全区域（Safe Region）"}],"type":5,"uuid":"b0635d519ab1f23d4b56d66127c416f4"}],"originaltext":"安全点与安全区域","page":259,"textblocks":[{"first":[75.52161407470703,499.224609375,14.631797790527344,17.5],"last":[177.94419860839844,499.224609375,14.631790161132812,17.5],"length":8,"rects":[[75.52161407470703,499.224609375,117.05437469482422,17.5]],"start":1127,"text":"安全点与安全区域"}],"type":5,"uuid":"28e4a8982eb8f645756dea62254eb007"},{"date":"2022-05-07 16:36:07","docid":0,"fillcolor":"ffffed99","id":924,"originaltext":"记忆集与卡表","page":260,"textblocks":[{"first":[75.52161407470703,280.6240234375,14.631797790527344,17.5],"last":[148.68060302734375,280.6240234375,14.631805419921875,17.5],"length":6,"rects":[[75.52161407470703,280.6240234375,87.7907943725586,17.5]],"start":471,"text":"记忆集与卡表"}],"type":5,"uuid":"7bdf7b0008a2aee4bd0769f8d5e15551"}],"originaltext":"HotSpot的算法实现细节","page":258,"textblocks":[{"first":[75.52161407470703,742.6398315429688,13.058876037597656,21.5],"last":[247.1678009033203,742.6398315429688,17.070419311523438,21.5],"length":14,"rects":[[75.52161407470703,742.6398315429688,188.71660614013672,21.5]],"start":386,"text":"HotSpot的算法实现细节"}],"type":5,"uuid":"152759cf1d4a21d889ed79e8f750da9b"},{"content":"对于一些引用只有内存足够的情况下才会被保存在内存中，而这些内存引用就是为了这些情况而存在的\n\n都是可触及的","date":"2022-05-07 16:36:40","docid":0,"fillcolor":"ffffed99","folded":true,"id":925,"markups":[{"date":"2022-05-07 16:39:58","docid":0,"fillcolor":"ffffed99","id":927,"originaltext":"2. 既偏门又非常高频的面试题：强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？","page":261,"textblocks":[{"first":[87.52719116210938,729.0791015625,5.57958984375,12.5],"last":[107.78660583496094,745.0859375,9.754531860351562,10.5],"length":48,"rects":[[87.52719116210938,729.0791015625,420.1952209472656,12.5],[98.03207397460938,745.0859375,19.509063720703125,10.5]],"start":1335,"text":"2. 既偏门又非常高频的面试题：强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什\n么？"}],"type":5,"uuid":"46dd15b35a3b4805d125a51d0f769d35"},{"content":"只要有引用关系，打死也不回收","date":"2022-05-07 16:40:09","docid":0,"fillcolor":"ffffed99","id":928,"originaltext":"1. 强引用（StrongReference）","page":262,"textblocks":[{"first":[87.52719116210938,307.0337829589844,5.57958984375,14.5],"last":[212.89073181152344,307.0337829589844,9.754531860351562,14.5],"length":23,"rects":[[87.52719116210938,307.0337829589844,135.11807250976562,14.5]],"start":198,"text":"1. 强引用（StrongReference）"}],"type":5,"uuid":"3988dd33651af6a234a86af4bc935639"},{"content":"内存不足，既回收","date":"2022-05-07 16:40:12","docid":0,"fillcolor":"ffffed99","id":929,"originaltext":"2. 软引用（SoftReference）","page":262,"textblocks":[{"first":[87.52719116210938,353.9052734375,5.57958984375,12.5],"last":[200.88333129882812,353.9052734375,9.754531860351562,12.5],"length":21,"rects":[[87.52719116210938,353.9052734375,123.11067199707031,12.5]],"start":345,"text":"2. 软引用（SoftReference）"}],"type":5,"uuid":"3575d1922dc91501c483c4acb14a022f"},{"content":"只要垃圾回收器工作，都会将其回收","date":"2022-05-07 16:40:14","docid":0,"fillcolor":"ffffed99","id":930,"originaltext":"3. 弱引用（WeakReference）","page":262,"textblocks":[{"first":[87.52719116210938,383.919921875,5.57958984375,12.5],"last":[207.93727111816406,383.919921875,9.754531860351562,12.5],"length":21,"rects":[[87.52719116210938,383.919921875,130.16461181640625,12.5]],"start":433,"text":"3. 弱引用（WeakReference）"}],"type":5,"uuid":"b3c54ef3c7e618966cb44a9c27da8f48"},{"content":"获取一个对象的虚引用，只为了能够在其垃圾回收的时候获得一个通知","date":"2022-05-07 16:40:17","docid":0,"fillcolor":"ffffed99","id":931,"originaltext":"4. 虚引用（PhantomReference）","page":262,"textblocks":[{"first":[87.52719116210938,413.93359375,5.57958984375,12.5],"last":[224.5695037841797,413.93359375,9.754531860351562,12.5],"length":24,"rects":[[87.52719116210938,413.93359375,146.79684448242188,12.5]],"start":517,"text":"4. 虚引用（PhantomReference）"}],"type":5,"uuid":"2c019f063757e320a5410888532ce604"}],"originaltext":"再谈引用概述","page":261,"textblocks":[{"first":[75.52161407470703,639.541015625,17.07042694091797,20.5],"last":[160.87376403808594,639.541015625,17.0704345703125,20.5],"length":6,"rects":[[75.52161407470703,639.541015625,102.4225845336914,20.5]],"start":1257,"text":"再谈引用概述"}],"type":5,"uuid":"32603c98bbcd90323db863241cbd2604"},{"content":"1、默认new创建的的引用\n2、强引用是可触及的，只要对象被引用，那么GC就不会回收\n3、造成内存泄漏的的主要原因","date":"2022-05-07 16:37:17","docid":0,"fillcolor":"ffffed99","folded":true,"id":926,"markups":[{"date":"2022-05-07 17:28:29","docid":0,"fillcolor":"ffffed99","id":938,"originaltext":"永远不会回收","page":262,"textblocks":[{"first":[293.1227111816406,582.01171875,9.754547119140625,12.5],"last":[341.8953857421875,582.01171875,9.7545166015625,12.5],"length":6,"rects":[[293.1227111816406,582.01171875,58.527191162109375,12.5]],"start":802,"text":"永远不会回收"}],"type":5,"uuid":"4e6e2a06475366559b1c55b22e15ec73"},{"content":"1、可直接访问对象\n2、只要强引用引用了对象，对象打死也不会回收\n3、造成内存泄漏的原因之一","date":"2022-05-07 17:19:01","docid":0,"fillcolor":"ffffed99","id":932,"originaltext":"总结","page":263,"textblocks":[{"first":[75.52161407470703,491.9697265625,9.754531860351562,12.5],"last":[85.2761459350586,491.9697265625,9.754531860351562,12.5],"length":2,"rects":[[75.52161407470703,491.9697265625,19.509063720703125,12.5]],"start":133,"text":"总结"}],"type":5,"uuid":"8fd670de1cfc52ac860f811df23e03c7"}],"originaltext":"再谈引用：强引用","page":262,"textblocks":[{"first":[75.52161407470703,490.4716796875,17.07042694091797,19.5],"last":[195.01463317871094,490.4716796875,17.0704345703125,19.5],"length":8,"rects":[[75.52161407470703,490.4716796875,136.5634536743164,19.5]],"start":636,"text":"再谈引用：强引用"}],"type":5,"uuid":"28b83b5f62a652e0a9184da4c6d57977"},{"date":"2022-05-07 17:20:06","docid":0,"fillcolor":"ffffed99","folded":true,"id":933,"markups":[{"content":"在发生OOM之前会回收这些软引用的对象\n\n通常用来做缓存","date":"2022-05-07 17:20:42","docid":0,"fillcolor":"ffffed99","id":934,"originaltext":"软引用（Soft Reference）：内存不足即回收","page":263,"textblocks":[{"first":[75.52161407470703,637.9880981445312,9.754531860351562,13.5],"last":[263.6583251953125,637.9880981445312,9.7545166015625,13.5],"length":27,"rects":[[75.52161407470703,637.9880981445312,197.89122772216797,13.5]],"start":261,"text":"软引用（Soft Reference）：内存不足即回收"}],"type":5,"uuid":"27a9866b0a44e1747c71bb4b353e041a"}],"originaltext":"再谈引用：软引用","page":263,"textblocks":[{"first":[75.52161407470703,606.7763671875,17.07042694091797,19.5],"last":[195.01463317871094,606.7763671875,17.0704345703125,19.5],"length":8,"rects":[[75.52161407470703,606.7763671875,136.5634536743164,19.5]],"start":251,"text":"再谈引用：软引用"}],"type":5,"uuid":"31cc0192aca739cc5d3e2b57f13006e1"},{"content":"只被弱引用关联的对象，只能存活到下一次垃圾回收\n\n用来保存可有可无的数据","date":"2022-05-07 17:24:54","docid":0,"fillcolor":"ffffed99","folded":true,"id":935,"markups":[{"date":"2022-05-07 17:28:17","docid":0,"fillcolor":"ffffed99","id":937,"originaltext":"弱引用（Weak Reference）发现即回收","page":265,"textblocks":[{"first":[89.77823638916016,487.2177734375,9.754531860351562,12.5],"last":[256.3625793457031,487.2177734375,9.754547119140625,12.5],"length":24,"rects":[[89.77823638916016,487.2177734375,176.3388900756836,12.5]],"start":63,"text":"弱引用（Weak Reference）发现即回收"}],"type":5,"uuid":"67d6dce5ba9cfb7571b66d0314a384f6"},{"content":"底层用的就是弱引用","date":"2022-05-07 17:28:59","docid":0,"fillcolor":"ffffed99","id":939,"originaltext":"面试题：你开发中使用过WeakHashMap吗？","page":266,"textblocks":[{"first":[75.52161407470703,89.4332046508789,9.754531860351562,14.5],"last":[265.58734130859375,89.4332046508789,9.7545166015625,14.5],"length":24,"rects":[[75.52161407470703,89.4332046508789,199.82024383544922,14.5]],"start":87,"text":"面试题：你开发中使用过WeakHashMap吗？"}],"type":5,"uuid":"248df7aa796a624c60b804102a12defc"}],"originaltext":"再谈引用：弱引用","page":265,"textblocks":[{"first":[75.52161407470703,455.2060546875,17.07042694091797,19.5],"last":[195.01463317871094,455.2060546875,17.0704345703125,19.5],"length":8,"rects":[[75.52161407470703,455.2060546875,136.5634536743164,19.5]],"start":53,"text":"再谈引用：弱引用"}],"type":5,"uuid":"9a9c9157a2a4d55874df36f03021db39"},{"content":"为了跟踪该对象的垃圾回收过程\n需要配合引用队列一起使用","date":"2022-05-07 17:27:35","docid":0,"fillcolor":"ffffed99","folded":true,"id":936,"markups":[{"date":"2022-05-07 17:31:08","docid":0,"fillcolor":"ffffed99","id":940,"originaltext":"虚引用（Phantom Reference）：对象回收跟踪","page":266,"textblocks":[{"first":[75.52161407470703,799.3123168945312,9.754531860351562,13.5],"last":[279.1712951660156,799.3123168945312,9.754547119140625,13.5],"length":29,"rects":[[75.52161407470703,799.3123168945312,213.40422821044922,13.5]],"start":155,"text":"虚引用（Phantom Reference）：对象回收跟踪"}],"type":5,"uuid":"4d7b00800507bcca38b31bc8175064a7"}],"originaltext":"再谈引用：虚引用","page":266,"textblocks":[{"first":[75.52161407470703,768.1005859375,17.07042694091797,19.5],"last":[195.01463317871094,768.1005859375,17.0704345703125,19.5],"length":8,"rects":[[75.52161407470703,768.1005859375,136.5634536743164,19.5]],"start":145,"text":"再谈引用：虚引用"}],"type":5,"uuid":"c64c25d516e7ccecd2d1ea0135f6a82e"},{"date":"2022-05-07 17:33:08","docid":0,"fillcolor":"ffffed99","id":941,"originaltext":"再谈引用：终结器引用（了解）","page":269,"textblocks":[{"first":[75.52161407470703,198.68789672851562,17.07042694091797,20.5],"last":[297.4372253417969,198.68789672851562,17.0704345703125,20.5],"length":14,"rects":[[75.52161407470703,198.68789672851562,238.98604583740234,20.5]],"start":2,"text":"再谈引用：终结器引用（了解）"}],"type":5,"uuid":"d5128ea8125845a61b227aeee1b1b9ac"}],"originaltext":"垃圾回收相关概念","page":246,"textblocks":[{"first":[75.52161407470703,85.88591003417969,21.94770050048828,25.5],"last":[229.15550231933594,85.88591003417969,21.94769287109375,25.5],"length":8,"rects":[[75.52161407470703,85.88591003417969,175.58158111572266,25.5]],"start":2,"text":"垃圾回收相关概念"}],"title":"第11章-垃圾回收相关概念","type":5,"uuid":"29e83512b255dcf34aa3b97cbfdc1634"},{"date":"2022-05-08 00:24:17","docid":0,"fillcolor":"ffffed99","folded":false,"id":943,"markups":[{"date":"2022-05-08 00:23:53","docid":0,"fillcolor":"ffffed99","folded":false,"id":942,"markups":[{"date":"2022-05-09 09:17:31","docid":0,"fillcolor":"ffffed99","id":946,"originaltext":"垃圾回收器概述","page":270,"textblocks":[{"first":[75.52161407470703,154.06484985351562,14.631797790527344,17.5],"last":[163.31240844726562,154.06484985351562,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,154.06484985351562,102.42259979248047,17.5]],"start":21,"text":"垃圾回收器概述"}],"type":5,"uuid":"abb0bf57783ff59f753e833df5490976"},{"content":"线程数分类：串行垃圾回收器、并行垃圾回收器","date":"2022-05-09 09:17:36","docid":0,"fillcolor":"ffffed99","folded":false,"id":947,"markups":[{"content":"指垃圾回收器线程的线程数\n\n串行垃圾回收器：不适合单CPU处理器场景","date":"2022-05-09 09:18:49","docid":0,"fillcolor":"ffffed99","id":948,"originaltext":"线程数","page":270,"textblocks":[{"first":[85.2761459350586,389.9225769042969,9.754531860351562,12.5],"last":[104.78520965576172,389.9225769042969,9.754531860351562,12.5],"length":3,"rects":[[85.2761459350586,389.9225769042969,29.263595581054688,12.5]],"start":299,"text":"线程数"}],"type":5,"uuid":"951303be03e8bd77a024b8a05fa78e4f"},{"content":"按工作模式分：\n并发式垃圾回收、独占式垃圾回收\n\n并发式垃圾回收就是垃圾回收线程和工作线程一起运行\n\n独占式垃圾回收要求垃圾回收线程运行的时候工作线程必须停止","date":"2022-05-09 09:19:27","docid":0,"fillcolor":"ffffed99","id":949,"originaltext":"工作模式","page":271,"textblocks":[{"first":[95.03067779541016,173.07177734375,9.754531860351562,12.5],"last":[124.29427337646484,173.07177734375,9.754524230957031,12.5],"length":4,"rects":[[95.03067779541016,173.07177734375,39.01811981201172,12.5]],"start":232,"text":"工作模式"}],"type":5,"uuid":"655ac76b4fcdc319582afad85bf5acee"},{"content":"压缩式垃圾回收器：会碎片整理，使用指针碰撞分配内存\n\n非压缩式垃圾回收器：不会碎片整理，使用空闲列表分配内存","date":"2022-05-09 09:29:24","docid":0,"fillcolor":"ffffed99","id":950,"originaltext":"碎片处理方式","page":271,"textblocks":[{"first":[85.2761459350586,492.47064208984375,9.754531860351562,13.5],"last":[134.04879760742188,492.47064208984375,9.754531860351562,13.5],"length":6,"rects":[[85.2761459350586,492.47064208984375,58.527183532714844,13.5]],"start":367,"text":"碎片处理方式"}],"type":5,"uuid":"d3381dafd3ff1a5a4f43f554e2bba466"},{"content":"年轻代垃圾回收器\n老年代垃圾回收器","date":"2022-05-09 09:29:30","docid":0,"fillcolor":"ffffed99","id":951,"originaltext":"工作的内存区间","page":271,"textblocks":[{"first":[85.2761459350586,591.7662963867188,9.754531860351562,12.5],"last":[143.80332946777344,591.7662963867188,9.754531860351562,12.5],"length":7,"rects":[[85.2761459350586,591.7662963867188,68.2817153930664,12.5]],"start":490,"text":"工作的内存区间"}],"type":5,"uuid":"725b178836b237a4f384571b357f1998"}],"originaltext":"垃圾回收器分类","page":270,"textblocks":[{"first":[75.52161407470703,359.41070556640625,14.631797790527344,17.5],"last":[163.31240844726562,359.41070556640625,14.631805419921875,17.5],"length":7,"rects":[[75.52161407470703,359.41070556640625,102.42259979248047,17.5]],"start":289,"text":"垃圾回收器分类"}],"type":5,"uuid":"00a14dcca1c5d9880d48307ea5fa0043"},{"content":"吞吐量、暂停时间、内存占用构成不可能三角：优秀的GC只会占用其中两者\n\n重点关注吞吐量和暂停时间","date":"2022-05-09 09:38:32","docid":0,"fillcolor":"ffffed99","folded":true,"id":952,"markups":[{"date":"2022-05-09 09:42:27","docid":0,"fillcolor":"ffffed99","id":953,"originaltext":"1. 吞吐量","page":271,"textblocks":[{"first":[87.52719116210938,714.8235473632812,5.57958984375,12.5],"last":[117.5411376953125,714.8235473632812,9.754531860351562,12.5],"length":6,"rects":[[87.52719116210938,714.8235473632812,39.76847839355469,12.5]],"start":542,"text":"1. 吞吐量"}],"type":5,"uuid":"c2124133228ee40a8accbbe52d8fc64e"},{"date":"2022-05-09 09:42:30","docid":0,"fillcolor":"ffffed99","id":954,"originaltext":"2. 垃圾收集开销","page":271,"textblocks":[{"first":[87.52719116210938,744.8374633789062,5.57958984375,12.5],"last":[146.8047332763672,744.8374633789062,9.754531860351562,12.5],"length":9,"rects":[[87.52719116210938,744.8374633789062,69.03207397460938,12.5]],"start":596,"text":"2. 垃圾收集开销"}],"type":5,"uuid":"8be88559c19fd444163be1e98394911d"},{"date":"2022-05-09 09:42:33","docid":0,"fillcolor":"ffffed99","id":955,"originaltext":"3. 暂停时间","page":271,"textblocks":[{"first":[87.52719116210938,759.8444213867188,5.57958984375,12.5],"last":[127.29566955566406,759.8444213867188,9.754531860351562,12.5],"length":7,"rects":[[87.52719116210938,759.8444213867188,49.52301025390625,12.5]],"start":632,"text":"3. 暂停时间"}],"type":5,"uuid":"05b200aac1b5dafce83ad2cad16a70aa"},{"date":"2022-05-09 09:42:35","docid":0,"fillcolor":"ffffed99","id":956,"originaltext":"4. 收集频率","page":271,"textblocks":[{"first":[87.52719116210938,774.8513793945312,5.57958984375,12.5],"last":[127.29566955566406,774.8513793945312,9.754531860351562,12.5],"length":7,"rects":[[87.52719116210938,774.8513793945312,49.52301025390625,12.5]],"start":663,"text":"4. 收集频率"}],"type":5,"uuid":"6db8470432470189922ce021641cb424"},{"date":"2022-05-09 09:42:46","docid":0,"fillcolor":"ffffed99","id":957,"originaltext":"5. 内存占用","page":271,"textblocks":[{"first":[87.52719116210938,789.8583374023438,5.57958984375,12.5],"last":[127.29566955566406,789.8583374023438,9.754531860351562,12.5],"length":7,"rects":[[87.52719116210938,789.8583374023438,49.52301025390625,12.5]],"start":693,"text":"5. 内存占用"}],"type":5,"uuid":"f9ad0c2d860080baf87159dfcae59018"},{"date":"2022-05-09 09:42:51","docid":0,"fillcolor":"ffffed99","id":958,"originaltext":"6. 快速","page":272,"textblocks":[{"first":[87.52719116210938,29.75537109375,5.57958984375,12.5],"last":[107.78660583496094,29.75537109375,9.754531860351562,12.5],"length":5,"rects":[[87.52719116210938,29.75537109375,30.013946533203125,12.5]],"start":0,"text":"6. 快速"}],"type":5,"uuid":"aaf0984b5935bffbd9a4a57437e43cc0"},{"content":"用户线程运行的时间和总时间之比\n\n由于单个GC时间长，回收的效率较高，所以不用多次回收，吞吐量就高","date":"2022-05-09 09:56:29","docid":0,"fillcolor":"ffffed99","id":959,"originaltext":"吞吐量（throughput）","page":272,"textblocks":[{"first":[75.52161407470703,236.50192260742188,9.754531860351562,14.5],"last":[170.80453491210938,236.50192260742188,9.754531860351562,14.5],"length":15,"rects":[[75.52161407470703,236.50192260742188,105.0374526977539,14.5]],"start":232,"text":"吞吐量（throughput）"}],"type":5,"uuid":"fc70b23f0f39c923db29321f177fe91c"},{"content":"也就是STW\n如果STW时间短，那么回收效率较低，就需要多次去回收","date":"2022-05-09 09:57:47","docid":0,"fillcolor":"ffffed99","id":960,"originaltext":"暂停时间（pause time）","page":272,"textblocks":[{"first":[75.52161407470703,498.42315673828125,9.754531860351562,13.5],"last":[178.46812438964844,498.42315673828125,9.754531860351562,13.5],"length":16,"rects":[[75.52161407470703,498.42315673828125,112.70104217529297,13.5]],"start":456,"text":"暂停时间（pause time）"}],"type":5,"uuid":"e905d3879111742eb40bf4e670c4c2ac"},{"content":"所以由于回收的效率的固定，导致吞吐量和暂停时间的此消彼长\n\n要求在最大吞吐量的情况下，尽量降低停顿时间STW","date":"2022-05-09 10:04:51","docid":0,"fillcolor":"ffffed99","id":961,"originaltext":"吞吐量 vs 暂停时间","page":272,"textblocks":[{"first":[75.52161407470703,726.328369140625,9.754531860351562,12.5],"last":[149.5141143798828,726.328369140625,9.754531860351562,12.5],"length":11,"rects":[[75.52161407470703,726.328369140625,83.74703216552734,12.5]],"start":626,"text":"吞吐量 vs 暂停时间"}],"type":5,"uuid":"30173578d7fd30dedae81ee49497be46"}],"originaltext":"评估 GC 的性能指标","page":271,"textblocks":[{"first":[75.52161407470703,638.5403442382812,14.631797790527344,17.5],"last":[190.832763671875,638.5403442382812,14.631805419921875,17.5],"length":11,"rects":[[75.52161407470703,638.5403442382812,129.94295501708984,17.5]],"start":524,"text":"评估 GC 的性能指标"}],"type":5,"uuid":"abd4169a62a90922bb811a34164b4e1c"}],"originaltext":"GC 分类与性能指标","page":270,"textblocks":[{"first":[75.52161407470703,122.0509033203125,12.358993530273438,19.5],"last":[205.61697387695312,122.0509033203125,17.0704345703125,19.5],"length":10,"rects":[[75.52161407470703,122.0509033203125,147.1657943725586,19.5]],"start":9,"text":"GC 分类与性能指标"}],"title":"GC 分类与性能指标","type":5,"uuid":"f6deddaae667ebbbfb81c387f715e261"},{"date":"2022-05-09 10:06:20","docid":0,"fillcolor":"ffffed99","folded":false,"id":962,"markups":[{"date":"2022-05-09 10:18:37","docid":0,"fillcolor":"ffffed99","id":963,"originaltext":"垃圾收集器发展史","page":273,"textblocks":[{"first":[75.52161407470703,328.145751953125,14.631797790527344,17.5],"last":[177.94419860839844,328.145751953125,14.631790161132812,17.5],"length":8,"rects":[[75.52161407470703,328.145751953125,117.05437469482422,17.5]],"start":512,"text":"垃圾收集器发展史"}],"type":5,"uuid":"ae78dcea0ec1b7421281eb5e24cd02b2"},{"date":"2022-05-09 10:18:41","docid":0,"fillcolor":"ffffed99","folded":false,"id":964,"markups":[{"date":"2022-05-09 10:19:06","docid":0,"fillcolor":"ffffed99","id":965,"originaltext":"1. 串行回收器","page":273,"textblocks":[{"first":[87.52719116210938,698.0159301757812,5.57958984375,13.5],"last":[137.05020141601562,698.0159301757812,9.754531860351562,13.5],"length":8,"rects":[[87.52719116210938,698.0159301757812,59.27754211425781,13.5]],"start":1174,"text":"1. 串行回收器"}],"type":5,"uuid":"e3d165f7e2cec0a40dfa461878959400"},{"date":"2022-05-09 10:19:11","docid":0,"fillcolor":"ffffed99","id":966,"originaltext":"2. 并行回收器","page":273,"textblocks":[{"first":[87.52719116210938,712.2227783203125,5.57958984375,14.5],"last":[137.05020141601562,712.2227783203125,9.754531860351562,14.5],"length":8,"rects":[[87.52719116210938,712.2227783203125,59.27754211425781,14.5]],"start":1201,"text":"2. 并行回收器"}],"type":5,"uuid":"6af72920800997b6ad4e23f9e4802d73"},{"date":"2022-05-09 10:19:16","docid":0,"fillcolor":"ffffed99","id":967,"originaltext":"3. 并发回收器","page":273,"textblocks":[{"first":[87.52719116210938,728.0298461914062,5.57958984375,13.5],"last":[137.05020141601562,728.0298461914062,9.754531860351562,13.5],"length":8,"rects":[[87.52719116210938,728.0298461914062,59.27754211425781,13.5]],"start":1248,"text":"3. 并发回收器"}],"type":5,"uuid":"bdab7f7f3da92a0195e111c23d6f79d8"},{"date":"2022-05-09 10:20:08","docid":0,"fillcolor":"ffffed99","id":968,"originaltext":"7款经典回收器与垃圾分代之间的关系","page":274,"textblocks":[{"first":[75.52161407470703,648.543212890625,5.5698394775390625,13.5],"last":[227.40748596191406,648.543212890625,9.754531860351562,13.5],"length":17,"rects":[[75.52161407470703,648.543212890625,161.6404037475586,13.5]],"start":7,"text":"7款经典回收器与垃圾分代之间的关系"}],"type":5,"uuid":"d0c205950d15299f5007cc58f1afddab"}],"originaltext":"7款经典的垃圾收集器","page":273,"textblocks":[{"first":[75.52161407470703,646.29345703125,8.354759216308594,17.5],"last":[200.92784118652344,646.29345703125,14.631790161132812,17.5],"length":10,"rects":[[75.52161407470703,646.29345703125,140.03801727294922,17.5]],"start":1160,"text":"7款经典的垃圾收集器"}],"type":5,"uuid":"c39d808084ece8d19635af75859ae5b9"},{"content":"CMS与ParallelScavenge不能组合是因为ParallelScavenge架构不一样","date":"2022-05-09 10:20:20","docid":0,"fillcolor":"ffffed99","id":969,"originaltext":"垃圾收集器的组合关系","page":275,"textblocks":[{"first":[75.52161407470703,76.529052734375,14.631797790527344,17.5],"last":[207.20779418945312,76.529052734375,14.631805419921875,17.5],"length":10,"rects":[[75.52161407470703,76.529052734375,146.31798553466797,17.5]],"start":15,"text":"垃圾收集器的组合关系"}],"type":5,"uuid":"4c06e63fd079ca725c733f0362a2d200"}],"originaltext":"不同的垃圾回收器概述","page":273,"textblocks":[{"first":[75.52161407470703,256.4632873535156,17.07042694091797,20.5],"last":[229.15550231933594,256.4632873535156,17.0704345703125,20.5],"length":10,"rects":[[75.52161407470703,256.4632873535156,170.7043228149414,20.5]],"start":434,"text":"不同的垃圾回收器概述"}],"type":5,"uuid":"79db647c250e071a016f389429695419"},{"content":"最早的串行的新生代垃圾回收器，在单线程下效率较高","date":"2022-05-09 10:36:39","docid":0,"fillcolor":"ffffed99","folded":true,"id":970,"markups":[{"content":"1、HotSpot中Client模式下默认的垃圾回收器（Serial GC配合Serial Old GC）\n2、使用标记复制算法\n3、在老年代也提供 Serial Old GC使用标记压缩算法\n4、在JDK14之前可以配合Parallel Scavenge的新生代垃圾回收器进行垃圾回收\n5、在JDK14之前可以配合CMS的老年代垃圾回收器进行垃圾回收\n\n6、现在只能配合Parallel GC进行垃圾回收","date":"2022-05-09 10:38:01","docid":0,"fillcolor":"ffffed99","id":971,"originaltext":"Serial 回收器：串行回收","page":277,"textblocks":[{"first":[75.52161407470703,51.96562576293945,5.374748229980469,13.499996185302734],"last":[173.74803161621094,51.96562576293945,9.754531860351562,13.499996185302734],"length":15,"rects":[[75.52161407470703,51.96562576293945,107.98094940185547,13.499996185302734]],"start":2,"text":"Serial 回收器：串行回收"}],"type":5,"uuid":"8602088b8994a49f8bc86860caeb3617"},{"content":"简单高效","date":"2022-05-09 10:45:27","docid":0,"fillcolor":"ffffed99","id":972,"originaltext":"Serial 回收器的优势","page":277,"textblocks":[{"first":[75.52161407470703,443.94775390625,5.374748229980469,12.5],"last":[154.2389678955078,443.94775390625,9.754531860351562,12.5],"length":13,"rects":[[75.52161407470703,443.94775390625,88.47188568115234,12.5]],"start":513,"text":"Serial 回收器的优势"}],"type":5,"uuid":"a51b53aea01daebab45cf904dfdb9eb9"},{"content":"1、不能满足交互性较强的引用","date":"2022-05-09 10:46:28","docid":0,"fillcolor":"ffffed99","id":973,"originaltext":"总结","page":277,"textblocks":[{"first":[75.52161407470703,617.2783203125,9.754531860351562,12.5],"last":[85.2761459350586,617.2783203125,9.754531860351562,12.5],"length":2,"rects":[[75.52161407470703,617.2783203125,19.509063720703125,12.5]],"start":821,"text":"总结"}],"type":5,"uuid":"b497848bb04d87320648c11559c70939"}],"originaltext":"Serial 回收器：串行回收","page":276,"textblocks":[{"first":[75.52161407470703,775.0040283203125,9.405807495117188,19.5],"last":[247.41786193847656,775.0040283203125,17.070419311523438,19.5],"length":15,"rects":[[75.52161407470703,775.0040283203125,188.96666717529297,19.5]],"start":306,"text":"Serial 回收器：串行回收"}],"type":5,"uuid":"e54c3b6aad8412d77e8731441bce6f2a"},{"content":"1、是在Serial的多线程版本\n2、并行回收\n3、新生代采用标记复制算法，老年代一般使用Serial old GC，采用标记压缩算法\n4、JDK9之前可有选择Serial old GC作为老年代垃圾回收器，JDK14之前可以选择CMS并发垃圾回收器作为老年代垃圾回收器\n5、","date":"2022-05-09 10:48:17","docid":0,"fillcolor":"ffffed99","folded":true,"id":974,"markups":[{"content":"单线程下ParNew比不过Serial GC，因为线程上下文切换耗费的资源远远高于单个执行的开销\n多线程下优于ParNew","date":"2022-05-09 10:54:28","docid":0,"fillcolor":"ffffed99","id":975,"originaltext":"ParNew 回收器与 Serial 回收器比较","page":278,"textblocks":[{"first":[75.52161407470703,357.40771484375,6.125846862792969,12.5],"last":[227.05979919433594,357.40771484375,9.754531860351562,12.5],"length":24,"rects":[[75.52161407470703,357.40771484375,161.29271697998047,12.5]],"start":309,"text":"ParNew 回收器与 Serial 回收器比较"}],"type":5,"uuid":"ab18e22220a99bf9c960b5e1fad6f85a"}],"originaltext":"ParNew 回收器：并行回收","page":277,"textblocks":[{"first":[75.52161407470703,731.4339599609375,10.720230102539062,20.5],"last":[266.8054504394531,731.4339599609375,17.0704345703125,20.5],"length":15,"rects":[[75.52161407470703,731.4339599609375,208.3542709350586,20.5]],"start":940,"text":"ParNew 回收器：并行回收"}],"type":5,"uuid":"9e3ca5a8c447cb79c759ca040ea219d8"},{"date":"2022-05-09 10:59:20","docid":0,"fillcolor":"ffffed99","folded":false,"id":976,"markups":[{"content":"与ParNew差不多，不同点在于：\n1、吞吐量可控制，吞吐量优先\n2、自适应调节策略\n\n特点：\n1、比较适合不需要太多交互的任务\n2、吞吐量可控制\n3、自适应调节策略\n4、可以选择与Parallel Old老年代垃圾回收器配合，在JDK14之前可以选择与 Serial Old GC老年代垃圾回收器配合，","date":"2022-05-09 10:59:28","docid":0,"fillcolor":"ffffed99","id":977,"originaltext":"Parallel Scavenge 回收器：吞吐量优先","page":278,"textblocks":[{"first":[75.52161407470703,714.5237426757812,6.125846862792969,13.5],"last":[240.9342803955078,714.5237426757812,9.754531860351562,13.5],"length":27,"rects":[[75.52161407470703,714.5237426757812,175.16719818115234,13.5]],"start":798,"text":"Parallel Scavenge 回收器：吞吐量优先"}],"type":5,"uuid":"81490f62166e6eea20e5e7f594137cf7"},{"date":"2022-05-09 11:07:30","docid":0,"fillcolor":"ffffed99","id":978,"originaltext":"在Java8中，默认是此垃圾收集器","page":279,"textblocks":[{"first":[98.03207397460938,369.3135681152344,9.754531860351562,14.5],"last":[231.4615020751953,369.3135681152344,9.754531860351562,14.5],"length":17,"rects":[[98.03207397460938,369.3135681152344,143.1839599609375,14.5]],"start":469,"text":"在Java8中，默认是此垃圾收集器"}],"type":5,"uuid":"c159cd9106bd0ad373d632bb681a26a0"}],"originaltext":"Parallel 回收器：吞吐量优先","page":278,"textblocks":[{"first":[75.52161407470703,661.7017822265625,10.720230102539062,19.5],"last":[281.3253173828125,661.7017822265625,17.0704345703125,19.5],"length":18,"rects":[[75.52161407470703,661.7017822265625,222.87413787841797,19.5]],"start":776,"text":"Parallel 回收器：吞吐量优先"}],"type":5,"uuid":"7bc9f5d2db8014c28c84c81d5ff2869e"},{"date":"2022-05-09 11:07:47","docid":0,"fillcolor":"ffffed99","folded":true,"id":979,"markups":[{"content":"特点：\n1、专门用于交互（强交互）\n2、并发垃圾回收器，实现了用户线程和垃圾回收线程的同时工作\n3、在老年代中使用标记清除算法\n4、在JDK14中被删除","date":"2022-05-09 11:08:20","docid":0,"fillcolor":"ffffed99","id":980,"originaltext":"CMS 回收器","page":280,"textblocks":[{"first":[75.52161407470703,140.3076171875,9.320457458496094,13.5],"last":[139.76434326171875,140.3076171875,14.631805419921875,13.5],"length":7,"rects":[[75.52161407470703,140.3076171875,78.8745346069336,13.5]],"start":116,"text":"CMS 回收器"}],"type":5,"uuid":"eb6bd475db3bb3edeedb4e039f6bdc33"},{"date":"2022-05-09 11:10:27","docid":0,"fillcolor":"ffffed99","folded":false,"id":981,"markups":[{"content":"仅寻找GCRoots能直接关联到的对象，所以STW很短","date":"2022-05-09 11:14:17","docid":0,"fillcolor":"ffffed99","id":982,"originaltext":"1. 初始标记（Initial-Mark）阶段","page":280,"textblocks":[{"first":[87.52719116210938,630.0341796875,5.57958984375,12.5],"last":[217.76324462890625,630.0341796875,9.754531860351562,12.5],"length":23,"rects":[[87.52719116210938,630.0341796875,139.99058532714844,12.5]],"start":785,"text":"1. 初始标记（Initial-Mark）阶段"}],"type":5,"uuid":"3bdea07187bf0164bae83f4690bf858c"},{"content":"并发的寻找，从GCRoots找到整个关联到的对象","date":"2022-05-09 11:14:23","docid":0,"fillcolor":"ffffed99","id":983,"originaltext":"2. 并发标记（Concurrent-Mark）阶段","page":280,"textblocks":[{"first":[87.52719116210938,690.0625,5.57958984375,12.5],"last":[244.31671142578125,690.0625,9.754531860351562,12.5],"length":26,"rects":[[87.52719116210938,690.0625,166.54405212402344,12.5]],"start":944,"text":"2. 并发标记（Concurrent-Mark）阶段"}],"type":5,"uuid":"c1ac2812f182df99ba2e2e370766363e"},{"content":"修正并发标记期间变动的一些对象（怀不能确定是否是真的是垃圾的对象），修正的话STW很短","date":"2022-05-09 11:14:32","docid":0,"fillcolor":"ffffed99","id":984,"originaltext":"3. 重新标记（Remark）阶段","page":280,"textblocks":[{"first":[87.52719116210938,720.076171875,5.57958984375,12.5],"last":[201.41677856445312,720.076171875,9.754531860351562,12.5],"length":17,"rects":[[87.52719116210938,720.076171875,123.64411926269531,12.5]],"start":1038,"text":"3. 重新标记（Remark）阶段"}],"type":5,"uuid":"ebace012c2a3d8a3b08da3b3cbaf92e4"},{"content":"标记完成直接删除和用户线程一起运行","date":"2022-05-09 11:14:38","docid":0,"fillcolor":"ffffed99","id":985,"originaltext":"4. 并发清除（Concurrent-Sweep）阶段","page":280,"textblocks":[{"first":[87.52719116210938,780.1044921875,5.57958984375,12.5],"last":[250.8467254638672,780.1044921875,9.754531860351562,12.5],"length":27,"rects":[[87.52719116210938,780.1044921875,173.07406616210938,12.5]],"start":1206,"text":"4. 并发清除（Concurrent-Sweep）阶段"}],"type":5,"uuid":"4482add0b16b46b0d18fd2856f46c518"}],"originaltext":"CMS 工作原理（过程）","page":280,"textblocks":[{"first":[75.52161407470703,416.4365234375,9.320457458496094,17.5],"last":[212.92333984375,416.4365234375,14.631805419921875,17.5],"length":12,"rects":[[75.52161407470703,416.4365234375,152.03353118896484,17.5]],"start":684,"text":"CMS 工作原理（过程）"}],"type":5,"uuid":"98610e69eb4d974d016502ee9c7a7dc9"},{"content":"1、还是需要STW，在初始标记和重新标记阶段\n2、并发标记和并发清除阶段耗时，但是能与用户线程并发执行\n3、CMS不是在老年代满了情况下去清除，他有额外的阈值，达到了便回去垃圾回收，以便于他有充足的空间去工作\n4、如果运行的时候没有充足的空间，就会启动Serial old GC清除老年代\n5、使用标记清除算法会产生碎片","date":"2022-05-09 11:22:41","docid":0,"fillcolor":"ffffed99","folded":true,"id":986,"markups":[{"content":"因为垃圾回收的时候用户线程在运行，这个时候使用压缩改变内存中对象的存储地址，影响运行","date":"2022-05-09 11:28:32","docid":0,"fillcolor":"ffffed99","id":989,"originaltext":"为什么 CMS 不采用标记-压缩算法呢？","page":281,"textblocks":[{"first":[75.52161407470703,532.9382934570312,9.754531860351562,13.5],"last":[231.32264709472656,532.9382934570312,9.754531860351562,13.5],"length":20,"rects":[[75.52161407470703,532.9382934570312,165.5555648803711,13.5]],"start":657,"text":"为什么 CMS 不采用标记-压缩算法呢？"}],"type":5,"uuid":"58f06b035b16bd4325b27c98cfbd88d0"}],"originaltext":"CMS分析","page":281,"textblocks":[{"first":[75.52161407470703,55.5185546875,9.320457458496094,17.5],"last":[121.33171844482422,55.5185546875,14.631797790527344,17.5],"length":5,"rects":[[75.52161407470703,55.5185546875,60.44190216064453,17.5]],"start":2,"text":"CMS分析"}],"type":5,"uuid":"d5fb5a45fa7acc67859571cd5e40809a"},{"date":"2022-05-09 11:28:26","docid":0,"fillcolor":"ffffed99","folded":true,"id":988,"markups":[{"date":"2022-05-09 11:32:44","docid":0,"fillcolor":"ffffed99","id":990,"originaltext":"优点","page":281,"textblocks":[{"first":[75.52161407470703,663.048828125,9.754531860351562,12.5],"last":[85.2761459350586,663.048828125,9.754531860351562,12.5],"length":2,"rects":[[75.52161407470703,663.048828125,19.509063720703125,12.5]],"start":813,"text":"优点"}],"type":5,"uuid":"1f0fea562dbee1a3e10156a610ad371e"},{"content":"1、占用用户线程，吞吐量低了\n2、内存碎片\n3、浮动垃圾：在并发标记阶段本来是好的对象，不引用变成了无用对象","date":"2022-05-09 11:32:48","docid":0,"fillcolor":"ffffed99","id":991,"originaltext":"弊端","page":281,"textblocks":[{"first":[75.52161407470703,723.8271484375,9.754531860351562,12.5],"last":[85.2761459350586,723.8271484375,9.754531860351562,12.5],"length":2,"rects":[[75.52161407470703,723.8271484375,19.509063720703125,12.5]],"start":831,"text":"弊端"}],"type":5,"uuid":"328a12ad3dd612c4e6d8d4852d605149"}],"originaltext":"CMS 的优点与弊端","page":281,"textblocks":[{"first":[75.52161407470703,611.0263671875,9.320457458496094,17.5],"last":[183.6597442626953,611.0263671875,14.631790161132812,17.5],"length":10,"rects":[[75.52161407470703,611.0263671875,122.7699203491211,17.5]],"start":799,"text":"CMS 的优点与弊端"}],"type":5,"uuid":"3f84687d87567636f6001534d813ca08"},{"content":"内存开销选Serial\n吞吐量选Parallel\n低延迟选CMS","date":"2022-05-09 11:38:43","docid":0,"fillcolor":"ffffed99","id":992,"originaltext":"小结","page":282,"textblocks":[{"first":[75.52161407470703,589.767578125,14.631797790527344,18.5],"last":[90.15341186523438,589.767578125,14.631797790527344,18.5],"length":2,"rects":[[75.52161407470703,589.767578125,29.263595581054688,18.5]],"start":975,"text":"小结"}],"type":5,"uuid":"0447f63aa003765d9510e9440368a5de"},{"content":"JDK14删除","date":"2022-05-09 11:39:01","docid":0,"fillcolor":"ffffed99","id":993,"originaltext":"JDK 后续版本中 CMS 的变化","page":283,"textblocks":[{"first":[75.52161407470703,30.2568359375,4.8431243896484375,17.5],"last":[245.9163360595703,30.2568359375,14.631790161132812,17.5],"length":17,"rects":[[75.52161407470703,30.2568359375,185.0265121459961,17.5]],"start":0,"text":"JDK 后续版本中 CMS 的变化"}],"type":5,"uuid":"4dad4248a76041546889a4ae259fffa0"}],"originaltext":"CMS 回收器：低延迟","page":280,"textblocks":[{"first":[75.52161407470703,106.3939437866211,10.873863220214844,20.5],"last":[218.75320434570312,106.3939437866211,17.0704345703125,20.5],"length":11,"rects":[[75.52161407470703,106.3939437866211,160.3020248413086,20.5]],"start":103,"text":"CMS 回收器：低延迟"}],"type":5,"uuid":"86a3e6fd39153651e986b34f9d278254"},{"date":"2022-05-09 11:41:15","docid":0,"fillcolor":"ffffed99","folded":false,"id":994,"markups":[{"content":"为了事应不断扩大的内存和不断增加的处理器数量\n\n设计的目标：在延迟可控的情况下尽可能获取最高的吞吐量","date":"2022-05-09 14:03:27","docid":0,"fillcolor":"ffffed99","id":995,"originaltext":"为什么还需要G1","page":283,"textblocks":[{"first":[75.52161407470703,223.0966796875,14.631797790527344,17.5],"last":[173.90582275390625,223.0966796875,8.354751586914062,17.5],"length":8,"rects":[[75.52161407470703,223.0966796875,106.73896026611328,17.5]],"start":296,"text":"为什么还需要G1"}],"type":5,"uuid":"45dc401b10cef63b3a7217e04f57e641"},{"content":"1、在规定的允许收集时间，优先回收价值最大的Region\n2、每个Region可以表示不同的区域\n3、JDK9之后的默认垃圾回收器\n4、既可以用于新生代也可以用于老年代","date":"2022-05-09 14:04:23","docid":0,"fillcolor":"ffffed99","id":996,"originaltext":"为什么名字叫Garbage First(G1)呢？","page":283,"textblocks":[{"first":[75.52161407470703,428.39141845703125,14.631797790527344,18.5],"last":[304.45782470703125,428.39141845703125,14.631805419921875,18.5],"length":25,"rects":[[75.52161407470703,428.39141845703125,243.5680160522461,18.5]],"start":650,"text":"为什么名字叫Garbage First(G1)呢？"}],"type":5,"uuid":"d78a6327a44670fc86a48fa9dda67997"},{"content":"1、并行和并发兼备\n2、","date":"2022-05-09 14:05:49","docid":0,"fillcolor":"ffffed99","folded":false,"id":997,"markups":[{"content":"并行性：在垃圾回收阶段有多个GC线程同时工作，此时用户线程STW\n并发性：部分工作与用户线程同时执行","date":"2022-05-09 14:15:57","docid":0,"fillcolor":"ffffed99","id":998,"originaltext":"1. 并行与并发兼备","page":283,"textblocks":[{"first":[87.52719116210938,783.60546875,5.57958984375,13.5],"last":[156.55926513671875,783.60546875,9.754531860351562,13.5],"length":10,"rects":[[87.52719116210938,783.60546875,78.78660583496094,13.5]],"start":1291,"text":"1. 并行与并发兼备"}],"type":5,"uuid":"aced845c0e7bb89af50d13a592df521e"},{"content":"1、使用分区的思想实现分代垃圾回收器，不要求其连续\n2、将内存进行分区域\n3、对年轻代和老年代都进行回收","date":"2022-05-09 14:16:01","docid":0,"fillcolor":"ffffed99","folded":true,"id":999,"markups":[{"date":"2022-05-09 14:21:16","docid":0,"fillcolor":"ffffed99","id":1000,"originaltext":"G1的分代，已经不是下面这样的了","page":284,"textblocks":[{"first":[75.52161407470703,253.0593719482422,7.101295471191406,13.500015258789062],"last":[215.009521484375,253.0593719482422,9.754531860351562,13.500015258789062],"length":16,"rects":[[75.52161407470703,253.0593719482422,149.24243927001953,13.500015258789062]],"start":331,"text":"G1的分代，已经不是下面这样的了"}],"type":5,"uuid":"cda1cbefa10c67ca165f3478161ce0d8"},{"date":"2022-05-09 14:21:18","docid":0,"fillcolor":"ffffed99","id":1001,"originaltext":"G1的分区是这样的一个区域","page":284,"textblocks":[{"first":[75.52161407470703,558.5009765625,7.101295471191406,13.5],"last":[185.7459259033203,558.5009765625,9.754531860351562,13.5],"length":13,"rects":[[75.52161407470703,558.5009765625,119.97884368896484,13.5]],"start":348,"text":"G1的分区是这样的一个区域"}],"type":5,"uuid":"17ac866d5ff9fc54214bae5e3c81a3da"}],"originaltext":"2. 分代收集","page":284,"textblocks":[{"first":[87.52719116210938,89.783203125,5.57958984375,12.5],"last":[127.29566955566406,89.783203125,9.754531860351562,12.5],"length":7,"rects":[[87.52719116210938,89.783203125,49.52301025390625,12.5]],"start":117,"text":"2. 分代收集"}],"type":5,"uuid":"e7e6f1630b3cb6f05d313b2f48fccc3c"},{"content":"Region之间使用标记复制算法，整体上看使用的是标记压缩算法","date":"2022-05-09 14:24:41","docid":0,"fillcolor":"ffffed99","id":1002,"originaltext":"空间整合","page":284,"textblocks":[{"first":[75.52161407470703,752.3408203125,9.754531860351562,12.5],"last":[104.78520965576172,752.3408203125,9.754531860351562,12.5],"length":4,"rects":[[75.52161407470703,752.3408203125,39.01812744140625,12.5]],"start":362,"text":"空间整合"}],"title":"3.空间整合","type":5,"uuid":"1e6c0c49320bda2202b4b7c6e3083fb5"},{"content":"1、可以选取部分的区域进行垃圾回收，只回收一个一个的Region\n2、每次回收都是价值最大的Region","date":"2022-05-09 14:25:20","docid":0,"fillcolor":"ffffed99","id":1003,"originaltext":"可预测的停顿时间模型","page":285,"textblocks":[{"first":[75.52161407470703,100.0390625,14.631797790527344,17.5],"last":[207.20779418945312,100.0390625,14.631805419921875,17.5],"length":10,"rects":[[75.52161407470703,100.0390625,146.31798553466797,17.5]],"start":179,"text":"可预测的停顿时间模型"}],"title":"4.可预测的停顿时间模型","type":5,"uuid":"145b410c7962e93df837c16a642346ba"}],"originaltext":"G1 回收器的优势","page":283,"textblocks":[{"first":[75.52161407470703,709.322265625,10.593421936035156,17.5],"last":[171.42848205566406,709.322265625,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,709.322265625,110.53865814208984,17.5]],"start":1245,"text":"G1 回收器的优势"}],"type":5,"uuid":"f5d4b684e4af7c66920c0201aee41ba4"},{"content":"1、G1需要占用额外的内存空间","date":"2022-05-09 14:30:11","docid":0,"fillcolor":"ffffed99","id":1004,"originaltext":"G1 回收器的缺点","page":285,"textblocks":[{"first":[75.52161407470703,290.6279296875,10.593421936035156,17.5],"last":[171.42848205566406,290.6279296875,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,290.6279296875,110.53865814208984,17.5]],"start":548,"text":"G1 回收器的缺点"}],"type":5,"uuid":"419d8217bb7f8fd34e8da958c5b8e516"},{"content":"针对于大内存多处理器","date":"2022-05-09 14:34:16","docid":0,"fillcolor":"ffffed99","id":1005,"originaltext":"G1 的适用场景","page":286,"textblocks":[{"first":[75.52161407470703,55.0185546875,10.593421936035156,17.5],"last":[156.7966766357422,55.0185546875,14.631790161132812,17.5],"length":8,"rects":[[75.52161407470703,55.0185546875,95.90685272216797,17.5]],"start":52,"text":"G1 的适用场景"}],"type":5,"uuid":"899a925105382859738aee457958cbe8"},{"date":"2022-05-09 14:36:28","docid":0,"fillcolor":"ffffed99","folded":true,"id":1006,"markups":[{"date":"2022-05-09 14:37:35","docid":0,"fillcolor":"ffffed99","id":1007,"originaltext":"所有的Region大小相同，且在JVM生命周期内不会被改变","page":286,"textblocks":[{"first":[226.9396209716797,421.0874938964844,9.754531860351562,14.5],"last":[464.18243408203125,421.0874938964844,9.7545166015625,14.5],"length":29,"rects":[[226.9396209716797,421.0874938964844,246.99732971191406,14.5]],"start":634,"text":"所有的Region大小相同，且在JVM生命周期内不会被改变"}],"type":5,"uuid":"599518a400158791a7599abc311d6ceb"},{"content":"专门存储大对象（只要超过1.5个Region的情况下才会被分配到H的Region）\n\n如果一个H都存储不下，就拿联系的H区来存储\n\n大部分的时候都当作老年代来看待","date":"2022-05-09 14:39:23","docid":0,"fillcolor":"ffffed99","id":1008,"originaltext":"设置 H 的原因","page":287,"textblocks":[{"first":[75.52161407470703,215.841796875,9.754531860351562,12.5],"last":[127.07107543945312,215.841796875,9.754531860351562,12.5],"length":8,"rects":[[75.52161407470703,215.841796875,61.303993225097656,12.5]],"start":2,"text":"设置 H 的原因"}],"type":5,"uuid":"7505e2dd68787b8bb0463c42625af628"},{"content":"1、每个Region使用指针碰撞的方式存储\n2、当一个Region有很多的线程需要使用的时候就会创建TLAB","date":"2022-05-09 14:42:35","docid":0,"fillcolor":"ffffed99","id":1009,"originaltext":"Regio的细节","page":287,"textblocks":[{"first":[75.52161407470703,329.59454345703125,6.43798828125,13.5],"last":[121.76038360595703,329.59454345703125,9.754539489746094,13.5],"length":8,"rects":[[75.52161407470703,329.59454345703125,55.993309020996094,13.5]],"start":191,"text":"Regio的细节"}],"type":5,"uuid":"5cfcf2731b5c711a579abba2f3c8ecbb"}],"originaltext":"分区 Region","page":286,"textblocks":[{"first":[75.52161407470703,324.0435485839844,14.631797790527344,19.5],"last":[148.68060302734375,324.0435485839844,9.61309814453125,19.5],"length":9,"rects":[[75.52161407470703,324.0435485839844,82.77208709716797,19.5]],"start":455,"text":"分区 Region"}],"type":5,"uuid":"49e9cbba975ecd4feda1f04cd6292c17"},{"date":"2022-05-09 14:51:03","docid":0,"fillcolor":"ffffed99","folded":true,"id":1010,"markups":[{"content":"1、当伊甸园区满的时候，开启年轻代的回收流程发生STW\n2、当堆内存达到45%的时候就会触发老年代的标记过程\n3、并发标记完成开始混合回收，对老年代回收是按Region进行回收的","date":"2022-05-09 20:43:16","docid":0,"fillcolor":"ffffed99","id":1011,"originaltext":"回收流程","page":288,"textblocks":[{"first":[75.52161407470703,304.3828125,9.754531860351562,12.5],"last":[104.78520965576172,304.3828125,9.754531860351562,12.5],"length":4,"rects":[[75.52161407470703,304.3828125,39.01812744140625,12.5]],"start":135,"text":"回收流程"}],"type":5,"uuid":"f988e27f38ad4faef1ed44f919652639"}],"originaltext":"G1 垃圾回收流程","page":287,"textblocks":[{"first":[75.52161407470703,686.5625,10.593421936035156,17.5],"last":[171.42848205566406,686.5625,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,686.5625,110.53865814208984,17.5]],"start":359,"text":"G1 垃圾回收流程"}],"type":5,"uuid":"26f8332aa043902169eb8774f3da4ff4"},{"content":"问题：一个对象不只是年轻代会引用他，可能老年代中的对象也会引用这个对象，导致yongGC也需要去遍历整个堆空间是否有老年代对象引用年轻代对象\n\n解决：GC的时候为GCRoot做一个Remembered Set，记录哪个的Region引用自己，保证不需要进行全表扫描，也不会遗漏","date":"2022-05-09 20:51:45","docid":0,"fillcolor":"ffffed99","id":1012,"originaltext":"Remembered Set（记忆集）","page":288,"textblocks":[{"first":[75.52161407470703,516.9334106445312,9.656990051269531,18.5],"last":[259.0406494140625,516.9334106445312,14.631805419921875,18.5],"length":19,"rects":[[75.52161407470703,516.9334106445312,198.15084075927734,18.5]],"start":627,"text":"Remembered Set（记忆集）"}],"type":5,"uuid":"b9d33b42a35e79f689b8d618fcc3036d"},{"content":"1、只有在伊甸园区满的时候才会发生年轻代回收YGC\n2、大致YGC过程：触发后发生STW，G1创建包含年轻代的伊甸园区和Survior区内存分段的回收表","date":"2022-05-09 20:51:53","docid":0,"fillcolor":"ffffed99","folded":true,"id":1013,"markups":[{"content":"G1中YGC的细致过程：\n1、扫描GCRoots\n2、更新记忆集：更新RSet需要线程同步，所以当老年代对象直接更改记忆集开销太大，使用dirty card queue，当对象引用的时候现在其中进行更改，到一定的时候，使用脏卡表帮助RSet更新\n3、处理记忆集\n4、复制对象：对对象在新生代中进行处理，该进S区的进S区，进老年代的进入老年代\n5、处理引用：处理强、软、弱、虚引用，单个Region中的存储是连续的没有碎片的","date":"2022-05-10 08:55:21","docid":0,"fillcolor":"ffffed99","id":1014,"originaltext":"然后开始如下回收过程：","page":290,"textblocks":[{"first":[75.52161407470703,121.296875,9.754531860351562,13.5],"last":[173.0669403076172,121.296875,9.754531860351562,13.5],"length":11,"rects":[[75.52161407470703,121.296875,107.29985809326172,13.5]],"start":53,"text":"然后开始如下回收过程："}],"type":5,"uuid":"470027724868ab9b2db6ec9dd1441501"}],"originaltext":"G1回收过程一：年轻代 GC","page":289,"textblocks":[{"first":[75.52161407470703,349.1552734375,10.593421936035156,17.5],"last":[240.5525360107422,349.1552734375,9.320449829101562,17.5],"length":14,"rects":[[75.52161407470703,349.1552734375,174.35137176513672,17.5]],"start":208,"text":"G1回收过程一：年轻代 GC"}],"type":5,"uuid":"8b1d829480935d2667b8072dded76056"},{"content":"","date":"2022-05-10 09:06:11","docid":0,"fillcolor":"ffffed99","folded":false,"id":1015,"markups":[{"content":"1、直接初略寻找GCRoots的可达对象，产生STW跟CMS的初始标记一样\nSTW","date":"2022-05-10 09:10:10","docid":0,"fillcolor":"ffffed99","id":1016,"originaltext":"1. 初始标记阶段","page":290,"textblocks":[{"first":[87.52719116210938,594.0166015625,5.57958984375,12.5],"last":[146.8047332763672,594.0166015625,9.754531860351562,12.5],"length":9,"rects":[[87.52719116210938,594.0166015625,69.03207397460938,12.5]],"start":750,"text":"1. 初始标记阶段"}],"type":5,"uuid":"3e826a4691d4032085d13078fb32c07b"},{"content":"2、从Survivor区扫描可以达到老年代的对象，并进行标记（一定要在YGC之前，因为YGC会动Survivor区中对象的存储地址）","date":"2022-05-10 09:10:22","docid":0,"fillcolor":"ffffed99","id":1017,"originaltext":"2. 根区域扫描","page":290,"textblocks":[{"first":[87.52719116210938,628.1832275390625,5.57958984375,14.5],"last":[137.05020141601562,628.1832275390625,9.754531860351562,14.5],"length":8,"rects":[[87.52719116210938,628.1832275390625,59.27754211425781,14.5]],"start":834,"text":"2. 根区域扫描"}],"type":5,"uuid":"4cdcdeda303e8c06e5e584a2764a9f72"},{"content":"这个过程是在初始标记的情况下进行细致的标记：\n1、与用户线程同时执行，但是有可能会被YGC打断\n2、如果细致标记的过程中发现整个Region都是垃圾，就直接实时回收\n3、对每个Region计算活跃性","date":"2022-05-10 09:10:28","docid":0,"fillcolor":"ffffed99","id":1018,"originaltext":"3. 并发标记","page":290,"textblocks":[{"first":[87.52719116210938,678.5056762695312,5.57958984375,13.5],"last":[127.29566955566406,678.5056762695312,9.754531860351562,13.5],"length":7,"rects":[[87.52719116210938,678.5056762695312,49.52301025390625,13.5]],"start":959,"text":"3. 并发标记"}],"type":5,"uuid":"3dc96e9dc3448726014897e6602b672c"},{"content":"对并发标记进行修正（有些Region可能被认为疑似垃圾，这个时候就会对这个Region进行再次标记）\n使用初始快照算法\nSTW","date":"2022-05-10 09:10:33","docid":0,"fillcolor":"ffffed99","id":1019,"originaltext":"4. 再次标记（Remark）","page":290,"textblocks":[{"first":[87.52719116210938,744.0869140625,5.57958984375,12.5],"last":[181.90771484375,744.0869140625,9.754531860351562,12.5],"length":15,"rects":[[87.52719116210938,744.0869140625,104.13505554199219,12.5]],"start":1114,"text":"4. 再次标记（Remark）"}],"type":5,"uuid":"c1fd19a1064582df428932416870fdb8"},{"content":"其实不是清理，只是对需要清理的地方中的每个Region计算活跃性并排序\nSTW","date":"2022-05-10 09:10:39","docid":0,"fillcolor":"ffffed99","id":1020,"originaltext":"5. 独占清理（cleanup，STW）","page":290,"textblocks":[{"first":[87.52719116210938,777.5025634765625,5.57958984375,14.5],"last":[212.3001251220703,777.5025634765625,9.754531860351562,14.5],"length":20,"rects":[[87.52719116210938,777.5025634765625,134.5274658203125,14.5]],"start":1214,"text":"5. 独占清理（cleanup，STW）"}],"type":5,"uuid":"42eac0c67a2f2cc902736108a51bfce2"},{"content":"清理","date":"2022-05-10 09:10:45","docid":0,"fillcolor":"ffffed99","id":1021,"originaltext":"6. 并发清理阶段","page":291,"textblocks":[{"first":[87.52719116210938,29.7578125,5.57958984375,12.5],"last":[146.8047332763672,29.7578125,9.754531860351562,12.5],"length":9,"rects":[[87.52719116210938,29.7578125,69.03207397460938,12.5]],"start":0,"text":"6. 并发清理阶段"}],"type":5,"uuid":"5f208129efc35c06285b8a74a2c6bca2"}],"originaltext":"G1回收过程二：并发标记过程","page":290,"textblocks":[{"first":[75.52161407470703,541.994140625,10.593421936035156,17.5],"last":[255.41842651367188,541.994140625,14.631805419921875,17.5],"length":14,"rects":[[75.52161407470703,541.994140625,194.52861785888672,17.5]],"start":732,"text":"G1回收过程二：并发标记过程"}],"type":5,"uuid":"de0f40d5d1c3946424a39d2985d4f3c4"},{"content":"只回收一部分的老年代，不是全部老年代","date":"2022-05-10 09:29:30","docid":0,"fillcolor":"ffffed99","folded":true,"id":1022,"markups":[{"content":"1、老年代的Region会被分成8段来回收\n2、回收算法和年轻代一样是复制算法\n3、由上一次并发标记过程已经排序，并且只有垃圾占比65%以上才会被回收\n4、虽然分为8段，但是不是真的一定要回收8次，当垃圾占比达到10%的时候就不会进行混合回收了","date":"2022-05-10 09:30:25","docid":0,"fillcolor":"ffffed99","id":1023,"originaltext":"混合回收的细节","page":291,"textblocks":[{"first":[75.52161407470703,582.763671875,9.754531860351562,12.5],"last":[134.04879760742188,582.763671875,9.754531860351562,12.5],"length":7,"rects":[[75.52161407470703,582.763671875,68.2817153930664,12.5]],"start":254,"text":"混合回收的细节"}],"type":5,"uuid":"8fe65b9997797a0c93f506ed6da8fd14"}],"originaltext":"G1回收过程三：混合回收过程","page":291,"textblocks":[{"first":[75.52161407470703,55.021484375,10.593421936035156,17.5],"last":[255.41842651367188,55.021484375,14.631805419921875,17.5],"length":14,"rects":[[75.52161407470703,55.021484375,194.52861785888672,17.5]],"start":24,"text":"G1回收过程三：混合回收过程"}],"type":5,"uuid":"115ceaaed13184cf49a19370cf08c2b0"},{"content":"G1用来避免出现FullGC，因为是单线程的，需要较长的STW\n\nG1出现FullGC原因：\n1、老年代需要存放对象的时候，内存已经耗尽，不够存储对象\n2、并发处理过程内存达到阈值\n（并发处理过程是边产生垃圾，边清理的）","date":"2022-05-10 09:37:52","docid":0,"fillcolor":"ffffed99","id":1024,"originaltext":"G1 回收可选的过程四：Full GC","page":292,"textblocks":[{"first":[75.52161407470703,55.51953125,10.593421936035156,17.5],"last":[270.9247131347656,55.51953125,9.320465087890625,17.5],"length":19,"rects":[[75.52161407470703,55.51953125,204.72356414794922,17.5]],"start":2,"text":"G1 回收可选的过程四：Full GC"}],"type":5,"uuid":"0f5f0869a1a73ecf2251623e7fa580d3"}],"originaltext":"G1 回收器：区域化分代式","page":283,"textblocks":[{"first":[75.52161407470703,191.08203125,12.358993530273438,19.5],"last":[255.69468688964844,191.08203125,17.070419311523438,19.5],"length":13,"rects":[[75.52161407470703,191.08203125,197.24349212646484,19.5]],"start":281,"text":"G1 回收器：区域化分代式"}],"type":5,"uuid":"4e8044dd7388e8b1240978dc8b5dd27b"},{"date":"2022-05-10 09:48:23","docid":0,"fillcolor":"ffffed99","folded":true,"id":1026,"markups":[{"date":"2022-05-10 09:48:28","docid":0,"fillcolor":"ffffed99","id":1027,"originaltext":"7 种垃圾回收器的比较","page":292,"textblocks":[{"first":[75.52161407470703,581.765625,8.354759216308594,17.5],"last":[204.7286834716797,581.765625,14.631790161132812,17.5],"length":11,"rects":[[75.52161407470703,581.765625,143.83885955810547,17.5]],"start":774,"text":"7 种垃圾回收器的比较"}],"type":5,"uuid":"a66e182f67f9c99732b74554755be510"},{"date":"2022-05-10 09:50:54","docid":0,"fillcolor":"ffffed99","id":1028,"originaltext":"怎么选择垃圾回收器","page":293,"textblocks":[{"first":[75.52161407470703,148.0625,14.631797790527344,17.5],"last":[192.5760040283203,148.0625,14.631790161132812,17.5],"length":9,"rects":[[75.52161407470703,148.0625,131.6861801147461,17.5]],"start":4,"text":"怎么选择垃圾回收器"}],"type":5,"uuid":"3fadcfa36461f5f1ac40da27aeecc158"}],"originaltext":"垃圾回收器总结","page":292,"textblocks":[{"first":[75.52161407470703,548.75,17.07042694091797,19.5],"last":[177.94419860839844,548.75,17.0704345703125,19.5],"length":7,"rects":[[75.52161407470703,548.75,119.4930191040039,19.5]],"start":765,"text":"垃圾回收器总结"}],"type":5,"uuid":"3e0b61ae536135d9bb957fed5da00561"}],"originaltext":"垃圾回收器","page":270,"textblocks":[{"first":[75.52161407470703,85.88591003417969,21.94770050048828,25.5],"last":[163.31240844726562,85.88591003417969,21.94769287109375,25.5],"length":5,"rects":[[75.52161407470703,85.88591003417969,109.73848724365234,25.5]],"start":2,"text":"垃圾回收器"}],"title":"第12章-垃圾回收器","type":5,"uuid":"41064bb8793e5bb6e0a3249160f1ed89"}],"maxid":1028,"notelinks":[],"title":"尚硅谷JVM","unimportant":[]}