{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2022-02-09 18:06:41","docid":0,"fillcolor":"ffffed99","folded":true,"id":273,"markups":[{"date":"2022-02-09 18:06:50","docid":0,"fillcolor":"ffffed99","folded":true,"id":274,"markups":[{"date":"2022-02-09 18:06:58","docid":0,"fillcolor":"ffffed99","folded":true,"id":275,"markups":[{"date":"2022-02-09 18:08:57","docid":0,"fillcolor":"ffffed99","id":278,"originaltext":"1)线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系2)线性结构有两种不同的存储结构，即顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的3)链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息4)线性结构常见的有：数组、队列、链表和栈，后面我们会详细讲解.","page":15,"textblocks":[{"first":[70.91999816894531,499.85650634765625,6,12],"last":[440.3999938964844,616.8565063476562,3,12],"length":194,"rects":[[70.91999816894531,499.85650634765625,441.4800262451172,12],[70.91999816894531,523.2564697265625,596.0350799560547,12],[92.15899658203125,546.656494140625,180.24099731445312,12],[70.91999816894531,570.0574951171875,595.7991180419922,12],[92.15899658203125,593.4564819335938,36,12],[70.91999816894531,616.8565063476562,372.47999572753906,12]],"start":197,"text":"1)线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系\n2)线性结构有两种不同的存储结构，即顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序\n表，顺序表中的存储元素是连续的\n3)链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地\n址信息\n4)线性结构常见的有：数组、队列、链表和栈，后面我们会详细讲解."}],"title":"线性结构3大特点以及包括","type":5}],"originaltext":"2.3.1线性结构","page":15,"textblocks":[{"first":[85.08000183105469,447.123291015625,7.5,16.611328125],"last":[160.9199981689453,447.123291015625,15,16.611328125],"length":9,"rects":[[85.08000183105469,447.123291015625,90.83999633789062,16.611328125]],"start":187,"text":"2.3.1线性结构"}],"type":5},{"date":"2022-02-09 18:07:03","docid":0,"fillcolor":"ffffed99","id":276,"markups":[{"date":"2022-02-09 18:09:17","docid":0,"fillcolor":"ffffed99","id":279,"originaltext":"非线性结构包括：二维数组，多维数组，广义表，树结构，图结构","page":15,"textblocks":[{"first":[70.91999816894531,718.2564697265625,12,12],"last":[407.1590881347656,718.2564697265625,12,12],"length":29,"rects":[[70.91999816894531,718.2564697265625,348.2390899658203,12]],"start":403,"text":"非线性结构包括：二维数组，多维数组，广义表，树结构，图结构"}],"title":"非线性结构包括","type":5}],"originaltext":"2.3.2非线性结构","page":15,"textblocks":[{"first":[85.08000183105469,665.9993896484375,7.5,15],"last":[175.9199981689453,665.9993896484375,15,15],"length":10,"rects":[[85.08000183105469,665.9993896484375,105.83999633789062,15]],"start":392,"text":"2.3.2非线性结构"}],"type":5}],"originaltext":"2.3线性结构和非线性结构","page":15,"textblocks":[{"first":[70.91999816894531,369.261962890625,7.974998474121094,15.95001220703125],"last":[250.91546630859375,369.261962890625,15.95001220703125,15.95001220703125],"length":13,"rects":[[70.91999816894531,369.261962890625,195.9454803466797,15.95001220703125]],"start":154,"text":"2.3线性结构和非线性结构"}],"type":5}],"originaltext":"第 2 章 数据结构和算法概述","page":13,"textblocks":[{"first":[224.52000427246094,132.14572143554688,21.949996948242188,22.29296875],"last":[490.5561828613281,132.14572143554688,21.949981689453125,22.29296875],"length":15,"rects":[[224.52000427246094,132.14572143554688,287.9861602783203,22.29296875]],"start":72,"text":"第 2 章 数据结构和算法概述"}],"type":5},{"date":"2022-02-09 18:17:05","docid":0,"fillcolor":"ffffed99","folded":true,"id":280,"markups":[{"content":"对普通二维数组的压缩，只要符合二维数组的定义都可以使用来压缩：\n\n稀疏数组（也是二位数组不过是压缩过的）定义要点：\n1、使用row，col，val定义三列，row指定行，col指定列，val指定数据\n2、这个二维稀疏数组的第一行记录整个二位数组的数据，也就是二维数组有多少行，多少列，以及多少个不同数据\n3、后面的行直接记录不同数据的下标以及其val\n\n\n稀疏数组的创建思路：\n1、遍历数组得到有效数据个数sum\n2、根据sum创建稀疏数组（其中sum+1为行数） \n3、再次遍历数组获取有效数据\n\n\n恢复思路：\n1、遍历第一行数据创建数组\n2、遍历稀疏数组剩下的行，set数据即可","date":"2022-02-09 18:17:12","docid":0,"fillcolor":"ffffed99","folded":true,"id":281,"markups":[{"date":"2022-02-09 18:17:17","docid":0,"fillcolor":"ffffed99","id":282,"originaltext":"先看一个实际的需求","page":16,"textblocks":[{"first":[115.91999816894531,236.99937438964844,15,15],"last":[235.9199981689453,236.99937438964844,15,15],"length":9,"rects":[[115.91999816894531,236.99937438964844,135,15]],"start":112,"text":"先看一个实际的需求"}],"type":5},{"date":"2022-02-09 18:17:35","docid":0,"fillcolor":"ffffed99","folded":false,"id":283,"markups":[{"content":"稀疏数组：\n第一行记录原始数组有多少行多少列，多少个不同的值\n后于其他行不同值的下标以及值","date":"2022-02-09 18:24:08","docid":0,"fillcolor":"ffffed99","folded":false,"id":284,"markups":[{"date":"2022-02-09 18:24:25","docid":0,"fillcolor":"ffffed99","id":285,"originaltext":"1) 记录数组一共有几行几列，有多少个不同的值","page":16,"textblocks":[{"first":[94.91999816894531,655.8565063476562,6,12],"last":[339.4800109863281,655.8565063476562,12,12],"length":23,"rects":[[94.91999816894531,655.8565063476562,256.5600128173828,12]],"start":260,"text":"1) 记录数组一共有几行几列，有多少个不同的值"}],"type":5},{"date":"2022-02-09 18:24:29","docid":0,"fillcolor":"ffffed99","id":286,"originaltext":"2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模","page":16,"textblocks":[{"first":[94.91999816894531,679.2564697265625,6,12],"last":[531,679.2564697265625,12,12],"length":39,"rects":[[94.91999816894531,679.2564697265625,448.0800018310547,12]],"start":284,"text":"2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模"}],"type":5}],"originaltext":"稀疏数组的处理方法","page":16,"textblocks":[{"first":[91.91999816894531,632.4564819335938,12,12],"last":[187.9199981689453,632.4564819335938,12,12],"length":9,"rects":[[91.91999816894531,632.4564819335938,108,12]],"start":248,"text":"稀疏数组的处理方法"}],"title":"稀疏数组的建立","type":5},{"content":"","date":"2022-02-09 18:24:46","docid":0,"fillcolor":"ffffed99","id":287,"originaltext":"稀疏数组举例说明","page":16,"textblocks":[{"first":[91.91999816894531,726.0565185546875,12,12],"last":[175.9199981689453,726.0565185546875,12,12],"length":8,"rects":[[91.91999816894531,726.0565185546875,96,12]],"start":325,"text":"稀疏数组举例说明"}],"title":"稀疏数组举例","type":5}],"originaltext":"基本介绍","page":16,"textblocks":[{"first":[115.91999816894531,532.9232788085938,15,16.611328125],"last":[160.9199981689453,532.9232788085938,15,16.611328125],"length":4,"rects":[[115.91999816894531,532.9232788085938,60,16.611328125]],"start":201,"text":"基本介绍"}],"type":5},{"content":"代码转化过程思路\n\n行数是不同数值数+1\n列是3列\n\n稀疏数组的创建思路：\n1、遍历数组得到有效数据个数sum\n2、根据sum创建稀疏数组 \n3、再次遍历数组获取有效数据\n\n返回思路：\n1、遍历第一行数据创建数组\n2、遍历稀疏数组剩下的行，设置数据即可","date":"2022-02-09 18:26:36","docid":0,"fillcolor":"ffffed99","id":288,"originaltext":"应用实例","page":17,"textblocks":[{"first":[115.91999816894531,384.7232971191406,15,16.611328125],"last":[160.9199981689453,384.7232971191406,15,16.611328125],"length":4,"rects":[[115.91999816894531,384.7232971191406,60,16.611328125]],"start":77,"text":"应用实例"}],"type":5},{"content":"动态数组常用技术：\n1、快慢指针：慢指针设置值，快指针寻找符合条件值（当快指针遍历完数组的时候，慢指针也停止，只要取慢指针前面的数据即可）\n\n2、size计数：设置一个int类型size值，只要遍历一个数据，size++，做到size计数（配合快慢指针中的慢指针可以计算所需要数组的长度）\n\n3、前缀和：创建多一个数组，与斐波那契数列一样的思想，就可以寻找对应下标元素的前缀和\n\n4、差分数组：从下标为1的数据开始计算前一个数据和后一个数据的差值放到新数组中\n\n5、化的东窗口：","date":"2022-02-09 19:42:23","docid":0,"fillcolor":"ffffed99","id":289,"originaltext":"代码实现","page":18,"textblocks":[{"first":[91.91999816894531,453.0564880371094,12,12],"last":[127.91999816894531,453.0564880371094,12,12],"length":4,"rects":[[91.91999816894531,453.0564880371094,48,12]],"start":75,"text":"代码实现"}],"type":5}],"originaltext":"稀疏 sparsearray 数组","page":16,"textblocks":[{"first":[106.91999816894531,204.9567413330078,15.949996948242188,17.663375854492188],"last":[235.6793975830078,204.9567413330078,15.949996948242188,17.663375854492188],"length":17,"rects":[[106.91999816894531,204.9567413330078,144.7093963623047,17.663375854492188]],"start":89,"text":"稀疏 sparsearray 数组"}],"title":"稀疏数组","type":5},{"content":"一般使用的是循环链表\n头尾指针，最大数量，数组\n\n使用取模%得到下标\n\n\n得出的重要结论：\n对循环来说取模%可以知道自己实际下标，\n因为取模%相当于消圈\n\n思路：\n1、设置头指针和尾指针为0，操纵数据后再动指针\n2、添加使用取模运算%保证尾指针下一个不是头指针（这个时候尾指针的数据还没有放下去）\n3、删除的时候保证尾指针和头指针不相等即可\n4、获取数据个数取模运算%时需要进行手动套一圈，保证尾指针在头指针之前","date":"2022-02-09 22:53:21","docid":0,"fillcolor":"ffffed99","folded":true,"id":290,"markups":[{"date":"2022-02-09 22:54:56","docid":0,"fillcolor":"ffffed99","folded":true,"id":291,"markups":[{"content":"链表天然适合队列\n但是使用数组实现更加效率较高","date":"2022-02-09 22:55:10","docid":0,"fillcolor":"ffffed99","id":292,"originaltext":"1)队列是一个有序列表，可以用数组或是链表来实现。2)遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出","page":22,"textblocks":[{"first":[70.91999816894531,633.5374755859375,6,12],"last":[489,656.9375,12,12],"length":62,"rects":[[70.91999816894531,633.5374755859375,297.36000061035156,12],[70.91999816894531,656.9375,430.0800018310547,12]],"start":189,"text":"1)队列是一个有序列表，可以用数组或是链表来实现。\n2)遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出"}],"type":5}],"originaltext":"队列介绍","page":22,"textblocks":[{"first":[115.91999816894531,580.6832885742188,15,16.611328125],"last":[160.9199981689453,580.6832885742188,15,16.611328125],"length":4,"rects":[[115.91999816894531,580.6832885742188,60,16.611328125]],"start":184,"text":"队列介绍"}],"type":5},{"content":"先动数据后动指针\n\n头指针指向第一个元素\n尾指针指向最后元素的后一位\n（注意）\n取模运算想要知道的就是自己的下标\n\n\n得出的重要结论：\n对循环来说取模%可以知道自己实际下标，\n因为取模%相当于消圈\n\n思路：\n1、设置头指针和尾指针为0，操纵数据后再动指针\n2、添加使用取模运算%保证尾指针下一个不是头指针（这个时候尾指针的数据还没有放下去）\n3、删除的时候保证尾指针和头指针不相等即可\n4、获取数据个数取模运算%时需要进行手动套一圈，保证尾指针在头指针之前","date":"2022-02-10 10:53:07","docid":0,"fillcolor":"ffffed99","id":295,"originaltext":"数组模拟环形队列","page":29,"textblocks":[{"first":[115.91999816894531,229.19937133789062,15,15],"last":[220.9199981689453,229.19937133789062,15,15],"length":8,"rects":[[115.91999816894531,229.19937133789062,120,15]],"start":143,"text":"数组模拟环形队列"}],"type":5}],"originaltext":"队列","page":22,"textblocks":[{"first":[106.91999816894531,307.3167419433594,15.949996948242188,17.66339111328125],"last":[122.87939453125,307.3167419433594,15.949996948242188,17.66339111328125],"length":2,"rects":[[106.91999816894531,307.3167419433594,31.909393310546875,17.66339111328125]],"start":152,"text":"队列"}],"type":5}],"originaltext":"第 3 章 稀疏数组和队列","page":16,"textblocks":[{"first":[246.47999572753906,163.34571838378906,21.949996948242188,22.29296875],"last":[468.4770812988281,163.34571838378906,21.95001220703125,22.29296875],"length":13,"rects":[[246.47999572753906,163.34571838378906,243.9470977783203,22.29296875]],"start":72,"text":"第 3 章 稀疏数组和队列"}],"type":5},{"date":"2022-02-10 12:07:49","docid":0,"fillcolor":"ffffed99","folded":true,"id":296,"markups":[{"date":"2022-02-10 12:09:00","docid":0,"fillcolor":"ffffed99","folded":true,"id":297,"markups":[{"date":"2022-02-10 12:09:09","docid":0,"fillcolor":"ffffed99","id":298,"originaltext":"1)链表是以节点的方式来存储,是链式存储2)每个节点包含 data 域， next 域：指向下一个节点.3)如图：发现链表的各个节点不一定是连续存储.4)链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定","page":36,"textblocks":[{"first":[70.91999816894531,499.85650634765625,6,12],"last":[440.6400146484375,570.0574951171875,12,12],"length":110,"rects":[[70.91999816894531,499.85650634765625,228.2390899658203,12],[70.91999816894531,523.2564697265625,292.5600128173828,12],[70.91999816894531,546.656494140625,264.7200164794922,12],[70.91999816894531,570.0574951171875,381.7200164794922,12]],"start":131,"text":"1)链表是以节点的方式来存储,是链式存储\n2)每个节点包含 data 域， next 域：指向下一个节点.\n3)如图：发现链表的各个节点不一定是连续存储.\n4)链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定"}],"title":"链表特点","type":5}],"originaltext":"链表(Linked List)介绍","page":36,"textblocks":[{"first":[106.91999816894531,173.75674438476562,15.949996948242188,17.663375854492188],"last":[239.7593994140625,173.75674438476562,15.949996948242188,17.663375854492188],"length":17,"rects":[[106.91999816894531,173.75674438476562,148.78939819335938,17.663375854492188]],"start":85,"text":"链表(Linked List)介绍"}],"type":5},{"content":"头节点不能动即可，删除找前指针\n\n创建思路：\n1、先创建一个head头节点，作用就是表示单链表的头\n2、后面每添加一个节点，就直接加入到链表的最后\n3、有条件添加或者删除需要辅助指针指向操作节点的前一个","date":"2022-02-10 12:13:43","docid":0,"fillcolor":"ffffed99","folded":true,"id":299,"markups":[{"date":"2022-02-10 12:31:02","docid":0,"fillcolor":"ffffed99","folded":true,"id":300,"markups":[{"content":"遍历","date":"2022-02-10 18:40:11","docid":0,"fillcolor":"ffffed99","id":301,"originaltext":"1)求单链表中有效节点的个数","page":46,"textblocks":[{"first":[70.91999816894531,493.13751220703125,6,12],"last":[223.9199981689453,493.13751220703125,12,12],"length":14,"rects":[[70.91999816894531,493.13751220703125,165,12]],"start":312,"text":"1)求单链表中有效节点的个数"}],"type":5},{"content":"遍历得到总长度","date":"2022-02-10 18:40:27","docid":0,"fillcolor":"ffffed99","id":302,"originaltext":"2)查找单链表中的倒数第 k 个结点 【新浪面试题】","page":47,"textblocks":[{"first":[70.91999816894531,415.13751220703125,6,12],"last":[337.9200134277344,415.13751220703125,12,12],"length":26,"rects":[[70.91999816894531,415.13751220703125,279.00001525878906,12]],"start":223,"text":"2)查找单链表中的倒数第 k 个结点 【新浪面试题】"}],"type":5},{"content":"用临时讲点，边遍历边反转","date":"2022-02-10 18:40:44","docid":0,"fillcolor":"ffffed99","id":303,"originaltext":"3)单链表的反转【腾讯面试题，有点难度】","page":48,"textblocks":[{"first":[70.91999816894531,508.73748779296875,6,12],"last":[295.91998291015625,508.73748779296875,12,12],"length":20,"rects":[[70.91999816894531,508.73748779296875,236.99998474121094,12]],"start":365,"text":"3)单链表的反转【腾讯面试题，有点难度】"}],"type":5},{"date":"2022-02-10 18:41:37","docid":0,"fillcolor":"ffffed99","id":304,"originaltext":"4)从尾到头打印单链表 【百度，要求方式 1：反向遍历 。 方式 2：Stack 栈】","page":50,"textblocks":[{"first":[70.91999816894531,321.5375061035156,6,12],"last":[481.5589904785156,321.5375061035156,12,12],"length":43,"rects":[[70.91999816894531,321.5375061035156,422.6389923095703,12]],"start":268,"text":"4)从尾到头打印单链表 【百度，要求方式 1：反向遍历 。 方式 2：Stack 栈】"}],"type":5}],"originaltext":"单链表面试题(新浪、百度、腾讯)","page":46,"textblocks":[{"first":[106.91999816894531,440.4229736328125,15.949996948242188,15.95001220703125],"last":[336.239990234375,440.4229736328125,5.31134033203125,15.95001220703125],"length":16,"rects":[[106.91999816894531,440.4229736328125,234.63133239746094,15.95001220703125]],"start":281,"text":"单链表面试题(新浪、百度、腾讯)"}],"type":5}],"originaltext":"单链表的应用实例","page":37,"textblocks":[{"first":[106.91999816894531,158.6629638671875,15.949996948242188,16.19921875],"last":[218.87637329101562,158.6629638671875,15.949996948242188,16.19921875],"length":8,"rects":[[106.91999816894531,158.6629638671875,127.9063720703125,16.19921875]],"start":76,"text":"单链表的应用实例"}],"type":5},{"date":"2022-02-10 18:41:48","docid":0,"fillcolor":"ffffed99","folded":true,"id":305,"markups":[{"date":"2022-02-10 18:49:26","docid":0,"fillcolor":"ffffed99","id":306,"originaltext":"双向链表的操作分析和实现","page":52,"textblocks":[{"first":[115.91999816894531,542.2783813476562,15,15],"last":[280.91998291015625,542.2783813476562,15,15],"length":12,"rects":[[115.91999816894531,542.2783813476562,179.99998474121094,15]],"start":407,"text":"双向链表的操作分析和实现"}],"type":5},{"content":"带序号添加遍历比较添加即可","date":"2022-02-10 18:52:22","docid":0,"fillcolor":"ffffed99","id":308,"originaltext":"课堂作业和思路提示","page":61,"textblocks":[{"first":[115.91999816894531,183.4793701171875,15,15],"last":[235.9199981689453,183.4793701171875,15,15],"length":9,"rects":[[115.91999816894531,183.4793701171875,135,15]],"start":78,"text":"课堂作业和思路提示"}],"type":5}],"originaltext":"双向链表应用实例","page":52,"textblocks":[{"first":[106.91999816894531,510.62298583984375,15.949996948242188,15.95001220703125],"last":[218.87637329101562,510.62298583984375,15.949996948242188,15.95001220703125],"length":8,"rects":[[106.91999816894531,510.62298583984375,127.9063720703125,15.95001220703125]],"start":393,"text":"双向链表应用实例"}],"type":5},{"content":"建立单向循环列表只要\nfirst指向首节点点\ncurNode指向最后的操作节点即可\n一直操作的都是最后节点\n\n总结：首尾指针\n\n\n\n思路：\n创建使用首尾指针\n删除使用前后指针","date":"2022-02-10 18:50:11","docid":0,"fillcolor":"ffffed99","folded":true,"id":307,"markups":[{"date":"2022-02-10 19:43:36","docid":0,"fillcolor":"ffffed99","folded":false,"id":310,"markups":[{"content":"可以使用不带头节点的单向环形列表解决\n\n思路：\n添加使用首尾指针\n删除使用前后指针","date":"2022-02-10 19:44:10","docid":0,"fillcolor":"ffffed99","id":311,"originaltext":"Josephu 问题","page":62,"textblocks":[{"first":[106.91999816894531,275.15673828125,6.204551696777344,17.66339111328125],"last":[178.43939208984375,275.15673828125,15.949996948242188,17.66339111328125],"length":10,"rects":[[106.91999816894531,275.15673828125,87.46939086914062,17.66339111328125]],"start":76,"text":"Josephu 问题"}],"type":5},{"content":"使用两个指针指向需要删除节点和前置节点来操作\n（注意：因为不是下标移动的时候需要-1）","date":"2022-02-10 19:51:18","docid":0,"fillcolor":"ffffed99","id":313,"originaltext":"Josephu 问题的代码实现","page":63,"textblocks":[{"first":[106.91999816894531,649.5557250976562,6.204551696777344,17.66339111328125],"last":[258.47698974609375,649.5557250976562,15.95001220703125,17.66339111328125],"length":15,"rects":[[106.91999816894531,649.5557250976562,167.5070037841797,17.66339111328125]],"start":127,"text":"Josephu 问题的代码实现"}],"type":5}],"originaltext":"单向环形链表介绍","page":61,"textblocks":[{"first":[106.91999816894531,619.822998046875,15.949996948242188,15.95001220703125],"last":[218.87637329101562,619.822998046875,15.949996948242188,15.95001220703125],"length":8,"rects":[[106.91999816894531,619.822998046875,127.9063720703125,15.95001220703125]],"start":436,"text":"单向环形链表介绍"}],"type":5}],"originaltext":"单向环形链表应用场景","page":61,"textblocks":[{"first":[106.91999816894531,261.0229797363281,15.949996948242188,15.95001220703125],"last":[250.91546630859375,261.0229797363281,15.95001220703125,15.95001220703125],"length":10,"rects":[[106.91999816894531,261.0229797363281,159.9454803466797,15.95001220703125]],"start":135,"text":"单向环形链表应用场景"}],"type":5}],"originaltext":"第 4 章 链表","page":36,"textblocks":[{"first":[301.44000244140625,132.14572143554688,21.95001220703125,22.29296875],"last":[413.3994140625,132.14572143554688,21.95001220703125,22.29296875],"length":8,"rects":[[301.44000244140625,132.14572143554688,133.909423828125,22.29296875]],"start":73,"text":"第 4 章 链表"}],"type":5},{"date":"2022-02-10 19:46:25","docid":0,"fillcolor":"ffffed99","folded":false,"id":312,"markups":[{"date":"2022-02-10 21:43:20","docid":0,"fillcolor":"ffffed99","folded":true,"id":314,"markups":[{"date":"2022-02-10 21:43:29","docid":0,"fillcolor":"ffffed99","id":315,"originaltext":"1)栈的英文为(stack)2)栈是一个先入后出(FILO-First In Last Out)的有序列表。3)栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。4)根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除5)图解方式说明出栈(pop)和入栈(push)的概念","page":70,"textblocks":[{"first":[70.91999816894531,476.0766296386719,6,13.2890625],"last":[308.51953125,616.8565063476562,12,12],"length":251,"rects":[[70.91999816894531,476.0766296386719,115.71372985839844,13.2890625],[70.91999816894531,499.47564697265625,318.5990753173828,13.2890625],[70.91999816894531,523.2564697265625,597.4774017333984,12],[92.15899658203125,546.656494140625,434.8809814453125,12],[70.91999816894531,570.0574951171875,597.3582611083984,12],[92.15899658203125,593.4564819335938,204.71731567382812,12],[70.91999816894531,616.8565063476562,249.5995330810547,12]],"start":255,"text":"1)栈的英文为(stack)\n2)栈是一个先入后出(FILO-First In Last Out)的有序列表。\n3)栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的\n一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。\n4)根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元\n素最先删除，最先放入的元素最后删除\n5)图解方式说明出栈(pop)和入栈(push)的概念"}],"title":"栈的特点","type":5},{"date":"2022-02-10 21:43:43","docid":0,"fillcolor":"ffffed99","id":316,"originaltext":"栈的应用场景","page":71,"textblocks":[{"first":[106.91999816894531,260.0629577636719,15.949996948242188,15.95001220703125],"last":[186.95758056640625,260.0629577636719,15.949996948242188,15.95001220703125],"length":6,"rects":[[106.91999816894531,260.0629577636719,95.98757934570312,15.95001220703125]],"start":76,"text":"栈的应用场景"}],"type":5}],"originaltext":"栈的介绍","page":70,"textblocks":[{"first":[106.91999816894531,423.8619689941406,15.949996948242188,15.95001220703125],"last":[154.91848754882812,423.8619689941406,15.949996948242188,15.95001220703125],"length":4,"rects":[[106.91999816894531,423.8619689941406,63.948486328125,15.95001220703125]],"start":250,"text":"栈的介绍"}],"type":5},{"content":"思路：\n1、首先使用top指向-1\n2、添加：top++，然后设置数据\n3、获取：保存数据，top--\n\n链表使用头指针和辅助指针即可","date":"2022-02-10 21:44:03","docid":0,"fillcolor":"ffffed99","id":317,"originaltext":"栈的快速入门","page":71,"textblocks":[{"first":[106.91999816894531,478.46197509765625,15.949996948242188,15.95001220703125],"last":[186.95758056640625,478.46197509765625,15.949996948242188,15.95001220703125],"length":6,"rects":[[106.91999816894531,478.46197509765625,95.98757934570312,15.95001220703125]],"start":273,"text":"栈的快速入门"}],"type":5},{"date":"2022-02-10 21:44:19","docid":0,"fillcolor":"ffffed99","folded":false,"id":318,"markups":[{"content":"1、使用index进行遍历\n2、创建两个栈\n\t数字入数栈\n\t操作符入操作符栈\n3、入栈判断：\n   3.1、当index指向的操作符小于或者等于操作符栈栈顶元素的时候，先弹出两个数和一个符号进行运算，得到数字放入数栈。\n  3.2、大于直接放入符号栈\n4、拿出数和符号进行运算\n\n（注意：入栈比较只需要比较一次即可）\n\n重点在于符号进栈需要比较是否小于或等于>=符号栈顶元素的优先级","date":"2022-02-11 11:15:42","docid":0,"fillcolor":"ffffed99","id":322,"originaltext":"思路分析","page":76,"textblocks":[{"first":[91.91999816894531,641.3375244140625,12,12],"last":[127.91999816894531,641.3375244140625,12,12],"length":4,"rects":[[91.91999816894531,641.3375244140625,48,12]],"start":326,"text":"思路分析"}],"type":5}],"originaltext":"栈实现综合计算器(中缀表达式)","page":76,"textblocks":[{"first":[106.91999816894531,510.62298583984375,15.949996948242188,15.95001220703125],"last":[320.15899658203125,510.62298583984375,5.31134033203125,15.95001220703125],"length":15,"rects":[[106.91999816894531,510.62298583984375,218.5503387451172,15.95001220703125]],"start":295,"text":"栈实现综合计算器(中缀表达式)"}],"type":5},{"content":"前缀表达式：\n从右往左扫描，遇到数字压栈，遇到操作符弹出两个数来运算\n(3+4)×5-6的前缀表达式：\n-x+3456\n\n后缀表达式：\n从左往右扫描，遇到数字压栈，遇到操作符弹出两个数来运算\n(3+4)×5-6的后缀表达式：\n34+5×6-","date":"2022-02-10 21:44:31","docid":0,"fillcolor":"ffffed99","id":319,"originaltext":"逆波兰计算器","page":85,"textblocks":[{"first":[106.91999816894531,229.82296752929688,15.949996948242188,16.19921875],"last":[186.95758056640625,229.82296752929688,15.949996948242188,16.19921875],"length":6,"rects":[[106.91999816894531,229.82296752929688,95.98757934570312,16.19921875]],"start":95,"text":"逆波兰计算器"}],"type":5},{"content":"步骤：\n1、遇到操作数直接放入集合\n2、遇到操作符\n   2.1、（第一层判断）操作符大于或者是”（ “  或者 当前字符是”（ “  直接压栈\n\n   2.2、（第二层判断）：否则，如果遇到  ）弹出元素直到遇到（\n\n   2.3、（第二层判断）：否则，否则从栈顶一直比较直到优先级大于 才压栈，每一次比较不成功弹出元素\n\n后缀表达式：\n从左往右扫描，遇到数字压栈，遇到操作符弹出两个数来运算","date":"2022-02-10 21:44:55","docid":0,"fillcolor":"ffffed99","folded":true,"id":320,"markups":[{"date":"2022-02-11 14:33:50","docid":0,"fillcolor":"ffffed99","id":323,"originaltext":"代码实现中缀表达式转为后缀表达式","page":90,"textblocks":[{"first":[115.91999816894531,470.9993896484375,15,15],"last":[340.91998291015625,470.9993896484375,15,15],"length":16,"rects":[[115.91999816894531,470.9993896484375,239.99998474121094,15]],"start":78,"text":"代码实现中缀表达式转为后缀表达式"}],"type":5}],"originaltext":"中缀表达式转换为后缀表达式","page":89,"textblocks":[{"first":[106.91999816894531,183.02296447753906,15.949996948242188,16.19921875],"last":[298.91400146484375,183.02296447753906,15.95001220703125,16.19921875],"length":13,"rects":[[106.91999816894531,183.02296447753906,207.9440155029297,16.19921875]],"start":76,"text":"中缀表达式转换为后缀表达式"}],"type":5},{"date":"2022-02-10 21:45:04","docid":0,"fillcolor":"ffffed99","id":321,"originaltext":"逆波兰计算器完整版","page":99,"textblocks":[{"first":[106.91999816894531,510.62298583984375,15.949996948242188,15.95001220703125],"last":[234.95606994628906,510.62298583984375,15.949996948242188,15.95001220703125],"length":9,"rects":[[106.91999816894531,510.62298583984375,143.98606872558594,15.95001220703125]],"start":213,"text":"逆波兰计算器完整版"}],"type":5}],"originaltext":"第 5 章 栈","page":70,"textblocks":[{"first":[312.4800109863281,132.14572143554688,21.95001220703125,22.29296875],"last":[402.4800109863281,132.14572143554688,21.95001220703125,22.29296875],"length":7,"rects":[[312.4800109863281,132.14572143554688,111.95001220703125,22.29296875]],"start":73,"text":"第 5 章 栈"}],"type":5},{"date":"2022-02-11 14:34:12","docid":0,"fillcolor":"ffffed99","folded":false,"id":324,"markups":[{"date":"2022-02-11 23:10:47","docid":0,"fillcolor":"ffffed99","id":325,"originaltext":"递归的概念","page":108,"textblocks":[{"first":[106.91999816894531,431.6629638671875,15.949996948242188,15.95001220703125],"last":[170.8778839111328,431.6629638671875,15.949996948242188,15.95001220703125],"length":5,"rects":[[106.91999816894531,431.6629638671875,79.90788269042969,15.95001220703125]],"start":129,"text":"递归的概念"}],"type":5},{"content":"阶乘的概念","date":"2022-02-11 23:23:30","docid":0,"fillcolor":"ffffed99","id":326,"originaltext":"递归调用机制","page":108,"textblocks":[{"first":[106.91999816894531,509.6629638671875,15.949996948242188,15.95001220703125],"last":[186.95758056640625,509.6629638671875,15.949996948242188,15.95001220703125],"length":6,"rects":[[106.91999816894531,509.6629638671875,95.98757934570312,15.95001220703125]],"start":200,"text":"递归调用机制"}],"type":5},{"date":"2022-02-12 10:20:28","docid":0,"fillcolor":"ffffed99","folded":false,"id":327,"markups":[{"content":"1、每执行一次方法，开辟一个栈空间\n2、基本数据类型数据独立，引用数据类型共享\n3、向递归退出的条件逼近\n4、谁调用返回给谁","date":"2022-02-12 10:25:04","docid":0,"fillcolor":"ffffed99","id":328,"originaltext":"1)执行一个方法时，就创建一个新的受保护的独立空间(栈空间)2)方法的局部变量是独立的，不会相互影响, 比如 n 变量3)如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.4)递归必须向退出递归的条件逼近，否则就是无限递归,出现 StackOverflowError，死龟了:)5)当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕","page":111,"textblocks":[{"first":[70.91999816894531,211.25750732421875,6,12],"last":[248.15899658203125,328.2565002441406,12,12],"length":222,"rects":[[70.91999816894531,211.25750732421875,340.9560089111328,12],[70.91999816894531,234.65750122070312,306.00001525878906,12],[70.91999816894531,258.0574951171875,415.9199981689453,12],[70.91999816894531,281.4574890136719,480.87535095214844,12],[70.91999816894531,304.85650634765625,595.9178314208984,12],[92.15899658203125,328.2565002441406,168,12]],"start":101,"text":"1)执行一个方法时，就创建一个新的受保护的独立空间(栈空间)\n2)方法的局部变量是独立的，不会相互影响, 比如 n 变量\n3)如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.\n4)递归必须向退出递归的条件逼近，否则就是无限递归,出现 StackOverflowError，死龟了:)\n5)当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或\n者返回时，该方法也就执行完毕"}],"title":"规则","type":5}],"originaltext":"递归需要遵守的重要规则","page":111,"textblocks":[{"first":[106.91999816894531,135.26296997070312,15.949996948242188,16.19921875],"last":[266.8748779296875,135.26296997070312,15.95001220703125,16.19921875],"length":11,"rects":[[106.91999816894531,135.26296997070312,175.90489196777344,16.19921875]],"start":77,"text":"递归需要遵守的重要规则"}],"type":5},{"content":"条件\nx1 !=  x2\ny1 - x1 != y2 - x2\n\n用一个数组表示皇后，其中存储的数据表示列\n\n\n因为是8列，对每一个皇后尝试放置每一个列，只有成功才判断下一个，不的话就放置到下一列\n满就输出","date":"2022-02-12 10:30:16","docid":0,"fillcolor":"ffffed99","id":330,"originaltext":"递归-八皇后问题(回溯算法)","page":116,"textblocks":[{"first":[106.91999816894531,565.2229614257812,15.949996948242188,15.95001220703125],"last":[293.5199890136719,565.2229614257812,5.31134033203125,15.95001220703125],"length":14,"rects":[[106.91999816894531,565.2229614257812,191.9113311767578,15.95001220703125]],"start":304,"text":"递归-八皇后问题(回溯算法)"}],"type":5}],"originaltext":"第 6 章 递归","page":108,"textblocks":[{"first":[301.44000244140625,132.14572143554688,21.95001220703125,22.29296875],"last":[413.3994140625,132.14572143554688,21.95001220703125,22.29296875],"length":8,"rects":[[301.44000244140625,132.14572143554688,133.909423828125,22.29296875]],"start":74,"text":"第 6 章 递归"}],"type":5},{"date":"2022-02-12 10:30:38","docid":0,"fillcolor":"ffffed99","folded":false,"id":331,"markups":[{"date":"2022-02-12 14:45:06","docid":0,"fillcolor":"ffffed99","folded":true,"id":332,"markups":[{"date":"2022-02-12 15:04:30","docid":0,"fillcolor":"ffffed99","id":333,"originaltext":"1) 内部排序:","page":122,"textblocks":[{"first":[94.91999816894531,258.0574951171875,6,12],"last":[158.8800048828125,258.0574951171875,3.324005126953125,12],"length":8,"rects":[[94.91999816894531,258.0574951171875,67.28401184082031,12]],"start":155,"text":"1) 内部排序:"}],"type":5},{"date":"2022-02-12 15:04:32","docid":0,"fillcolor":"ffffed99","id":334,"originaltext":"2) 外部排序法：","page":122,"textblocks":[{"first":[94.91999816894531,304.85650634765625,6,12],"last":[170.8800048828125,304.85650634765625,12,12],"length":9,"rects":[[94.91999816894531,304.85650634765625,87.96000671386719,12]],"start":195,"text":"2) 外部排序法："}],"type":5},{"date":"2022-02-12 15:04:42","docid":0,"fillcolor":"ffffed99","id":335,"originaltext":"3) 常见的排序算法分类(见右图):","page":122,"textblocks":[{"first":[94.91999816894531,351.656494140625,6,12],"last":[262.7994079589844,351.656494140625,3.324005126953125,12],"length":18,"rects":[[94.91999816894531,351.656494140625,171.2034149169922,12]],"start":241,"text":"3) 常见的排序算法分类(见右图):"}],"type":5}],"originaltext":"排序的分类","page":122,"textblocks":[{"first":[106.91999816894531,228.86297607421875,15.949996948242188,16.19921875],"last":[170.8778839111328,228.86297607421875,15.949996948242188,16.19921875],"length":5,"rects":[[106.91999816894531,228.86297607421875,79.90788269042969,16.19921875]],"start":148,"text":"排序的分类"}],"type":5},{"date":"2022-02-12 15:12:53","docid":0,"fillcolor":"ffffed99","folded":true,"id":336,"markups":[{"date":"2022-02-12 15:14:46","docid":0,"fillcolor":"ffffed99","folded":true,"id":340,"markups":[{"date":"2022-02-12 15:14:55","docid":0,"fillcolor":"ffffed99","id":341,"originaltext":"1) 事后统计的方法","page":122,"textblocks":[{"first":[94.91999816894531,663.656494140625,6,12],"last":[182.8800048828125,663.656494140625,12,12],"length":10,"rects":[[94.91999816894531,663.656494140625,99.96000671386719,12]],"start":297,"text":"1) 事后统计的方法"}],"type":5},{"date":"2022-02-12 15:14:59","docid":0,"fillcolor":"ffffed99","id":342,"originaltext":"2) 事前估算的方法","page":123,"textblocks":[{"first":[94.91999816894531,156.65750122070312,6,12],"last":[182.8800048828125,156.65750122070312,12,12],"length":10,"rects":[[94.91999816894531,156.65750122070312,99.96000671386719,12]],"start":85,"text":"2) 事前估算的方法"}],"type":5}],"originaltext":"度量一个程序(算法)执行时间的两种方法","page":122,"textblocks":[{"first":[115.91999816894531,611.3993530273438,15,15],"last":[365.8800048828125,611.3993530273438,15,15],"length":19,"rects":[[115.91999816894531,611.3993530273438,264.9600067138672,15]],"start":277,"text":"度量一个程序(算法)执行时间的两种方法"}],"type":5},{"content":"执行次数","date":"2022-02-12 15:13:02","docid":0,"fillcolor":"ffffed99","id":337,"originaltext":"时间频度","page":123,"textblocks":[{"first":[115.91999816894531,205.32330322265625,15,16.611328125],"last":[160.9199981689453,205.32330322265625,15,16.611328125],"length":4,"rects":[[115.91999816894531,205.32330322265625,60,16.611328125]],"start":126,"text":"时间频度"}],"type":5},{"content":"系数，常数项，低阶忽略","date":"2022-02-12 15:13:13","docid":0,"fillcolor":"ffffed99","id":338,"originaltext":"时间复杂度","page":125,"textblocks":[{"first":[115.91999816894531,361.79937744140625,15,15],"last":[175.9199981689453,361.79937744140625,15,15],"length":5,"rects":[[115.91999816894531,361.79937744140625,75,15]],"start":184,"text":"时间复杂度"}],"type":5},{"date":"2022-02-12 15:13:19","docid":0,"fillcolor":"ffffed99","id":339,"originaltext":"常见的时间复杂度","page":125,"textblocks":[{"first":[115.91999816894531,603.599365234375,15,15],"last":[220.9199981689453,603.599365234375,15,15],"length":8,"rects":[[115.91999816894531,603.599365234375,120,15]],"start":611,"text":"常见的时间复杂度"}],"type":5},{"content":"选择最坏","date":"2022-02-12 15:34:39","docid":0,"fillcolor":"ffffed99","id":343,"originaltext":"平均时间复杂度和最坏时间复杂度","page":128,"textblocks":[{"first":[115.91999816894531,580.1994018554688,15,15],"last":[325.91998291015625,580.1994018554688,15,15],"length":15,"rects":[[115.91999816894531,580.1994018554688,224.99998474121094,15]],"start":162,"text":"平均时间复杂度和最坏时间复杂度"}],"type":5}],"originaltext":"算法的时间复杂度","page":122,"textblocks":[{"first":[106.91999816894531,579.8619384765625,15.949996948242188,15.95001220703125],"last":[218.87637329101562,579.8619384765625,15.949996948242188,15.95001220703125],"length":8,"rects":[[106.91999816894531,579.8619384765625,127.9063720703125,15.95001220703125]],"start":263,"text":"算法的时间复杂度"}],"type":5},{"content":"相邻对比，把大数字放最后\n最后一个不用比","date":"2022-02-12 15:35:06","docid":0,"fillcolor":"ffffed99","id":344,"originaltext":"冒泡排序","page":129,"textblocks":[{"first":[106.91999816894531,618.8619384765625,15.949996948242188,15.95001220703125],"last":[154.91848754882812,618.8619384765625,15.949996948242188,15.95001220703125],"length":4,"rects":[[106.91999816894531,618.8619384765625,63.948486328125,15.95001220703125]],"start":405,"text":"冒泡排序"}],"type":5},{"content":"与头比较，需要全部比较","date":"2022-02-12 17:56:31","docid":0,"fillcolor":"ffffed99","id":345,"originaltext":"选择排序","page":135,"textblocks":[{"first":[106.91999816894531,580.822998046875,15.949996948242188,15.95001220703125],"last":[154.91848754882812,580.822998046875,15.949996948242188,15.95001220703125],"length":4,"rects":[[106.91999816894531,580.822998046875,63.948486328125,15.95001220703125]],"start":323,"text":"选择排序"}],"type":5},{"content":"打牌，对正常的元素前移\n","date":"2022-02-12 20:25:42","docid":0,"fillcolor":"ffffed99","id":346,"originaltext":"插入排序","page":142,"textblocks":[{"first":[106.91999816894531,534.02294921875,15.949996948242188,15.95001220703125],"last":[154.91848754882812,534.02294921875,15.949996948242188,15.95001220703125],"length":4,"rects":[[106.91999816894531,534.02294921875,63.948486328125,15.95001220703125]],"start":262,"text":"插入排序"}],"type":5},{"content":"优化插入排序，\n插入排序+增量序列","date":"2022-02-12 21:32:55","docid":0,"fillcolor":"ffffed99","folded":true,"id":347,"markups":[{"date":"2022-02-12 21:46:52","docid":0,"fillcolor":"ffffed99","id":348,"originaltext":"希尔排序法应用实例","page":150,"textblocks":[{"first":[115.91999816894531,252.599365234375,15,15],"last":[235.9199981689453,252.599365234375,15,15],"length":9,"rects":[[115.91999816894531,252.599365234375,135,15]],"start":79,"text":"希尔排序法应用实例"}],"type":5},{"date":"2022-02-13 12:54:19","docid":0,"fillcolor":"ffffed99","id":354,"originaltext":"希尔排序法的示意图","page":149,"textblocks":[{"first":[115.91999816894531,307.1993713378906,15,15],"last":[235.9199981689453,307.1993713378906,15,15],"length":9,"rects":[[115.91999816894531,307.1993713378906,135,15]],"start":208,"text":"希尔排序法的示意图"}],"type":5}],"originaltext":"希尔排序","page":148,"textblocks":[{"first":[106.91999816894531,346.8229675292969,15.949996948242188,15.95001220703125],"last":[154.91848754882812,346.8229675292969,15.949996948242188,15.95001220703125],"length":4,"rects":[[106.91999816894531,346.8229675292969,63.948486328125,15.95001220703125]],"start":191,"text":"希尔排序"}],"type":5},{"content":"冒泡排序的改进\n\n小于的放左边\n大于的放右边\n\nwhile循环查找放置下标，判断小标是否正确，正确进行调换，然后轮到另一指针移动\n\n右指针让左指针动\n左指针让右指针动\n\n三色国旗","date":"2022-02-12 21:47:00","docid":0,"fillcolor":"ffffed99","folded":true,"id":349,"markups":[{"date":"2022-02-13 13:01:05","docid":0,"fillcolor":"ffffed99","id":355,"originaltext":"快速排序法示意图:","page":155,"textblocks":[{"first":[115.91999816894531,690.4793701171875,15,15],"last":[235.9199981689453,690.4793701171875,4.154998779296875,15],"length":9,"rects":[[115.91999816894531,690.4793701171875,124.15499877929688,15]],"start":404,"text":"快速排序法示意图:"}],"type":5}],"originaltext":"快速排序","page":155,"textblocks":[{"first":[106.91999816894531,534.02294921875,15.949996948242188,15.95001220703125],"last":[154.91848754882812,534.02294921875,15.949996948242188,15.95001220703125],"length":4,"rects":[[106.91999816894531,534.02294921875,63.948486328125,15.95001220703125]],"start":245,"text":"快速排序"}],"type":5},{"content":"分治思想\n\n分成两份，对左边和右边进行比较\n拿出到临时数组，\n因为是递归的思想，所以左右两部分绝对有序","date":"2022-02-12 21:47:20","docid":0,"fillcolor":"ffffed99","folded":true,"id":350,"markups":[{"date":"2022-02-13 20:07:31","docid":0,"fillcolor":"ffffed99","id":357,"originaltext":"归并排序思想示意图","page":160,"textblocks":[{"first":[133.9199981689453,596.8783569335938,15,15],"last":[253.9199981689453,596.8783569335938,14.999984741210938,15],"length":9,"rects":[[133.9199981689453,596.8783569335938,134.99998474121094,15]],"start":348,"text":"归并排序思想示意图"}],"type":5}],"originaltext":"归并排序","page":160,"textblocks":[{"first":[106.91999816894531,415.5699157714844,15.949996948242188,18.95013427734375],"last":[154.91848754882812,415.5699157714844,15.949996948242188,18.95013427734375],"length":4,"rects":[[106.91999816894531,415.5699157714844,63.948486328125,18.95013427734375]],"start":183,"text":"归并排序"}],"type":5},{"content":"就是很多桶子\n重点在于获取每个数对应桶子的下标\nint index = (i1 % mod)/dex","date":"2022-02-12 21:47:28","docid":0,"fillcolor":"ffffed99","folded":true,"id":351,"markups":[{"date":"2022-02-13 20:07:20","docid":0,"fillcolor":"ffffed99","id":356,"originaltext":"基数排序图文说明","page":167,"textblocks":[{"first":[133.9199981689453,205.79937744140625,15,15],"last":[238.9199981689453,205.79937744140625,15,15],"length":8,"rects":[[133.9199981689453,205.79937744140625,120,15]],"start":116,"text":"基数排序图文说明"}],"type":5},{"date":"2022-02-13 21:40:42","docid":0,"fillcolor":"ffffed99","id":358,"originaltext":"基数排序的说明","page":175,"textblocks":[{"first":[133.9199981689453,391.9732971191406,15,18.74462890625],"last":[223.9199981689453,391.9732971191406,15,18.74462890625],"length":7,"rects":[[133.9199981689453,391.9732971191406,105,18.74462890625]],"start":238,"text":"基数排序的说明"}],"type":5}],"originaltext":"基数排序","page":166,"textblocks":[{"first":[106.91999816894531,416.0489196777344,15.949996948242188,18.95013427734375],"last":[154.91848754882812,416.0489196777344,15.949996948242188,18.95013427734375],"length":4,"rects":[[106.91999816894531,416.0489196777344,63.948486328125,18.95013427734375]],"start":160,"text":"基数排序"}],"type":5},{"content":"三大算法\n冒泡、插入是稳定的，优化过后的都不是稳定的\n\n（荷兰国旗）\n快排最快是冒泡的优化\n\n归并、基数稳定，归并挺强","date":"2022-02-12 21:47:36","docid":0,"fillcolor":"ffffed99","id":352,"originaltext":"常用排序算法总结和对比","page":175,"textblocks":[{"first":[106.91999816894531,612.02294921875,15.949996948242188,15.95001220703125],"last":[266.8748779296875,612.02294921875,15.95001220703125,15.95001220703125],"length":11,"rects":[[106.91999816894531,612.02294921875,175.90489196777344,15.95001220703125]],"start":558,"text":"常用排序算法总结和对比"}],"type":5}],"originaltext":"第 7 章 排序算法","page":122,"textblocks":[{"first":[279.4800109863281,132.14572143554688,21.95001220703125,22.29296875],"last":[435.4785461425781,132.14572143554688,21.95001220703125,22.29296875],"length":10,"rects":[[279.4800109863281,132.14572143554688,177.94854736328125,22.29296875]],"start":74,"text":"第 7 章 排序算法"}],"type":5},{"date":"2022-02-12 21:48:01","docid":0,"fillcolor":"ffffed99","folded":false,"id":353,"markups":[{"date":"2022-02-13 21:52:43","docid":0,"fillcolor":"ffffed99","id":359,"originaltext":"线性查找算法","page":177,"textblocks":[{"first":[106.91999816894531,322.46197509765625,15.949996948242188,15.95001220703125],"last":[186.95758056640625,322.46197509765625,15.949996948242188,15.95001220703125],"length":6,"rects":[[106.91999816894531,322.46197509765625,95.98757934570312,15.95001220703125]],"start":162,"text":"线性查找算法"}],"type":5},{"content":"一定要有序数组\n\n比较中间值","date":"2022-02-13 21:52:48","docid":0,"fillcolor":"ffffed99","folded":true,"id":360,"markups":[{"date":"2022-02-13 22:15:48","docid":0,"fillcolor":"ffffed99","id":366,"originaltext":"二分查找算法的思路","page":178,"textblocks":[{"first":[115.91999816894531,713.8783569335938,15,15],"last":[235.9199981689453,713.8783569335938,15,15],"length":9,"rects":[[115.91999816894531,713.8783569335938,135,15]],"start":425,"text":"二分查找算法的思路"}],"type":5}],"originaltext":"二分查找算法","page":178,"textblocks":[{"first":[106.91999816894531,604.2229614257812,15.949996948242188,15.95001220703125],"last":[186.95758056640625,604.2229614257812,15.949996948242188,15.95001220703125],"length":6,"rects":[[106.91999816894531,604.2229614257812,95.98757934570312,15.95001220703125]],"start":319,"text":"二分查找算法"}],"type":5},{"content":"二分查找的优化\nmid = left + (right - left)*(target - arr[left])/(arr[right] - arr[left]);","date":"2022-02-13 21:52:59","docid":0,"fillcolor":"ffffed99","id":361,"originaltext":"插值查找算法","page":184,"textblocks":[{"first":[106.91999816894531,135.26296997070312,15.949996948242188,16.19921875],"last":[186.95758056640625,135.26296997070312,15.949996948242188,16.19921875],"length":6,"rects":[[106.91999816894531,135.26296997070312,95.98757934570312,16.19921875]],"start":77,"text":"插值查找算法"}],"type":5},{"date":"2022-02-13 21:53:08","docid":0,"fillcolor":"ffffed99","id":362,"originaltext":"斐波那契(黄金分割法)查找算法","page":188,"textblocks":[{"first":[106.91999816894531,236.6629638671875,15.949996948242188,16.19921875],"last":[309.5985412597656,236.6629638671875,15.95001220703125,16.19921875],"length":15,"rects":[[106.91999816894531,236.6629638671875,218.62855529785156,16.19921875]],"start":161,"text":"斐波那契(黄金分割法)查找算法"}],"type":5}],"originaltext":"第 8 章 查找算法","page":177,"textblocks":[{"first":[279.4800109863281,132.14572143554688,21.95001220703125,22.29296875],"last":[435.4785461425781,132.14572143554688,21.95001220703125,22.29296875],"length":10,"rects":[[279.4800109863281,132.14572143554688,177.94854736328125,22.29296875]],"start":74,"text":"第 8 章 查找算法"}],"type":5},{"date":"2022-02-13 21:53:28","docid":0,"fillcolor":"ffffed99","folded":false,"id":364,"markups":[{"date":"2022-02-14 16:02:20","docid":0,"fillcolor":"ffffed99","id":369,"originaltext":"树示意图","page":204,"textblocks":[{"first":[133.9199981689453,509.5233154296875,15,16.611328125],"last":[178.9199981689453,509.5233154296875,15,16.611328125],"length":4,"rects":[[133.9199981689453,509.5233154296875,60,16.611328125]],"start":211,"text":"树示意图"}],"type":5},{"date":"2022-02-15 12:15:16","docid":0,"fillcolor":"ffffed99","folded":false,"id":384,"markups":[{"date":"2022-02-14 16:03:52","docid":0,"fillcolor":"ffffed99","folded":true,"id":370,"markups":[{"date":"2022-02-14 16:04:26","docid":0,"fillcolor":"ffffed99","id":371,"originaltext":"1) 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。","page":206,"textblocks":[{"first":[70.91999816894531,133.25750732421875,6,12],"last":[447.239990234375,133.25750732421875,12,12],"length":34,"rects":[[70.91999816894531,133.25750732421875,388.3199920654297,12]],"start":74,"text":"1) 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。"}],"type":5},{"date":"2022-02-14 16:04:44","docid":0,"fillcolor":"ffffed99","id":372,"originaltext":"2) 二叉树的子节点分为左节点和右节点","page":206,"textblocks":[{"first":[70.91999816894531,156.65750122070312,6,12],"last":[266.8800048828125,156.65750122070312,12,12],"length":19,"rects":[[70.91999816894531,156.65750122070312,207.9600067138672,12]],"start":109,"text":"2) 二叉树的子节点分为左节点和右节点"}],"type":5},{"date":"2022-02-14 16:04:54","docid":0,"fillcolor":"ffffed99","id":373,"originaltext":"4) 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。","page":206,"textblocks":[{"first":[70.91999816894531,312.6575012207031,6,12],"last":[618.5999755859375,312.6575012207031,12,12],"length":56,"rects":[[70.91999816894531,312.6575012207031,559.6799774169922,12]],"start":136,"text":"4) 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。"}],"type":5},{"content":"倒数1、2层从左边数和从右边数都不会断开就是完全","date":"2022-02-14 16:05:17","docid":0,"fillcolor":"ffffed99","id":374,"originaltext":"5) 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树","page":206,"textblocks":[{"first":[70.91999816894531,445.2565002441406,6,12],"last":[310.91998291015625,468.656494140625,12,12],"length":73,"rects":[[70.91999816894531,445.2565002441406,595.7946624755859,12],[70.91999816894531,468.656494140625,251.99998474121094,12]],"start":193,"text":"5) 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二\n层的叶子节点在右边连续，我们称为完全二叉树"}],"type":5}],"originaltext":"二叉树的概念","page":205,"textblocks":[{"first":[133.9199981689453,682.2799072265625,15,16.611328125],"last":[208.9199981689453,682.2799072265625,15,16.611328125],"length":6,"rects":[[133.9199981689453,682.2799072265625,90,16.611328125]],"start":216,"text":"二叉树的概念"}],"type":5},{"date":"2022-02-14 16:08:58","docid":0,"fillcolor":"ffffed99","folded":true,"id":375,"markups":[{"content":"中左右","date":"2022-02-14 16:09:11","docid":0,"fillcolor":"ffffed99","id":376,"originaltext":"1)前序遍历: 先输出父节点，再遍历左子树和右子树","page":206,"textblocks":[{"first":[70.91999816894531,694.8565063476562,6,12],"last":[341.15899658203125,694.8565063476562,12,12],"length":25,"rects":[[70.91999816894531,694.8565063476562,282.23899841308594,12]],"start":306,"text":"1)前序遍历: 先输出父节点，再遍历左子树和右子树"}],"type":5},{"content":"左中右","date":"2022-02-14 16:09:25","docid":0,"fillcolor":"ffffed99","id":378,"originaltext":"2)中序遍历: 先遍历左子树，再输出父节点，再遍历右子树","page":206,"textblocks":[{"first":[70.91999816894531,718.2564697265625,6,12],"last":[377.15899658203125,718.2564697265625,12,12],"length":28,"rects":[[70.91999816894531,718.2564697265625,318.23899841308594,12]],"start":332,"text":"2)中序遍历: 先遍历左子树，再输出父节点，再遍历右子树"}],"type":5},{"content":"左右中","date":"2022-02-14 16:09:27","docid":0,"fillcolor":"ffffed99","id":379,"originaltext":"3)后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点","page":207,"textblocks":[{"first":[70.91999816894531,133.25750732421875,6,12],"last":[389.15899658203125,133.25750732421875,12,12],"length":29,"rects":[[70.91999816894531,133.25750732421875,330.23899841308594,12]],"start":74,"text":"3)后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点"}],"type":5}],"originaltext":"二叉树遍历的说明","page":206,"textblocks":[{"first":[133.9199981689453,642.599365234375,15,15],"last":[238.9199981689453,642.599365234375,15,15],"length":8,"rects":[[133.9199981689453,642.599365234375,120,15]],"start":274,"text":"二叉树遍历的说明"}],"type":5},{"date":"2022-02-14 16:10:07","docid":0,"fillcolor":"ffffed99","id":380,"originaltext":"二叉树-查找指定节点","page":213,"textblocks":[{"first":[133.9199981689453,300.4793701171875,15,15],"last":[258.8399963378906,300.4793701171875,15,15],"length":10,"rects":[[133.9199981689453,300.4793701171875,139.9199981689453,15]],"start":116,"text":"二叉树-查找指定节点"}],"type":5},{"date":"2022-02-15 11:41:44","docid":0,"fillcolor":"ffffed99","id":381,"originaltext":"二叉树-删除节点","page":224,"textblocks":[{"first":[133.9199981689453,651.0809326171875,15,16.611328125],"last":[228.83999633789062,651.0809326171875,15,16.611328125],"length":8,"rects":[[133.9199981689453,651.0809326171875,109.91999816894531,16.611328125]],"start":380,"text":"二叉树-删除节点"}],"type":5}],"originaltext":"二叉树","page":203,"textblocks":[{"first":[106.91999816894531,173.75674438476562,15.949996948242188,17.663375854492188],"last":[138.95909118652344,173.75674438476562,15.949996948242188,17.663375854492188],"length":3,"rects":[[106.91999816894531,173.75674438476562,47.98908996582031,17.663375854492188]],"start":94,"text":"二叉树"}],"type":5},{"date":"2022-02-15 12:04:00","docid":0,"fillcolor":"ffffed99","folded":true,"id":382,"markups":[{"date":"2022-02-15 12:16:11","docid":0,"fillcolor":"ffffed99","id":385,"originaltext":"顺序存储二叉树的特点:","page":229,"textblocks":[{"first":[91.91999816894531,523.2564697265625,12,12],"last":[211.9199981689453,523.2564697265625,3.324005126953125,12],"length":11,"rects":[[91.91999816894531,523.2564697265625,123.32400512695312,12]],"start":242,"text":"顺序存储二叉树的特点:"}],"type":5}],"originaltext":"顺序存储二叉树","page":228,"textblocks":[{"first":[106.91999816894531,666.6229858398438,15.949996948242188,15.95001220703125],"last":[202.91697692871094,666.6229858398438,15.949996948242188,15.95001220703125],"length":7,"rects":[[106.91999816894531,666.6229858398438,111.94697570800781,15.95001220703125]],"start":457,"text":"顺序存储二叉树"}],"type":5},{"content":"前后指针\n设置后驱节点的时候，\n为前驱节点设置后继节点\n\n其他照样遍历\n\n遍历对于中序遍历一直找左边即可\n","date":"2022-02-15 12:14:41","docid":0,"fillcolor":"ffffed99","folded":true,"id":383,"markups":[{"date":"2022-02-15 15:15:42","docid":0,"fillcolor":"ffffed99","id":386,"originaltext":"线索二叉树基本介绍","page":232,"textblocks":[{"first":[133.9199981689453,698.2783813476562,15,15],"last":[253.9199981689453,698.2783813476562,14.999984741210938,15],"length":9,"rects":[[133.9199981689453,698.2783813476562,134.99998474121094,15]],"start":411,"text":"线索二叉树基本介绍"}],"type":5}],"originaltext":"线索化二叉树","page":232,"textblocks":[{"first":[106.91999816894531,331.22296142578125,15.949996948242188,15.95001220703125],"last":[186.95758056640625,331.22296142578125,15.949996948242188,15.95001220703125],"length":6,"rects":[[106.91999816894531,331.22296142578125,95.98757934570312,15.95001220703125]],"start":190,"text":"线索化二叉树"}],"type":5}],"originaltext":"第 10 章树结构的基础部分","page":203,"textblocks":[{"first":[235.44000244140625,132.14572143554688,21.95001220703125,22.29296875],"last":[479.396484375,132.14572143554688,21.95001220703125,22.29296875],"length":14,"rects":[[235.44000244140625,132.14572143554688,265.906494140625,22.29296875]],"start":74,"text":"第 10 章树结构的基础部分"}],"type":5},{"date":"2022-02-13 21:53:42","docid":0,"fillcolor":"ffffed99","folded":false,"id":365,"markups":[{"date":"2022-02-16 13:15:57","docid":0,"fillcolor":"ffffed99","folded":true,"id":397,"markups":[{"date":"2022-02-16 13:16:06","docid":0,"fillcolor":"ffffed99","id":398,"originaltext":"堆排序基本介绍","page":252,"textblocks":[{"first":[133.9199981689453,205.79937744140625,15,15],"last":[223.9199981689453,205.79937744140625,15,15],"length":7,"rects":[[133.9199981689453,205.79937744140625,105,15]],"start":104,"text":"堆排序基本介绍"}],"type":5},{"date":"2022-02-16 13:16:13","docid":0,"fillcolor":"ffffed99","id":399,"originaltext":"堆排序基本思想","page":253,"textblocks":[{"first":[133.9199981689453,158.99937438964844,15,15],"last":[223.9199981689453,158.99937438964844,15,15],"length":7,"rects":[[133.9199981689453,158.99937438964844,105,15]],"start":81,"text":"堆排序基本思想"}],"type":5},{"date":"2022-02-16 13:16:31","docid":0,"fillcolor":"ffffed99","id":400,"originaltext":"再简单总结下堆排序的基本思路","page":258,"textblocks":[{"first":[93.35900115966797,139.85000610351562,21.95000457763672,25.5],"last":[379.31243896484375,139.85000610351562,21.95001220703125,25.5],"length":14,"rects":[[93.35900115966797,139.85000610351562,307.90345001220703,25.5]],"start":74,"text":"再简单总结下堆排序的基本思路"}],"type":5}],"originaltext":"堆排序","page":252,"textblocks":[{"first":[106.91999816894531,173.75674438476562,15.949996948242188,17.663375854492188],"last":[138.95909118652344,173.75674438476562,15.949996948242188,17.663375854492188],"length":3,"rects":[[106.91999816894531,173.75674438476562,47.98908996582031,17.663375854492188]],"start":93,"text":"堆排序"}],"type":5},{"content":"所有的数据都在叶子节点","date":"2022-02-16 13:16:43","docid":0,"fillcolor":"ffffed99","id":401,"originaltext":"赫夫曼树","page":262,"textblocks":[{"first":[106.91999816894531,485.7698974609375,15.949996948242188,18.95013427734375],"last":[154.91848754882812,485.7698974609375,15.949996948242188,18.95013427734375],"length":4,"rects":[[106.91999816894531,485.7698974609375,63.948486328125,18.95013427734375]],"start":277,"text":"赫夫曼树"}],"type":5},{"date":"2022-02-17 13:30:50","docid":0,"fillcolor":"ffffed99","id":402,"originaltext":"赫夫曼编码","page":269,"textblocks":[{"first":[106.91999816894531,135.26296997070312,15.949996948242188,16.19921875],"last":[170.8778839111328,135.26296997070312,15.949996948242188,16.19921875],"length":5,"rects":[[106.91999816894531,135.26296997070312,79.90788269042969,16.19921875]],"start":79,"text":"赫夫曼编码"}],"type":5},{"date":"2022-02-17 13:31:24","docid":0,"fillcolor":"ffffed99","id":403,"originaltext":"二叉排序树","page":302,"textblocks":[{"first":[106.91999816894531,612.02294921875,15.949996948242188,15.95001220703125],"last":[170.8778839111328,612.02294921875,15.949996948242188,15.95001220703125],"length":5,"rects":[[106.91999816894531,612.02294921875,79.90788269042969,15.95001220703125]],"start":416,"text":"二叉排序树"}],"type":5}],"originaltext":"第 11 章树结构实际应用","page":252,"textblocks":[{"first":[246.47999572753906,132.14572143554688,21.949996948242188,22.29296875],"last":[468.4770812988281,132.14572143554688,21.95001220703125,22.29296875],"length":13,"rects":[[246.47999572753906,132.14572143554688,243.9470977783203,22.29296875]],"start":74,"text":"第 11 章树结构实际应用"}],"type":5},{"date":"2022-02-14 15:44:50","docid":0,"fillcolor":"ffffed99","id":367,"originaltext":"第 12 章多路查找树","page":336,"textblocks":[{"first":[268.44000244140625,132.14572143554688,21.95001220703125,22.29296875],"last":[446.39794921875,132.14572143554688,21.95001220703125,22.29296875],"length":11,"rects":[[268.44000244140625,132.14572143554688,199.907958984375,22.29296875]],"start":74,"text":"第 12 章多路查找树"}],"type":5},{"date":"2022-02-14 15:44:56","docid":0,"fillcolor":"ffffed99","folded":false,"id":368,"markups":[{"date":"2022-02-15 22:43:30","docid":0,"fillcolor":"ffffed99","id":387,"originaltext":"二分查找算法(非递归)","page":360,"textblocks":[{"first":[106.91999816894531,174.26296997070312,15.949996948242188,16.19921875],"last":[256.20001220703125,174.26296997070312,5.31134033203125,16.19921875],"length":11,"rects":[[106.91999816894531,174.26296997070312,154.5913543701172,16.19921875]],"start":98,"text":"二分查找算法(非递归)"}],"type":5},{"content":"对于分治算法最重要的其实是寻找原子算法，由原子算法递归的结果\n\n\n整体的算法和原子的算法是不变的就是分治","date":"2022-02-15 22:50:45","docid":0,"fillcolor":"ffffed99","id":388,"originaltext":"分治算法","page":362,"textblocks":[{"first":[106.91999816894531,206.4229736328125,15.949996948242188,16.19921875],"last":[154.91848754882812,206.4229736328125,15.949996948242188,16.19921875],"length":4,"rects":[[106.91999816894531,206.4229736328125,63.948486328125,16.19921875]],"start":81,"text":"分治算法"}],"type":5},{"content":"整体的算法和原子的算法是变的就是动态规划\n\n每一阶段的算法都需要上一阶段的算法为基础，一直在变\n\n填表格","date":"2022-02-15 23:13:15","docid":0,"fillcolor":"ffffed99","id":396,"originaltext":"动态规划算法","page":365,"textblocks":[{"first":[106.91999816894531,487.22296142578125,15.949996948242188,15.95001220703125],"last":[186.95758056640625,487.22296142578125,15.949996948242188,15.95001220703125],"length":6,"rects":[[106.91999816894531,487.22296142578125,95.98757934570312,15.95001220703125]],"start":346,"text":"动态规划算法"}],"type":5},{"date":"2022-02-15 22:51:57","docid":0,"fillcolor":"ffffed99","id":389,"originaltext":"KMP 算法","page":371,"textblocks":[{"first":[106.91999816894531,697.3167724609375,11.515899658203125,17.66339111328125],"last":[161.51840209960938,697.3167724609375,15.949996948242188,17.66339111328125],"length":6,"rects":[[106.91999816894531,697.3167724609375,70.54840087890625,17.66339111328125]],"start":454,"text":"KMP 算法"}],"type":5},{"date":"2022-02-15 22:52:04","docid":0,"fillcolor":"ffffed99","id":390,"originaltext":"贪心算法","page":382,"textblocks":[{"first":[106.91999816894531,321.96990966796875,15.949996948242188,18.95013427734375],"last":[154.91848754882812,321.96990966796875,15.949996948242188,18.95013427734375],"length":4,"rects":[[106.91999816894531,321.96990966796875,63.948486328125,18.95013427734375]],"start":113,"text":"贪心算法"}],"type":5},{"date":"2022-02-15 22:52:14","docid":0,"fillcolor":"ffffed99","id":391,"originaltext":"普里姆算法","page":389,"textblocks":[{"first":[106.91999816894531,158.6629638671875,15.949996948242188,16.19921875],"last":[170.8778839111328,158.6629638671875,15.949996948242188,16.19921875],"length":5,"rects":[[106.91999816894531,158.6629638671875,79.90788269042969,16.19921875]],"start":79,"text":"普里姆算法"}],"type":5},{"date":"2022-02-15 22:52:24","docid":0,"fillcolor":"ffffed99","id":392,"originaltext":"克鲁斯卡尔算法","page":396,"textblocks":[{"first":[106.91999816894531,393.6229553222656,15.949996948242188,15.95001220703125],"last":[202.91697692871094,393.6229553222656,15.949996948242188,15.95001220703125],"length":7,"rects":[[106.91999816894531,393.6229553222656,111.94697570800781,15.95001220703125]],"start":218,"text":"克鲁斯卡尔算法"}],"type":5},{"date":"2022-02-15 22:52:31","docid":0,"fillcolor":"ffffed99","id":393,"originaltext":"迪杰斯特拉算法","page":409,"textblocks":[{"first":[106.91999816894531,604.2229614257812,15.949996948242188,15.95001220703125],"last":[202.91697692871094,604.2229614257812,15.949996948242188,15.95001220703125],"length":7,"rects":[[106.91999816894531,604.2229614257812,111.94697570800781,15.95001220703125]],"start":394,"text":"迪杰斯特拉算法"}],"type":5},{"date":"2022-02-15 22:52:39","docid":0,"fillcolor":"ffffed99","id":394,"originaltext":"弗洛伊德算法","page":420,"textblocks":[{"first":[106.91999816894531,346.8229675292969,15.949996948242188,15.95001220703125],"last":[186.95758056640625,346.8229675292969,15.949996948242188,15.95001220703125],"length":6,"rects":[[106.91999816894531,346.8229675292969,95.98757934570312,15.95001220703125]],"start":107,"text":"弗洛伊德算法"}],"type":5},{"date":"2022-02-15 22:52:46","docid":0,"fillcolor":"ffffed99","id":395,"originaltext":"马踏棋盘算法","page":427,"textblocks":[{"first":[106.91999816894531,557.4229736328125,15.949996948242188,15.95001220703125],"last":[186.95758056640625,557.4229736328125,15.949996948242188,15.95001220703125],"length":6,"rects":[[106.91999816894531,557.4229736328125,95.98757934570312,15.95001220703125]],"start":485,"text":"马踏棋盘算法"}],"type":5}],"originaltext":"第 14 章程序员常用 10 种算法","page":360,"textblocks":[{"first":[219,132.14572143554688,21.949996948242188,22.29296875],"last":[496.0791320800781,132.14572143554688,21.949981689453125,22.29296875],"length":18,"rects":[[219,132.14572143554688,299.02911376953125,22.29296875]],"start":74,"text":"第 14 章程序员常用 10 种算法"}],"type":5}],"maxid":403,"notelinks":[],"title":"尚硅谷算法","unimportant":[]}