{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2022-05-17 16:42:55","docid":0,"fillcolor":"ffffed99","folded":false,"id":1,"markups":[{"date":"2022-05-17 16:43:24","docid":0,"fillcolor":"ffffed99","folded":true,"id":2,"markups":[{"date":"2022-05-17 17:31:28","docid":0,"fillcolor":"ffffed99","id":3,"originaltext":"导入后端项目","page":7,"textblocks":[{"first":[63.215999603271484,87.989990234375,20.039997100830078,21.5],"last":[163.416015625,87.989990234375,20.040008544921875,21.5],"length":6,"rects":[[63.215999603271484,87.989990234375,120.24002456665039,21.5]],"start":153,"text":"导入后端项目"}],"type":5,"uuid":"0f1bf44f67b59b46e3681c55ee85be45"},{"date":"2022-05-17 17:31:34","docid":0,"fillcolor":"ffffed99","id":4,"originaltext":"导入前端项目","page":8,"textblocks":[{"first":[63.215999603271484,87.989990234375,20.039997100830078,21.5],"last":[163.416015625,87.989990234375,20.040008544921875,21.5],"length":6,"rects":[[63.215999603271484,87.989990234375,120.24002456665039,21.5]],"start":92,"text":"导入前端项目"}],"type":5,"uuid":"6f4e70d73ef0b834f835b40c18cd6366"},{"date":"2022-05-17 17:31:39","docid":0,"fillcolor":"ffffed99","id":5,"originaltext":"运行前端项目","page":9,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,23.5],"last":[163.416015625,86.989990234375,20.040008544921875,23.5],"length":6,"rects":[[63.215999603271484,86.989990234375,120.24002456665039,23.5]],"start":153,"text":"运行前端项目"}],"type":5,"uuid":"da9edc85dcabdd9bdbc56d2e0aca8f14"}],"originaltext":"导入黑马点评项目","page":5,"textblocks":[{"first":[63.215999603271484,87.989990234375,20.039997100830078,21.5],"last":[203.49603271484375,87.989990234375,20.040008544921875,21.5],"length":8,"rects":[[63.215999603271484,87.989990234375,160.32004165649414,21.5]],"start":216,"text":"导入黑马点评项目"}],"type":5,"uuid":"629d2375785b2bf9b1481246d97c7d30"},{"content":"因为session是特殊的cookie，每次访问服务器都会携带上cookie，而cookie有对应后端的session的id，如此能做到根据session的id做登陆校验\n\n对于手机号校验可以使用正则表达式校验\n\n生成验证码可以使用hutool包的方法生成\n\n这里session被用来存储验证码之后又被用来存储用户信息\n\nThreadLocal被用来存储用户\n\n对于校验登录状态，使用SpringBoot的拦截器，只要session存在用户信息就表示校验成功","date":"2022-05-18 09:47:10","docid":0,"fillcolor":"ffffed99","folded":true,"id":6,"markups":[{"content":"发送验证码：\n1、验证手机号\n2、不符合，返回错误信息\n3、生成对应的验证码\n4、将验证码保存到session中\n5、发送验证码到手机中\n6、返回生成成功信息","date":"2022-05-18 10:00:44","docid":0,"fillcolor":"ffffed99","id":7,"originaltext":"发送短信验证码","page":12,"textblocks":[{"first":[63.19200134277344,87.71000671386719,20.040000915527344,23.5],"last":[183.4320068359375,87.71000671386719,20.040008544921875,23.5],"length":7,"rects":[[63.19200134277344,87.71000671386719,140.28001403808594,23.5]],"start":39,"text":"发送短信验证码"}],"type":5,"uuid":"5dc251faaf93cec0ce1f05e51cb765ef"},{"content":"使用方向验证防止嵌套循环\n\n短信验证码登录：\n1、校验手机号码格式\n2、从session中获取验证码\n3、校验验证码是否存在，并输入的验证码是否相同\n4、校验错误，发送验证码错误信息\n5、校验成功，根据手机号码获取用户信息\n6、尝试获取用户信息\n7、获取不到用户信息，创建用户，并存入数据库\n8、将用户信息放入session中\n9、返回成功信息","date":"2022-05-18 11:27:20","docid":0,"fillcolor":"ffffed99","id":8,"originaltext":"短信验证码登录","page":13,"textblocks":[{"first":[63.19200134277344,87.71000671386719,20.040000915527344,23.5],"last":[183.4320068359375,87.71000671386719,20.040008544921875,23.5],"length":7,"rects":[[63.19200134277344,87.71000671386719,140.28001403808594,23.5]],"start":39,"text":"短信验证码登录"}],"type":5,"uuid":"8b6050a2b24d408a19ec8e8a5392b389"},{"content":"登录校验：\n1、根据Cookieid获取对应的session\n2、尝试从session中获取用户信息\n3、校验用户信息是否存在\n4、不存在直接拦截\n5、存在放入ThreadLocal中，放行\n6、在对应方法，转成DTO返回对应用户\n7、删除ThreadLocal中的用户信息","date":"2022-05-18 13:40:04","docid":0,"fillcolor":"ffffed99","id":9,"originaltext":"登录验证功能","page":14,"textblocks":[{"first":[63.19200134277344,87.71000671386719,20.040000915527344,23.5],"last":[163.39199829101562,87.71000671386719,20.040008544921875,23.5],"length":6,"rects":[[63.19200134277344,87.71000671386719,120.24000549316406,23.5]],"start":39,"text":"登录验证功能"}],"type":5,"uuid":"44849ecd95010bccf5f5dafecebc6e94"}],"originaltext":"基于Session实现登录","page":11,"textblocks":[{"first":[63.215999603271484,87.68998718261719,20.039997100830078,23.5],"last":[235.18002319335938,87.68998718261719,20.040008544921875,23.5],"length":13,"rects":[[63.215999603271484,87.68998718261719,192.00403213500977,23.5]],"start":57,"text":"基于Session实现登录"}],"type":5,"uuid":"9a6d344f8448e8afd7e9fb165a527659"},{"date":"2022-05-18 15:21:29","docid":0,"fillcolor":"ffffed99","folded":true,"id":10,"markups":[{"content":"由于请求量的上升，需要搭载多态Tomcat中，如此存在不同session，所以session不共享，之前的校验功能不能满足\n\n解决方案满足条件：\n1、数据共享\n2、内存存储\n3、key、value结构","date":"2022-05-18 15:22:21","docid":0,"fillcolor":"ffffed99","id":11,"originaltext":"session共享问题","page":18,"textblocks":[{"first":[63.19200134277344,137.51998901367188,7.896095275878906,19.5],"last":[169.510009765625,137.51998901367188,15.983993530273438,19.5],"length":11,"rects":[[63.19200134277344,137.51998901367188,122.302001953125,19.5]],"start":148,"text":"session共享问题"}],"type":5,"uuid":"039f7076e965e11f80f67c6e780d8d86"}],"originaltext":"集群的session共享问题","page":18,"textblocks":[{"first":[63.215999603271484,87.68998718261719,20.039997100830078,23.5],"last":[252.94003295898438,87.68998718261719,20.040008544921875,23.5],"length":14,"rects":[[63.215999603271484,87.68998718261719,209.76404190063477,23.5]],"start":50,"text":"集群的session共享问题"}],"type":5,"uuid":"d5d6da70d344ce141d6c2f0deee6e3ca"},{"content":"问题1：\n因为每一次的浏览器开启都是一个新的session，所以可以在一个会话中存取验证码，就能保证每一次session是对于每个用户是独立存在，保证code的key是独一的存在，那么Redis怎么做到Key的对于每个用户是独一的存在？\n\n解决1：从架构上看我们需要保证手机号唯一所以，而手机号直接就存储在用户那，不管怎样都会让我们获取到，只要将手机号码当成key即可\n\n\n问题2：那用户怎么存储？\n\n解决2：追求简单使用String，追求高效使用复杂一点的Hash，并且效率较高\n\n\n问题3：用户怎么存储到redis？\n\n解决3：使用随机的token，因为以后的登录校验都会有token","date":"2022-05-18 15:23:57","docid":0,"fillcolor":"ffffed99","folded":false,"id":12,"markups":[{"content":"问题：由于拦截器只会拦截部分，所以如果在没有拦截的路径并不能做到刷新token过期时间的作用\n\n解决：\n再加一个拦截器专门获取到用户存储到ThreadLoacl中并刷新对应token\n\n注意：对于拦截器底层有一个order属性来排序，如果没有设置，那都是0，只会按添加顺序拦截","date":"2022-05-18 15:27:47","docid":0,"fillcolor":"ffffed99","id":13,"originaltext":"登录拦截器的优化","page":23,"textblocks":[{"first":[63.19200134277344,87.010009765625,20.040000915527344,22.5],"last":[203.47201538085938,87.010009765625,20.040008544921875,22.5],"length":8,"rects":[[63.19200134277344,87.010009765625,160.3200225830078,22.5]],"start":39,"text":"登录拦截器的优化"}],"type":5,"uuid":"01837bd0f6913796eba2ce4ccb3387e4"},{"content":"对于发送短信和登录验证\n存储验证码信息使用Redis\n存储用户使用Redis\n\n然后最后的校验登录状态使用两个拦截器\n第一个拦截器负责从Redis拿到对应的用户信息放到ThreadLoacl，最后删除ThreadLoacl里的用户信息\n\n第二个拦截器负责，验证ThreadLoacl有没有用户信息，没有直接拦截","date":"2022-05-31 10:14:53","docid":0,"fillcolor":"ffffed99","id":130,"originaltext":"基于Redis实现共享session登录","page":21,"textblocks":[{"first":[63.215999603271484,87.68998718261719,20.039997100830078,23.5],"last":[324.2400207519531,87.68998718261719,20.040008544921875,23.5],"length":20,"rects":[[63.215999603271484,87.68998718261719,281.0640296936035,23.5]],"start":39,"text":"基于Redis实现共享session登录"}],"type":5,"uuid":"1f0822ea6e363512c9b85049f25aa70e"}],"originaltext":"基于Redis实现共享session登录","page":20,"textblocks":[{"first":[63.215999603271484,87.68998718261719,20.039997100830078,23.5],"last":[324.2400207519531,87.68998718261719,20.040008544921875,23.5],"length":20,"rects":[[63.215999603271484,87.68998718261719,281.0640296936035,23.5]],"start":39,"text":"基于Redis实现共享session登录"}],"type":5,"uuid":"0a3b61877bf88d9ca1b91c0273eb2b6f"}],"originaltext":"短信登录","page":3,"textblocks":[{"first":[414.4599914550781,219.16000366210938,32.063995361328125,34.5],"last":[510.58001708984375,219.16000366210938,32.06402587890625,34.5],"length":4,"rects":[[414.4599914550781,219.16000366210938,128.18405151367188,34.5]],"start":0,"text":"短信登录"}],"title":"01-短信登录","type":5,"uuid":"089485c62c7dfa090647ee6ddffed8a3"},{"date":"2022-05-19 11:00:08","docid":0,"fillcolor":"ffffed99","folded":false,"id":14,"markups":[{"content":"缓存可以分为\n1、浏览器缓存\n2、应用层缓存\n3、数据库缓存\n4、CPU缓存（一般做上面三个就可以了）","date":"2022-05-19 11:00:17","docid":0,"fillcolor":"ffffed99","folded":false,"id":15,"markups":[{"content":"1、降低后端和读写数据压力\n2、降低响应时间","date":"2022-05-19 11:07:37","docid":0,"fillcolor":"ffffed99","id":23,"originaltext":"缓存的作用","page":28,"textblocks":[{"first":[109.80000305175781,305.6300048828125,24,26.5],"last":[205.8000030517578,305.6300048828125,24,26.5],"length":5,"rects":[[109.80000305175781,305.6300048828125,120,26.5]],"start":45,"text":"缓存的作用"}],"type":5,"uuid":"9a274c717a1358fd4055d4a17c79809d"},{"content":"1、数据一致性成本\n2、代码维护以及运维成本","date":"2022-05-19 11:07:39","docid":0,"fillcolor":"ffffed99","id":24,"originaltext":"缓存的成本","page":28,"textblocks":[{"first":[735.7000122070312,305.6300048828125,24,26.5],"last":[831.7000122070312,305.6300048828125,24,26.5],"length":5,"rects":[[735.7000122070312,305.6300048828125,120,26.5]],"start":50,"text":"缓存的成本"}],"type":5,"uuid":"45f3357b26799bdd911376bf91e152e8"}],"originaltext":"什么是缓存","page":27,"textblocks":[{"first":[63.215999603271484,87.989990234375,20.039997100830078,22.5],"last":[143.37600708007812,87.989990234375,20.040008544921875,22.5],"length":5,"rects":[[63.215999603271484,87.989990234375,100.20001602172852,22.5]],"start":91,"text":"什么是缓存"}],"type":5,"uuid":"0c3ac42f37ef19efbf03b552d6870b66"},{"content":"使用JSONutils可以做到JSON来回切换\n\n套路：\n先从Redis中获取，拿到直接返回，拿不到，从数据库里面查，查到放到Redis中然后返回","date":"2022-05-19 11:00:24","docid":0,"fillcolor":"ffffed99","id":16,"originaltext":"添加Redis缓存","page":30,"textblocks":[{"first":[63.215999603271484,87.68998718261719,20.039997100830078,23.5],"last":[174.57998657226562,87.68998718261719,20.040008544921875,23.5],"length":9,"rects":[[63.215999603271484,87.68998718261719,131.40399551391602,23.5]],"start":52,"text":"添加Redis缓存"}],"type":5,"uuid":"5e10933b3e347ad8b7ceb66d4f5c3126"},{"content":"数据库数据改变，则缓存中也需要改变，来保证一致性","date":"2022-05-19 11:00:29","docid":0,"fillcolor":"ffffed99","folded":true,"id":17,"markups":[{"content":"内存淘汰机制：\n只有超过内存的时候才将缓存删除，一致性很差\n（适合一成不变的数据）\n超时剔除：\n设置key的过期时间\n居中的操作，比较适合拿来兜底\n\n主动更新：\n一致性最高，当然耗费性能","date":"2022-05-19 14:44:18","docid":0,"fillcolor":"ffffed99","id":25,"originaltext":"业务场景","page":34,"textblocks":[{"first":[77.25599670410156,405.04998779296875,15.959999084472656,18.5],"last":[125.13599395751953,405.04998779296875,15.959999084472656,18.5],"length":4,"rects":[[77.25599670410156,405.04998779296875,63.839996337890625,18.5]],"start":187,"text":"业务场景"}],"type":5,"uuid":"1a60e6f263ffedc2052573b703efe414"},{"content":"1、因为每次更新数据库的时候都会导致缓存的数据失效，但是如果很长一段时间没有人查询，那么每次更新数据库并更新缓存的操作在这一段时间的数据更新是无效的，因为根本没人用，所以删除更好\n\n2、原子性：\n单系统使用事务保证，分布式使用TCC分布式事务保证\n\n3、并发：\n都行，但是各有特点","date":"2022-05-19 11:00:57","docid":0,"fillcolor":"ffffed99","id":18,"originaltext":"主动更新策略","page":36,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,23.5],"last":[163.416015625,86.989990234375,20.040008544921875,23.5],"length":6,"rects":[[63.215999603271484,86.989990234375,120.24002456665039,23.5]],"start":59,"text":"主动更新策略"}],"type":5,"uuid":"95e0aa99a37397d17aa705d9506ae894"},{"date":"2022-05-19 15:22:09","docid":0,"fillcolor":"ffffed99","folded":true,"id":28,"markups":[{"content":"由于删除缓存较快，更新数据库较慢\n\n而查询缓存和数据库很快，写入缓存也很快\n\n导致数据库更新的时候，线程2可能操作，然后更新的缓存是就的值","date":"2022-05-19 15:07:38","docid":0,"fillcolor":"ffffed99","id":26,"originaltext":"先删除缓存，再操作数据库","page":39,"textblocks":[{"first":[170.52000427246094,145.60000610351562,14.039993286132812,16.5],"last":[324.8336181640625,145.60000610351562,14.040008544921875,16.5],"length":12,"rects":[[170.52000427246094,145.60000610351562,168.35362243652344,16.5]],"start":59,"text":"先删除缓存，再操作数据库"}],"type":5,"uuid":"a36ed59777e25211e73ceeac3c2192a3"},{"content":"并发角度上看写的时候先操作数据库再操作缓存更好","date":"2022-05-19 15:07:41","docid":0,"fillcolor":"ffffed99","id":27,"originaltext":"先操作数据库，再删除缓存","page":39,"textblocks":[{"first":[625.1500244140625,145.60000610351562,14.03997802734375,16.5],"last":[779.4634399414062,145.60000610351562,14.03997802734375,16.5],"length":12,"rects":[[625.1500244140625,145.60000610351562,168.3533935546875,16.5]],"start":71,"text":"先操作数据库，再删除缓存"}],"type":5,"uuid":"4038ae96c7cf93b9a5d9b965b650e7d2"}],"originaltext":"缓存更新策略的最佳实践方案：","page":40,"textblocks":[{"first":[410.92999267578125,161.23001098632812,18.02398681640625,21.5],"last":[644.9299926757812,161.23001098632812,18.02398681640625,21.5],"length":14,"rects":[[410.92999267578125,161.23001098632812,252.02398681640625,21.5]],"start":44,"text":"缓存更新策略的最佳实践方案："}],"type":5,"uuid":"31dc68af0e58e94328e51c35903548e5"}],"originaltext":"缓存更新策略","page":34,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,23.5],"last":[163.416015625,86.989990234375,20.040008544921875,23.5],"length":6,"rects":[[63.215999603271484,86.989990234375,120.24002456665039,23.5]],"start":39,"text":"缓存更新策略"}],"type":5,"uuid":"6a2e9356458526e4ae80565f33777a5f"},{"content":"单个key\n\n两种解决方案：\n一般选择缓存空对象也就是第一种","date":"2022-05-19 11:01:15","docid":0,"fillcolor":"ffffed99","folded":false,"id":19,"markups":[{"content":"缓存空对象：\n将查询的东西设置成有限时间缓存到redis中，破坏了redis和数据库的一致性","date":"2022-05-19 16:28:36","docid":0,"fillcolor":"ffffed99","id":29,"originaltext":"缓存空对象","page":43,"textblocks":[{"first":[85.75199890136719,202.92001342773438,15.959999084472656,18.5],"last":[149.59201049804688,202.92001342773438,15.960006713867188,18.5],"length":5,"rects":[[85.75199890136719,202.92001342773438,79.80001831054688,18.5]],"start":105,"text":"缓存空对象"}],"type":5,"uuid":"cd2f119eff1f2e53b01ce4c783a5a824"},{"content":"布隆过滤：\n可以简单的理解成布隆过滤器是二进制数组，里面存储二进制位\n（将数据计算出hash值，保存到过滤器中，如果hash值对的上就是存在，对不上就是不存在）\n他能做到不存在是一定不存在，但是存在则不一定存在","date":"2022-05-19 16:28:38","docid":0,"fillcolor":"ffffed99","id":30,"originaltext":"布隆过滤","page":43,"textblocks":[{"first":[85.75199890136719,318.1499938964844,15.959999084472656,18.5],"last":[133.6320037841797,318.1499938964844,15.960006713867188,18.5],"length":4,"rects":[[85.75199890136719,318.1499938964844,63.84001159667969,18.5]],"start":155,"text":"布隆过滤"}],"type":5,"uuid":"04eccfedac4ecb24c5b1d19af2121928"},{"content":"对于查询需要修改两个地方\n1、当数据库查询到空对象的时候，需要将对应的key缓存\n\n2、当查询Redis中命中对应key还需要判断是否是空对象\n\n\n\n命中：需要判断是否是空值\n\n未命中：需要查询数据库，不管怎样都需要缓存到数据库中，不过一个是缓存空值，一个是缓存正常数据","date":"2022-05-19 16:29:31","docid":0,"fillcolor":"ffffed99","id":31,"originaltext":"缓存穿透","page":44,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,22.5],"last":[123.33599853515625,86.989990234375,20.040008544921875,22.5],"length":4,"rects":[[63.215999603271484,86.989990234375,80.16000747680664,22.5]],"start":139,"text":"缓存穿透"}],"type":5,"uuid":"08918cc6436bf8324415a0a74b05b85f"}],"originaltext":"缓存穿透","page":43,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,22.5],"last":[123.33599853515625,86.989990234375,20.040008544921875,22.5],"length":4,"rects":[[63.215999603271484,86.989990234375,80.16000747680664,22.5]],"start":200,"text":"缓存穿透"}],"type":5,"uuid":"7012280e6d91483388c9b1b43d933fa3"},{"content":"全部key","date":"2022-05-19 11:01:24","docid":0,"fillcolor":"ffffed99","folded":true,"id":20,"markups":[{"date":"2022-05-19 16:51:45","docid":0,"fillcolor":"ffffed99","id":32,"originaltext":"缓存雪崩","page":50,"textblocks":[{"first":[63.19200134277344,135.9199981689453,15.984001159667969,21.5],"last":[111.0719985961914,135.9199981689453,15.984001159667969,21.5],"length":4,"rects":[[63.19200134277344,135.9199981689453,63.86399841308594,21.5]],"start":39,"text":"缓存雪崩"}],"type":5,"uuid":"416e4a28e71874918f8f2d0252f76782"},{"date":"2022-05-19 16:51:50","docid":0,"fillcolor":"ffffed99","folded":true,"id":33,"markups":[{"date":"2022-05-19 16:51:59","docid":0,"fillcolor":"ffffed99","id":34,"originaltext":" 给不同的Key的TTL添加随机值","page":50,"textblocks":[{"first":[77.03543853759766,200.49998474121094,8.716560363769531,18.5],"last":[259.6299743652344,200.49998474121094,14.040008544921875,18.5],"length":17,"rects":[[77.03543853759766,200.49998474121094,196.6345443725586,18.5]],"start":101,"text":" 给不同的Key的TTL添加随机值"}],"type":5,"uuid":"31dac907968c672e39a4cddef53657b7"},{"date":"2022-05-19 16:52:02","docid":0,"fillcolor":"ffffed99","id":35,"originaltext":" 利用Redis集群提高服务的可用性","page":50,"textblocks":[{"first":[77.03543853759766,230.3599853515625,8.716560363769531,16.5],"last":[275.949951171875,230.3599853515625,14.040008544921875,16.5],"length":18,"rects":[[77.03543853759766,230.3599853515625,212.95452117919922,16.5]],"start":120,"text":" 利用Redis集群提高服务的可用性"}],"type":5,"uuid":"599a7971548863db64803d738177359b"},{"date":"2022-05-19 16:52:04","docid":0,"fillcolor":"ffffed99","id":36,"originaltext":" 给缓存业务添加降级限流策略","page":50,"textblocks":[{"first":[77.03543853759766,257.95001220703125,8.716560363769531,17.5],"last":[254.1055908203125,257.95001220703125,14.040008544921875,17.5],"length":14,"rects":[[77.03543853759766,257.95001220703125,191.11016082763672,17.5]],"start":140,"text":" 给缓存业务添加降级限流策略"}],"type":5,"uuid":"da8372dabe72e0e6e74239920aa110fd"},{"date":"2022-05-19 16:52:08","docid":0,"fillcolor":"ffffed99","id":37,"originaltext":" 给业务添加多级缓存","page":50,"textblocks":[{"first":[77.03543853759766,286.510009765625,8.716560363769531,16.5],"last":[198.0719757080078,286.510009765625,14.039993286132812,16.5],"length":10,"rects":[[77.03543853759766,286.510009765625,135.07653045654297,16.5]],"start":156,"text":" 给业务添加多级缓存"}],"type":5,"uuid":"834dc1458d7b5ec6e694cee9e908731b"}],"originaltext":"解决方案","page":50,"textblocks":[{"first":[63.19200134277344,170.27999877929688,15.959999084472656,18.5],"last":[111.0719985961914,170.27999877929688,15.959999084472656,18.5],"length":4,"rects":[[63.19200134277344,170.27999877929688,63.839996337890625,18.5]],"start":94,"text":"解决方案"}],"type":5,"uuid":"a0cccd2370ec74b26378f0310230ed44"}],"originaltext":"缓存雪崩","page":50,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,22.5],"last":[123.33599853515625,86.989990234375,20.040008544921875,22.5],"length":4,"rects":[[63.215999603271484,86.989990234375,80.16000747680664,22.5]],"start":167,"text":"缓存雪崩"}],"type":5,"uuid":"368fb4a2821302dad6355828372c885a"},{"content":"部分key，并且这些key，较难恢复","date":"2022-05-19 11:01:30","docid":0,"fillcolor":"ffffed99","folded":false,"id":21,"markups":[{"date":"2022-05-19 16:54:13","docid":0,"fillcolor":"ffffed99","id":38,"originaltext":"缓存击穿问题","page":52,"textblocks":[{"first":[63.19200134277344,136.6199951171875,15.984001159667969,19.5],"last":[142.99200439453125,136.6199951171875,15.983993530273438,19.5],"length":6,"rects":[[63.19200134277344,136.6199951171875,95.78399658203125,19.5]],"start":39,"text":"缓存击穿问题"}],"type":5,"uuid":"e52c9c73a99559203a6bddc5c32da67f"},{"date":"2022-05-19 16:57:24","docid":0,"fillcolor":"ffffed99","folded":true,"id":39,"markups":[{"content":"做到只有一个线程在创建缓存，其他线程等待\n（保证系统的一致性）","date":"2022-05-19 16:57:48","docid":0,"fillcolor":"ffffed99","id":42,"originaltext":"互斥锁","page":54,"textblocks":[{"first":[123.4800033569336,254.6400146484375,18.00000762939453,20.5],"last":[159.48001098632812,254.6400146484375,18,20.5],"length":3,"rects":[[123.4800033569336,254.6400146484375,54.00000762939453,20.5]],"start":53,"text":"互斥锁"}],"type":5,"uuid":"c1ea4105c79b01568fe1f400303b8588"},{"content":"不再设置真正的过期时间，将过期时间放到value中，自己管理过期时间，过期的时候自己开一个新的线程加锁重新获取\n（保证系统的可用性）","date":"2022-05-19 16:57:52","docid":0,"fillcolor":"ffffed99","id":43,"originaltext":"逻辑过期","page":54,"textblocks":[{"first":[114.4800033569336,382.0920104980469,18.00000762939453,23.209991455078125],"last":[168.48001098632812,382.0920104980469,18,23.209991455078125],"length":4,"rects":[[114.4800033569336,382.0920104980469,72.00000762939453,23.209991455078125]],"start":104,"text":"逻辑过期"}],"type":5,"uuid":"571e47b478349cb95e035710a2d6527a"}],"originaltext":"解决方案","page":52,"textblocks":[{"first":[111.0719985961914,199.07998657226562,15.959999084472656,18.5],"last":[158.95201110839844,199.07998657226562,15.960006713867188,18.5],"length":4,"rects":[[111.0719985961914,199.07998657226562,63.84001922607422,18.5]],"start":114,"text":"解决方案"}],"type":5,"uuid":"fe1329fbd3d14187036639c3fad65d31"},{"content":"使用setnx做锁\n\n其他线程等待，单一线程获取锁恢复缓存，然后返回数据","date":"2022-05-19 17:08:39","docid":0,"fillcolor":"ffffed99","id":44,"originaltext":"基于互斥锁方式解决缓存击穿问题","page":55,"textblocks":[{"first":[180.10000610351562,94.30999755859375,20.040008544921875,23.5],"last":[460.4196472167969,94.30999755859375,20.040008544921875,23.5],"length":15,"rects":[[180.10000610351562,94.30999755859375,300.3596496582031,23.5]],"start":41,"text":"基于互斥锁方式解决缓存击穿问题"}],"type":5,"uuid":"0c67dddf290ddc27ef57d986adf40b8f"},{"content":"其他线程直接返回旧数据\n单一线程获取到锁开启独立线程恢复缓存，单一线程直接返回旧数据","date":"2022-05-19 17:08:46","docid":0,"fillcolor":"ffffed99","id":45,"originaltext":"基于逻辑过期方式解决缓存击穿问题","page":56,"textblocks":[{"first":[180.10000610351562,94.30999755859375,20.040008544921875,23.5],"last":[480.45965576171875,94.30999755859375,20.040008544921875,23.5],"length":16,"rects":[[180.10000610351562,94.30999755859375,320.399658203125,23.5]],"start":41,"text":"基于逻辑过期方式解决缓存击穿问题"}],"type":5,"uuid":"4040927553dc32bfc09c015543ac4bd1"}],"originaltext":"缓存击穿","page":52,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,22.5],"last":[123.33599853515625,86.989990234375,20.040008544921875,22.5],"length":4,"rects":[[63.215999603271484,86.989990234375,80.16000747680664,22.5]],"start":123,"text":"缓存击穿"}],"type":5,"uuid":"f7c26c6f3871b073ca25d6756363c658"},{"content":"将泛型运用到极致","date":"2022-05-19 11:01:40","docid":0,"fillcolor":"ffffed99","id":22,"originaltext":"缓存工具封装","page":58,"textblocks":[{"first":[180.10000610351562,95.20999145507812,20.040008544921875,22.5],"last":[280.300048828125,95.20999145507812,20.040008544921875,22.5],"length":6,"rects":[[180.10000610351562,95.20999145507812,120.24005126953125,22.5]],"start":293,"text":"缓存工具封装"}],"type":5,"uuid":"044f5c563a3c530956c0d702fc85db02"}],"originaltext":"商户查询缓存","page":25,"textblocks":[{"first":[423.8399963378906,219.16000366210938,32.063995361328125,34.5],"last":[584.1600341796875,219.16000366210938,32.06402587890625,34.5],"length":6,"rects":[[423.8399963378906,219.16000366210938,192.38406372070312,34.5]],"start":0,"text":"商户查询缓存"}],"type":5,"uuid":"d44091e381130f5a402b458c0b79dbe8"},{"date":"2022-05-20 15:58:15","docid":0,"fillcolor":"ffffed99","folded":false,"id":46,"markups":[{"date":"2022-05-20 16:16:42","docid":0,"fillcolor":"ffffed99","folded":false,"id":47,"markups":[{"content":"数据库中的自增存在问题","date":"2022-05-20 16:30:35","docid":0,"fillcolor":"ffffed99","folded":true,"id":51,"markups":[{"content":"规律明显可以猜到，订单数","date":"2022-05-20 16:26:50","docid":0,"fillcolor":"ffffed99","id":48,"originaltext":"id的规律性太明显","page":61,"textblocks":[{"first":[85.75199890136719,362.73675537109375,4.245361328125,18.8665771484375],"last":[195.9100341796875,362.73675537109375,15.960006713867188,18.8665771484375],"length":9,"rects":[[85.75199890136719,362.73675537109375,126.1180419921875,18.8665771484375]],"start":118,"text":"id的规律性太明显"}],"type":5,"uuid":"05ca44baf4b2b07cff8a463e7caff35a"},{"content":"几亿的数据","date":"2022-05-20 16:26:55","docid":0,"fillcolor":"ffffed99","id":49,"originaltext":"受单表数据量的限制","page":61,"textblocks":[{"first":[85.75199890136719,394.9700012207031,15.959999084472656,18.5],"last":[213.43203735351562,394.9700012207031,15.960006713867188,18.5],"length":9,"rects":[[85.75199890136719,394.9700012207031,143.64004516601562,18.5]],"start":130,"text":"受单表数据量的限制"}],"type":5,"uuid":"b119c87dedd79ed3f31728b3011e9a96"}],"originaltext":"一些问题","page":61,"textblocks":[{"first":[821.1717529296875,299.16998291015625,15.96002197265625,21.5],"last":[869.1635131835938,299.16998291015625,15.96002197265625,21.5],"length":4,"rects":[[821.1717529296875,299.16998291015625,63.9517822265625,21.5]],"start":109,"text":"一些问题"}],"type":5,"uuid":"bf74e0f5febca0c1c87ffda1a14b3841"},{"date":"2022-05-20 16:30:24","docid":0,"fillcolor":"ffffed99","folded":false,"id":50,"markups":[{"content":"时间戳：表示开始时间\n\n序列号：\n先使用\n\"icr:\" + keyPrefix + \":\" + date\n存储当前序列号到Redis中\n然后获取对应增加的号码取出，作为序列号\n如此就可以确定对应日期的订单量\n生成的数据库ID就是\n时间戳与序列号的拼接","date":"2022-05-20 16:47:29","docid":0,"fillcolor":"ffffed99","id":52,"originaltext":"ID的组成部分","page":63,"textblocks":[{"first":[72.93599700927734,353.3500061035156,4.692237854003906,19.5],"last":[153.5760040283203,353.3500061035156,15.960006713867188,19.5],"length":7,"rects":[[72.93599700927734,353.3500061035156,96.60001373291016,19.5]],"start":1256,"text":"ID的组成部分"}],"type":5,"uuid":"de6da00b22dedae11b250e68bbaf4b1d"}],"originaltext":"全局ID生成器","page":62,"textblocks":[{"first":[63.19200134277344,137.51998901367188,15.984001159667969,19.5],"last":[143.8300018310547,137.51998901367188,15.983993530273438,19.5],"length":7,"rects":[[63.19200134277344,137.51998901367188,96.62199401855469,19.5]],"start":39,"text":"全局ID生成器"}],"type":5,"uuid":"ac69a12d1f5da87cef309af4bad3f208"}],"originaltext":"全局唯一ID","page":61,"textblocks":[{"first":[63.215999603271484,87.68998718261719,20.039997100830078,23.5],"last":[149.2599639892578,87.68998718261719,15.270477294921875,23.5],"length":6,"rects":[[63.215999603271484,87.68998718261719,101.3144416809082,23.5]],"start":140,"text":"全局唯一ID"}],"type":5,"uuid":"786a62596d9c8e1d4a43d0969795db02"},{"date":"2022-05-26 16:32:18","docid":0,"fillcolor":"ffffed99","folded":false,"id":53,"markups":[{"date":"2022-05-26 16:32:39","docid":0,"fillcolor":"ffffed99","folded":true,"id":54,"markups":[{"date":"2022-05-26 16:32:45","docid":0,"fillcolor":"ffffed99","id":55,"originaltext":"秒杀是否开始或结束，如果尚未开始或已经结束则无法下单","page":69,"textblocks":[{"first":[202.66000366210938,165.91000366210938,14.063995361328125,17.5],"last":[553.0271606445312,165.91000366210938,14.06402587890625,17.5],"length":26,"rects":[[202.66000366210938,165.91000366210938,364.4311828613281,17.5]],"start":66,"text":"秒杀是否开始或结束，如果尚未开始或已经结束则无法下单"}],"type":5,"uuid":"180bdfe7116e609bf624b74e267a31d6"},{"date":"2022-05-26 16:32:51","docid":0,"fillcolor":"ffffed99","id":56,"originaltext":"库存是否充足，不足则无法下单","page":69,"textblocks":[{"first":[202.66000366210938,194.489990234375,14.039993286132812,16.5],"last":[385.0536804199219,194.489990234375,14.040008544921875,16.5],"length":14,"rects":[[202.66000366210938,194.489990234375,196.43368530273438,16.5]],"start":94,"text":"库存是否充足，不足则无法下单"}],"type":5,"uuid":"423b899ac44334a8f1b6a8c3c6d201d1"}],"originaltext":"两点","page":69,"textblocks":[{"first":[291.82000732421875,134.3900146484375,15.959991455078125,18.5],"last":[307.7799987792969,134.3900146484375,15.959991455078125,18.5],"length":2,"rects":[[291.82000732421875,134.3900146484375,31.91998291015625,18.5]],"start":61,"text":"两点"}],"type":5,"uuid":"296b58621290c22917f078aa44242ea4"}],"originaltext":"实现优惠券秒杀下单","page":66,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,23.5],"last":[223.53604125976562,86.989990234375,20.040008544921875,23.5],"length":9,"rects":[[63.215999603271484,86.989990234375,180.36005020141602,23.5]],"start":181,"text":"实现优惠券秒杀下单"}],"type":5,"uuid":"ec863fb814e66f2dc27255dae680ce6f"}],"originaltext":"优惠券秒杀","page":59,"textblocks":[{"first":[419.260009765625,219.97000122070312,32.040008544921875,33.5],"last":[547.4199829101562,219.97000122070312,32.03997802734375,33.5],"length":5,"rects":[[419.260009765625,219.97000122070312,160.199951171875,33.5]],"start":0,"text":"优惠券秒杀"}],"type":5,"uuid":"89518ad64977c0d342cbf8fed17e02d9"},{"date":"2022-05-27 10:13:31","docid":0,"fillcolor":"ffffed99","folded":false,"id":57,"markups":[{"date":"2022-05-27 10:13:50","docid":0,"fillcolor":"ffffed99","folded":false,"id":58,"markups":[{"content":"认为线程一定回发生线程安全问题，所以每一次执行到回发生线程安全问题的代码都加锁让他单线程执行\n\n严重影响性能","date":"2022-05-27 10:13:57","docid":0,"fillcolor":"ffffed99","id":59,"originaltext":"悲观锁","page":73,"textblocks":[{"first":[249.0500030517578,192.6400146484375,20.039993286132812,22.5],"last":[289.1300048828125,192.6400146484375,20.040008544921875,22.5],"length":3,"rects":[[249.0500030517578,192.6400146484375,60.12001037597656,22.5]],"start":79,"text":"悲观锁"}],"type":5,"uuid":"8e9a766403303ad8847a6d29e218f11e"},{"content":"认为不一定回发生线程安全问题，每次修改数据都会去比对数据是否发生改变，\n被改变说明发生了线程安全问题，重试或者抛出异常","date":"2022-05-27 10:14:00","docid":0,"fillcolor":"ffffed99","id":60,"originaltext":"乐观锁","page":73,"textblocks":[{"first":[658.3699951171875,195.73001098632812,20.03997802734375,22.5],"last":[698.498046875,195.73001098632812,20.03997802734375,22.5],"length":3,"rects":[[658.3699951171875,195.73001098632812,60.16802978515625,22.5]],"start":265,"text":"乐观锁"}],"type":5,"uuid":"1f1f25e54132a0cb7a5f26f830d8d7f9"}],"originaltext":"解决方案","page":73,"textblocks":[{"first":[462.63946533203125,136.6199951171875,15.9840087890625,19.5],"last":[510.6313171386719,136.6199951171875,15.983978271484375,19.5],"length":4,"rects":[[462.63946533203125,136.6199951171875,63.975830078125,19.5]],"start":64,"text":"解决方案"}],"type":5,"uuid":"132bcf3b9cf1cea579c4a49af94e57d8"},{"content":"成功率太低了","date":"2022-05-27 10:19:56","docid":0,"fillcolor":"ffffed99","folded":false,"id":61,"markups":[{"date":"2022-05-27 10:29:05","docid":0,"fillcolor":"ffffed99","id":62,"originaltext":"版本号法","page":74,"textblocks":[{"first":[90.16799926757812,173.95999145507812,15.984001159667969,18.5],"last":[138.04800415039062,173.95999145507812,15.983993530273438,18.5],"length":4,"rects":[[90.16799926757812,173.95999145507812,63.86399841308594,18.5]],"start":89,"text":"版本号法"}],"type":5,"uuid":"0422753494da31beb975eeca8b09fe81"},{"content":"版本号的改进\n使用库存代替版本号","date":"2022-05-27 10:29:13","docid":0,"fillcolor":"ffffed99","id":63,"originaltext":"CAS法","page":75,"textblocks":[{"first":[90.16799926757812,174.95999145507812,10.757232666015625,15.5],"last":[122.56999969482422,174.95999145507812,15.984001159667969,15.5],"length":4,"rects":[[90.16799926757812,174.95999145507812,48.38600158691406,15.5]],"start":81,"text":"CAS法"}],"type":5,"uuid":"20143d95b772f2ed0db3c8e0cdd130b0"}],"originaltext":"乐观锁","page":74,"textblocks":[{"first":[63.215999603271484,87.68998718261719,20.039997100830078,23.5],"last":[103.2959976196289,87.68998718261719,20.040000915527344,23.5],"length":3,"rects":[[63.215999603271484,87.68998718261719,60.119998931884766,23.5]],"start":83,"text":"乐观锁"}],"type":5,"uuid":"6b0d1e5a2e27a592bb0393b71d6e06fa"},{"date":"2022-05-27 10:30:34","docid":0,"fillcolor":"ffffed99","id":64,"originaltext":"超卖这样的线程安全问题，解决方案有哪些？","page":76,"textblocks":[{"first":[410.92999267578125,189.92999267578125,18,20.5],"last":[752.9299926757812,189.92999267578125,18,20.5],"length":20,"rects":[[410.92999267578125,189.92999267578125,360,20.5]],"start":44,"text":"超卖这样的线程安全问题，解决方案有哪些？"}],"type":5,"uuid":"91423a9eb570eb61d7d62918fd531310"}],"originaltext":"超卖问题","page":71,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,23.5],"last":[123.33599853515625,86.989990234375,20.040008544921875,23.5],"length":4,"rects":[[63.215999603271484,86.989990234375,80.16000747680664,23.5]],"start":39,"text":"超卖问题"}],"type":5,"uuid":"c497c1cc723560489704b8b045c86391"},{"content":"一个用户只能有一个张优惠卷\n\n一般使用的都是使用set集合，使用对应优惠劵做key","date":"2022-05-27 10:30:40","docid":0,"fillcolor":"ffffed99","folded":true,"id":65,"markups":[{"content":"加锁能 解决","date":"2022-05-27 11:47:20","docid":0,"fillcolor":"ffffed99","id":67,"originaltext":"单机情况下","page":80,"textblocks":[{"first":[206.83203125,136.6199951171875,15.983993530273438,19.5],"last":[270.67205810546875,136.6199951171875,15.9840087890625,19.5],"length":5,"rects":[[206.83203125,136.6199951171875,79.82403564453125,19.5]],"start":48,"text":"单机情况下"}],"type":5,"uuid":"78b0c2e434bc21af45c90ce536342ca0"},{"content":"直接出现问题，因为监视器也就是锁，我们设置的监视器是配合StringTable存在的，由于两套JVM存在不用的StringTable导致监视器出问题了，需要修改监视器","date":"2022-05-27 11:47:15","docid":0,"fillcolor":"ffffed99","id":66,"originaltext":"集群模式","page":80,"textblocks":[{"first":[494.5594482421875,136.6199951171875,15.9840087890625,19.5],"last":[542.5513305664062,136.6199951171875,15.9840087890625,19.5],"length":4,"rects":[[494.5594482421875,136.6199951171875,63.97589111328125,19.5]],"start":66,"text":"集群模式"}],"type":5,"uuid":"58708af5bbb46a2f4be42ab522954a6b"}],"originaltext":"一人一单","page":78,"textblocks":[{"first":[180.10000610351562,93.42001342773438,20.040008544921875,22.5],"last":[240.22003173828125,93.42001342773438,20.040008544921875,22.5],"length":4,"rects":[[180.10000610351562,93.42001342773438,80.1600341796875,22.5]],"start":71,"text":"一人一单"}],"type":5,"uuid":"47b24cda447105986a96f2c51707057f"},{"content":"解决优惠卷订单一人一单集群线程问题","date":"2022-05-27 11:49:16","docid":0,"fillcolor":"ffffed99","folded":false,"id":68,"markups":[{"date":"2022-05-27 11:53:39","docid":0,"fillcolor":"ffffed99","folded":true,"id":69,"markups":[{"date":"2022-05-27 11:53:56","docid":0,"fillcolor":"ffffed99","folded":false,"id":71,"markups":[{"date":"2022-05-27 11:53:50","docid":0,"fillcolor":"ffffed99","id":70,"originaltext":"满足分布式系统或集群模式下多进程可见并且互斥的锁。","page":88,"textblocks":[{"first":[142.99000549316406,136.6199951171875,15.983993530273438,19.5],"last":[526.5892944335938,136.6199951171875,15.9840087890625,19.5],"length":25,"rects":[[142.99000549316406,136.6199951171875,399.5832977294922,19.5]],"start":44,"text":"满足分布式系统或集群模式下多进程可见并且互斥的锁。"}],"type":5,"uuid":"c0b5798cdf2f5a51e532bbc201bd9f4e"}],"originaltext":"分布式锁","page":88,"textblocks":[{"first":[63.19200134277344,136.6199951171875,15.984001159667969,19.5],"last":[111.0719985961914,136.6199951171875,15.984001159667969,19.5],"length":4,"rects":[[63.19200134277344,136.6199951171875,63.86399841308594,19.5]],"start":39,"text":"分布式锁"}],"type":5,"uuid":"31cd54aa6d38efa1382fa2de7f0c608b"}],"originaltext":"什么是分布式锁","page":88,"textblocks":[{"first":[63.215999603271484,85.92999267578125,24.000003814697266,27.5],"last":[207.21600341796875,85.92999267578125,24,27.5],"length":7,"rects":[[63.215999603271484,85.92999267578125,168.00000381469727,27.5]],"start":70,"text":"什么是分布式锁"}],"type":5,"uuid":"0680da9ee6d32090a705a75ff0d0a303"},{"date":"2022-05-27 11:54:11","docid":0,"fillcolor":"ffffed99","folded":true,"id":72,"markups":[{"date":"2022-05-27 11:54:19","docid":0,"fillcolor":"ffffed99","id":73,"originaltext":"MySQL","page":89,"textblocks":[{"first":[273.1199951171875,195.6199951171875,18.503997802734375,22.5],"last":[327.4440002441406,195.6199951171875,9.84600830078125,22.5],"length":5,"rects":[[273.1199951171875,195.6199951171875,64.17001342773438,22.5]],"start":39,"text":"MySQL"}],"type":5,"uuid":"2cf2e5b245dca6a2e8037c9afe1b3782"},{"date":"2022-05-27 11:54:21","docid":0,"fillcolor":"ffffed99","id":74,"originaltext":"Redis","page":89,"textblocks":[{"first":[508.32000732421875,195.6199951171875,12.56402587890625,22.5],"last":[548.1539916992188,195.6199951171875,8.89202880859375,22.5],"length":5,"rects":[[508.32000732421875,195.6199951171875,48.72601318359375,22.5]],"start":44,"text":"Redis"}],"type":5,"uuid":"6badf0c7323e26903eb67992680ebb34"},{"date":"2022-05-27 11:54:24","docid":0,"fillcolor":"ffffed99","id":75,"originaltext":"Zookeeper","page":89,"textblocks":[{"first":[718.1500244140625,195.6199951171875,11.70001220703125,22.5],"last":[807.5560913085938,195.6199951171875,7.63201904296875,22.5],"length":9,"rects":[[718.1500244140625,195.6199951171875,97.0380859375,22.5]],"start":49,"text":"Zookeeper"}],"type":5,"uuid":"7dfa983412fb4ed87b619b12220524fa"}],"originaltext":"三种","page":89,"textblocks":[{"first":[622.5751953125,137.51998901367188,15.9840087890625,19.5],"last":[638.5352172851562,137.51998901367188,15.9840087890625,19.5],"length":2,"rects":[[622.5751953125,137.51998901367188,31.94403076171875,19.5]],"start":94,"text":"三种"}],"type":5,"uuid":"2725f4acea71244f4fc5bb460a1a5420"},{"date":"2022-05-27 11:59:44","docid":0,"fillcolor":"ffffed99","folded":true,"id":76,"markups":[{"content":"使用\nset key  value nx ex 存活时间 ","date":"2022-05-27 11:59:48","docid":0,"fillcolor":"ffffed99","id":77,"originaltext":"获取锁","page":90,"textblocks":[{"first":[85.75199890136719,170.17999267578125,15.959999084472656,19.5],"last":[117.6719970703125,170.17999267578125,15.960006713867188,19.5],"length":3,"rects":[[85.75199890136719,170.17999267578125,47.8800048828125,19.5]],"start":73,"text":"获取锁"}],"type":5,"uuid":"cbf0368a225300ade7d1c006434d1c21"},{"date":"2022-05-27 11:59:53","docid":0,"fillcolor":"ffffed99","id":78,"originaltext":"释放锁","page":90,"textblocks":[{"first":[85.75199890136719,308.144287109375,15.959999084472656,19.88214111328125],"last":[117.6719970703125,308.144287109375,15.960006713867188,19.88214111328125],"length":3,"rects":[[85.75199890136719,308.144287109375,47.8800048828125,19.88214111328125]],"start":125,"text":"释放锁"}],"type":5,"uuid":"c78851f3c51440cf257c6dd64cfbe638"}],"originaltext":"基于Redis的分布式锁","page":90,"textblocks":[{"first":[63.215999603271484,85.92999267578125,24.000003814697266,27.5],"last":[268.6600036621094,85.92999267578125,24,27.5],"length":12,"rects":[[63.215999603271484,85.92999267578125,229.4440040588379,27.5]],"start":39,"text":"基于Redis的分布式锁"}],"type":5,"uuid":"24991596154a712c80197e26348e97b4"},{"content":"可能存在的问题\n当某一线程阻塞导致锁超时，自动释放锁\n另一线程获取锁，这时第一线程完成需要释放锁，因为方向代理发送的请求、userID并且两者key一样只是运行在不同的服务器中，第一线程释放锁将第二线程的加锁状态打破\n第三线程重复这个状态，导致都没有加锁\n\n解决流程如下","date":"2022-05-27 12:00:15","docid":0,"fillcolor":"ffffed99","folded":true,"id":79,"markups":[{"date":"2022-05-27 15:05:28","docid":0,"id":80,"imgfile":"64e69d62bd91db366b52c36ec555375d.png","linecolor":"ffa0ec6f","linewidth":2,"page":95,"rect":[505.7355492477577,124.5123996628218,896.1818395484582,509.578524545993],"title":"解决方案","type":2,"uuid":"ab32ae500a0a61106f945f08c00daebb"},{"date":"2022-05-27 15:05:59","docid":0,"fillcolor":"ffffed99","id":81,"originaltext":"改进Redis的分布式锁","page":96,"textblocks":[{"first":[180.10000610351562,95.14399719238281,20.040008544921875,24.170013427734375],"last":[351.5800476074219,95.14399719238281,20.040008544921875,24.170013427734375],"length":12,"rects":[[180.10000610351562,95.14399719238281,191.52005004882812,24.170013427734375]],"start":41,"text":"改进Redis的分布式锁"}],"type":5,"uuid":"18a65fa795d2819f877aad12af3563e6"}],"originaltext":"基于Redis实现分布式锁初级版本","page":91,"textblocks":[{"first":[180.10000610351562,95.14399719238281,20.040008544921875,24.170013427734375],"last":[451.65985107421875,95.14399719238281,20.040008544921875,24.170013427734375],"length":17,"rects":[[180.10000610351562,95.14399719238281,291.599853515625,24.170013427734375]],"start":41,"text":"基于Redis实现分布式锁初级版本"}],"title":"被其他线程释放锁","type":5,"uuid":"caf0d79b4e0b25f057ca5e10bee99904"},{"content":"由于检查和释放锁是两步操作，可能会导致检查后阻塞，是一个ok的\n然后超时这个锁被释放，然后其他线程加锁，第一个ok的线程运行完成，继续释放锁，导致第二线程锁被释放\n\n解决：需要使用cas操作，不能将他们分开（就是最后的检查是否是当前线程的锁，然后释放的操作）","date":"2022-05-27 15:30:09","docid":0,"fillcolor":"ffffed99","id":82,"originaltext":"基于Redis的分布式锁","page":97,"textblocks":[{"first":[63.215999603271484,85.92999267578125,24.000003814697266,27.5],"last":[268.6600036621094,85.92999267578125,24,27.5],"length":12,"rects":[[63.215999603271484,85.92999267578125,229.4440040588379,27.5]],"start":39,"text":"基于Redis的分布式锁"}],"title":"释放锁的时候出问题","type":5,"uuid":"04cf4d4717d5edaf96e6cb41bb045b65"},{"content":"实现释放锁的cas操作\n\nRedis是存在事务的，只不过是一个批处理，只能保证原子性，不能保证一致性\n\n解决方案：使用Lua脚本将多条Redis命令集合在一起，做到这些命令的原子性","date":"2022-05-27 15:35:12","docid":0,"fillcolor":"ffffed99","folded":true,"id":83,"markups":[{"content":"使用Lua脚本编辑原子命令","date":"2022-05-27 16:09:07","docid":0,"fillcolor":"ffffed99","id":84,"originaltext":"Lua脚本来表示","page":100,"textblocks":[{"first":[111.06999969482422,300.7699890136719,8.187477111816406,19.5],"last":[201.79002380371094,300.7699890136719,15.960006713867188,19.5],"length":8,"rects":[[111.06999969482422,300.7699890136719,106.6800308227539,19.5]],"start":133,"text":"Lua脚本来表示"}],"type":5,"uuid":"b5bc62263af8720cedc3b4d9e604924b"}],"originaltext":"Redis的Lua脚本","page":98,"textblocks":[{"first":[63.215999603271484,85.92999267578125,15.672000885009766,27.5],"last":[213.10000610351562,85.92999267578125,24,27.5],"length":11,"rects":[[63.215999603271484,85.92999267578125,173.88400650024414,27.5]],"start":39,"text":"Redis的Lua脚本"}],"type":5,"uuid":"c6f8782cb333a12fc7a7bf9b59b0211e"},{"date":"2022-05-27 16:09:28","docid":0,"fillcolor":"ffffed99","id":85,"originaltext":"再次改进Redis的分布式锁","page":101,"textblocks":[{"first":[180.10000610351562,95.14399719238281,20.040008544921875,24.170013427734375],"last":[391.6800231933594,95.14399719238281,20.040008544921875,24.170013427734375],"length":14,"rects":[[180.10000610351562,95.14399719238281,231.62002563476562,24.170013427734375]],"start":41,"text":"再次改进Redis的分布式锁"}],"type":5,"uuid":"610a1a9356deac0c6911dd58ac91e8c4"},{"content":"还存在问题：\n1、不可重入：当一个线程调用一个方法获取锁的时候又去调用另一个方法，而另一个方法又要获取这个锁，这个时候直接就死锁\n\n2、不可重式：只拿了一次就不拿了\n\n3、超时释放\n\n4、主从一致性：读写分离","date":"2022-05-27 16:34:56","docid":0,"fillcolor":"ffffed99","id":86,"markups":[{"content":"直接Redis就可以解决锁的问题","date":"2022-05-27 16:46:45","docid":0,"fillcolor":"ffffed99","folded":true,"id":87,"markups":[{"content":"使用hash结构存储锁，实现思想跟ReentantLock的可重入锁是一样的，添加级数\n获取锁：首先判断锁是否已存在，不存在，直接创建锁并设置有效期，设置锁计数器为1；存在，就判断对应的field是否是当前线程，是的话直接计数器加一，继续执行，不是直接获取锁失败\n（两次判断，锁是否已存在，线程的id是否对应）\n\n释放锁：判断当前锁的线程field是否自己的，是，计数器减1，然后判断计数器是否为0，为0释放锁。不为0，重置有效期\n（两次判断，线程的id是否对应，计数器是否为0）\n","date":"2022-05-30 09:10:35","docid":0,"fillcolor":"ffffed99","id":88,"originaltext":"Redisson可重入锁原理","page":108,"textblocks":[{"first":[63.215999603271484,86.72999572753906,15.672000885009766,26.5],"last":[285.82000732421875,86.72999572753906,24,26.5],"length":14,"rects":[[63.215999603271484,86.72999572753906,246.60400772094727,26.5]],"start":39,"text":"Redisson可重入锁原理"}],"type":5,"uuid":"35807cbc10cee065cf179a8216e4416f"},{"content":"Redisson底层使用的都是以字符串形式写入的Lua脚本，来实现对应的获取锁和释放锁的操作","date":"2022-05-30 09:39:20","docid":0,"fillcolor":"ffffed99","id":89,"originaltext":"获取锁的Lua脚本","page":109,"textblocks":[{"first":[63.19200134277344,137.51998901367188,15.984001159667969,19.5],"last":[169.87001037597656,137.51998901367188,15.983993530273438,19.5],"length":9,"rects":[[63.19200134277344,137.51998901367188,122.66200256347656,19.5]],"start":708,"text":"获取锁的Lua脚本"}],"type":5,"uuid":"0a66b7f9ef03fdf5b8bb8c690edf3d80"},{"date":"2022-05-30 09:39:26","docid":0,"fillcolor":"ffffed99","id":90,"originaltext":"释放锁的Lua脚本","page":110,"textblocks":[{"first":[63.19200134277344,137.51998901367188,15.984001159667969,19.5],"last":[169.87001037597656,137.51998901367188,15.983993530273438,19.5],"length":9,"rects":[[63.19200134277344,137.51998901367188,122.66200256347656,19.5]],"start":641,"text":"释放锁的Lua脚本"}],"type":5,"uuid":"b1c26d7fba9bc0ca4ac21d88228966e2"},{"content":"锁默认的超时时间：30秒\n","date":"2022-05-30 09:51:20","docid":0,"fillcolor":"ffffed99","id":91,"originaltext":"Redisson分布式锁原理","page":111,"textblocks":[{"first":[63.215999603271484,85.92999267578125,15.672000885009766,27.5],"last":[285.82000732421875,85.92999267578125,24,27.5],"length":14,"rects":[[63.215999603271484,85.92999267578125,246.60400772094727,27.5]],"start":39,"text":"Redisson分布式锁原理"}],"type":5,"uuid":"4f182ddcd607af288e3fbaf8b81fe5ee"}],"originaltext":"Redisson","page":104,"textblocks":[{"first":[63.215999603271484,91.42999267578125,15.672000885009766,17.5],"last":[151.0560302734375,91.42999267578125,14.78399658203125,17.5],"length":8,"rects":[[63.215999603271484,91.42999267578125,102.62402725219727,17.5]],"start":39,"text":"Redisson"}],"type":5,"uuid":"534e52765cadef04f9b525d0195bfb3b"},{"content":"设置多台主节点的Redis\n对这些主节点的Redis设置从节点，只有这些主节点的都设置了对应的锁，才能判定这个线程拿到了锁\n\n这个叫做multiLock连锁","date":"2022-05-30 10:43:14","docid":0,"fillcolor":"ffffed99","id":92,"originaltext":"Redisson分布式锁主从一致性问题","page":113,"textblocks":[{"first":[63.215999603271484,85.92999267578125,15.672000885009766,27.5],"last":[405.82000732421875,85.92999267578125,24,27.5],"length":19,"rects":[[63.215999603271484,85.92999267578125,366.60400772094727,27.5]],"start":39,"text":"Redisson分布式锁主从一致性问题"}],"type":5,"uuid":"656b8e4b6dbced78b525b20fd649ddb6"}],"originaltext":"基于Redis的分布式锁优化","page":103,"textblocks":[{"first":[63.215999603271484,85.92999267578125,24.000003814697266,27.5],"last":[316.6600036621094,85.92999267578125,24,27.5],"length":14,"rects":[[63.215999603271484,85.92999267578125,277.4440040588379,27.5]],"start":39,"text":"基于Redis的分布式锁优化"}],"type":5,"uuid":"4d741492bc0aab98190458d9361cd770"}],"originaltext":"分布式锁","page":86,"textblocks":[{"first":[63.215999603271484,84.42999267578125,24.000003814697266,27.5],"last":[135.21600341796875,84.42999267578125,24,27.5],"length":4,"rects":[[63.215999603271484,84.42999267578125,96.00000381469727,27.5]],"start":39,"text":"分布式锁"}],"type":5,"uuid":"f06da57784bda4b238fdb6119ceb40a9"},{"content":"秒杀业务：\n\n这里是秒杀业务的前半部分：\n使用lua脚本判断一人一单以及扣除库存，然后根据返回值，是否使用用户id、订单id、优惠劵id创建订单，然后放入Reids实现的阻塞队列中\n（发消息也可以交给Lua脚本实现）\n（注意由于调用的方法是他，但是需要调用带有事务的方法会导致事务失效，需要在此获取代理对象）\n\n","date":"2022-05-30 11:13:15","docid":0,"fillcolor":"ffffed99","folded":false,"id":93,"markups":[{"content":"将判断秒杀库存和校验放到Redis中去做\n\n（一般不操作数据库的操作都可以放到Redis中去做，然后开启多一个线程去做剩下的步骤）","date":"2022-05-30 14:06:59","docid":0,"fillcolor":"ffffed99","id":95,"originaltext":"Redis优化秒杀","page":121,"textblocks":[{"first":[63.215999603271484,87.68998718261719,13.086124420166016,23.5],"last":[174.58001708984375,87.68998718261719,20.040008544921875,23.5],"length":9,"rects":[[63.215999603271484,87.68998718261719,131.40402603149414,23.5]],"start":54,"text":"Redis优化秒杀"}],"type":5,"uuid":"47d12c0795d7893b1b3d9b187cc22189"},{"content":"对于Redis中使用Lua脚本判断库存和一人一单：\n\n库存：使用String记录库存的数量\n\n一人一单：使用set，key记录优惠劵，value记录用户id","date":"2022-05-30 14:06:52","docid":0,"fillcolor":"ffffed99","id":94,"originaltext":"Lua脚本","page":122,"textblocks":[{"first":[248.9499969482422,189.80999755859375,10.814407348632812,20.5],"last":[299.3500061035156,189.80999755859375,18.02398681640625,20.5],"length":5,"rects":[[248.9499969482422,189.80999755859375,68.42399597167969,20.5]],"start":39,"text":"Lua脚本"}],"type":5,"uuid":"8a3a46a1e932bb21fb1ac4b6bae4b6fe"},{"date":"2022-05-30 14:09:36","docid":0,"fillcolor":"ffffed99","folded":true,"id":96,"markups":[{"content":"对于优惠劵的添加的时候也需要将优惠卷放到Redis，以便于之后对库存的判断","date":"2022-05-30 14:09:42","docid":0,"fillcolor":"ffffed99","id":97,"originaltext":"①","page":123,"textblocks":[{"first":[180.10000610351562,178.74002075195312,15.983993530273438,20.5],"last":[180.10000610351562,178.74002075195312,15.983993530273438,20.5],"length":1,"rects":[[180.10000610351562,178.74002075195312,15.983993530273438,20.5]],"start":59,"text":"①"}],"type":5,"uuid":"f40ed2cabd5fc85068c558fd6b0938e5"},{"content":"首先需要将Lua脚本文件导入，使用DefaultRedisScript<Long>放置到静态代码块中导入。然后使用Redis的模板调用excute方法就可一个调用对应脚本文件\n三个参数（对应脚本文件，key参数，其他参数）\n最后根据返回值判断对应的执行","date":"2022-05-30 14:09:43","docid":0,"fillcolor":"ffffed99","id":98,"originaltext":"②","page":123,"textblocks":[{"first":[180.10000610351562,212.30999755859375,15.960006713867188,18.5],"last":[180.10000610351562,212.30999755859375,15.960006713867188,18.5],"length":1,"rects":[[180.10000610351562,212.30999755859375,15.960006713867188,18.5]],"start":88,"text":"②"}],"type":5,"uuid":"ec3bf0c13c77b2635b95d6026ecda728"},{"content":"直接创建一个阻塞队列\n\nBlockingQueue：\n如果一个线程去取元素，没有元素的话，那个线程就会阻塞直接到队列有元素可以取出）","date":"2022-05-30 14:09:46","docid":0,"fillcolor":"ffffed99","id":99,"originaltext":"③","page":123,"textblocks":[{"first":[180.10000610351562,245.95001220703125,15.960006713867188,18.5],"last":[180.10000610351562,245.95001220703125,15.960006713867188,18.5],"length":1,"rects":[[180.10000610351562,245.95001220703125,15.960006713867188,18.5]],"start":121,"text":"③"}],"type":5,"uuid":"a0a3c42ed07cd8a4633932c5ccc9ad4a"},{"content":"线程池：\n直接创建对应的线程池即可\n线程任务：\n使用实现Runnable即可的类里面实现对应的run方法\n执行时机：\n只要优惠劵订单业务实现类被注入到spring中就可以调用，使用@PostConstruct","date":"2022-05-30 14:09:48","docid":0,"fillcolor":"ffffed99","id":100,"originaltext":"④","page":123,"textblocks":[{"first":[180.10000610351562,276.5899963378906,15.983993530273438,19.5],"last":[180.10000610351562,276.5899963378906,15.983993530273438,19.5],"length":1,"rects":[[180.10000610351562,276.5899963378906,15.983993530273438,19.5]],"start":151,"text":"④"}],"type":5,"uuid":"5a569d276dc6a7ffe9f006fb5302d275"}],"originaltext":"改进秒杀业务，提高并发性能","page":123,"textblocks":[{"first":[180.10000610351562,94.30999755859375,20.040008544921875,23.5],"last":[420.4598693847656,94.30999755859375,20.040008544921875,23.5],"length":13,"rects":[[180.10000610351562,94.30999755859375,260.3998718261719,23.5]],"start":41,"text":"改进秒杀业务，提高并发性能"}],"type":5,"uuid":"47eaae01f8c05741363c205a24e9a742"}],"originaltext":"Redis优化秒杀","page":119,"textblocks":[{"first":[63.215999603271484,87.68998718261719,13.086124420166016,23.5],"last":[174.58001708984375,87.68998718261719,20.040008544921875,23.5],"length":9,"rects":[[63.215999603271484,87.68998718261719,131.40402603149414,23.5]],"start":39,"text":"Redis优化秒杀"}],"type":5,"uuid":"1a691bc48bf69a9c8327974a836c6a52"},{"content":"秒杀业务的后半部分：\n从消息队列中获取对应信息，然后解析数据，然后执行加锁方法，其中调用加了事务的订单操作方法\n\n\n\n1、获取消息方法（顺便获取代理对象）\n2、执行加锁方法防止并发问题\n3、执行真正数据库操作","date":"2022-05-30 14:51:37","docid":0,"fillcolor":"ffffed99","folded":false,"id":101,"markups":[{"content":"包含生产者、消费者、消息队列","date":"2022-05-30 15:08:13","docid":0,"fillcolor":"ffffed99","id":103,"originaltext":"消息队列（Message Queue）","page":126,"textblocks":[{"first":[63.19200134277344,135.9199981689453,15.984001159667969,21.5],"last":[267.3399963378906,135.9199981689453,15.9840087890625,21.5],"length":19,"rects":[[63.19200134277344,135.9199981689453,220.1320037841797,21.5]],"start":39,"text":"消息队列（Message Queue）"}],"type":5,"uuid":"08d4c8318e7b4a45de6863d53863f7ff"},{"content":"使用三种方式实现消息队列：\n1、list结构\n2、","date":"2022-05-30 15:08:06","docid":0,"fillcolor":"ffffed99","folded":true,"id":102,"markups":[{"content":"简单实现","date":"2022-05-30 15:09:05","docid":0,"fillcolor":"ffffed99","id":104,"originaltext":"list结构","page":127,"textblocks":[{"first":[90.16799926757812,304.0267333984375,4.245361328125,19.8665771484375],"last":[127.97000122070312,304.0267333984375,15.960006713867188,19.8665771484375],"length":6,"rects":[[90.16799926757812,304.0267333984375,53.76200866699219,19.8665771484375]],"start":230,"text":"list结构"}],"type":5,"uuid":"bf2544ff5853c95379f5977ae076afe3"},{"content":"有一定基本","date":"2022-05-30 15:09:09","docid":0,"fillcolor":"ffffed99","id":105,"originaltext":"PubSub","page":127,"textblocks":[{"first":[90.16799926757812,337.46270751953125,9.782211303710938,18.871612548828125],"last":[139.01510620117188,337.46270751953125,10.213775634765625,18.871612548828125],"length":6,"rects":[[90.16799926757812,337.46270751953125,59.060882568359375,18.871612548828125]],"start":254,"text":"PubSub"}],"type":5,"uuid":"91eaace4c341316005cbfe340d53406e"},{"content":"完善的消息队列","date":"2022-05-30 15:09:13","docid":0,"fillcolor":"ffffed99","id":106,"originaltext":"Stream","page":127,"textblocks":[{"first":[90.16799926757812,369.3267517089844,9.20892333984375,19.8665771484375],"last":[128.5358428955078,369.3267517089844,14.954513549804688,19.8665771484375],"length":6,"rects":[[90.16799926757812,369.3267517089844,53.322357177734375,19.8665771484375]],"start":274,"text":"Stream"}],"type":5,"uuid":"cedd2c20d33c12d8acdb12759a4188e1"}],"originaltext":"Redis提供了三种不同的方式","page":127,"textblocks":[{"first":[63.167999267578125,271.67999267578125,10.421882629394531,19.5],"last":[247.61004638671875,271.67999267578125,15.959991455078125,19.5],"length":15,"rects":[[63.167999267578125,271.67999267578125,200.40203857421875,19.5]],"start":204,"text":"Redis提供了三种不同的方式"}],"type":5,"uuid":"6ec0bd47cd2c9637db835a854e3cb41f"},{"content":"list实现需要使用特定的阻塞命令BRPOP和BLPOP\n因为普通的取出，在没有消息的时候会直接返回null","date":"2022-05-30 15:09:45","docid":0,"fillcolor":"ffffed99","folded":true,"id":107,"markups":[{"date":"2022-05-30 15:20:55","docid":0,"fillcolor":"ffffed99","id":109,"originaltext":"基于List的消息队列有哪些优缺点","page":129,"textblocks":[{"first":[410.92999267578125,163,18.02398681640625,20.5],"last":[655.969970703125,163,18.02398681640625,20.5],"length":17,"rects":[[410.92999267578125,163,263.06396484375,20.5]],"start":44,"text":"基于List的消息队列有哪些优缺点"}],"type":5,"uuid":"805fe463cdc35c57e6d8ccb1d3a76a69"}],"originaltext":"基于List结构模拟消息队列","page":128,"textblocks":[{"first":[63.215999603271484,87.68998718261719,20.039997100830078,23.5],"last":[275.86004638671875,87.68998718261719,20.040008544921875,23.5],"length":14,"rects":[[63.215999603271484,87.68998718261719,232.68405532836914,23.5]],"start":254,"text":"基于List结构模拟消息队列"}],"type":5,"uuid":"061d18bd78770626ae431b570656a73e"},{"date":"2022-05-30 15:09:53","docid":0,"fillcolor":"ffffed99","folded":true,"id":108,"markups":[{"content":"天生就是阻塞式的","date":"2022-05-30 15:27:19","docid":0,"fillcolor":"ffffed99","folded":true,"id":111,"markups":[{"date":"2022-05-30 15:27:24","docid":0,"fillcolor":"ffffed99","id":112,"originaltext":"SUBSCRIBE channel [channel]","page":130,"textblocks":[{"first":[90.552001953125,198.97998046875,9.20892333984375,19.5],"last":[309.87432861328125,198.97998046875,5.33062744140625,19.5],"length":27,"rects":[[90.552001953125,198.97998046875,224.6529541015625,19.5]],"start":133,"text":"SUBSCRIBE channel [channel]"}],"type":5,"uuid":"a1f1da52cba5fd4829ced5f4449d9a71"},{"date":"2022-05-30 15:27:29","docid":0,"fillcolor":"ffffed99","id":113,"originaltext":"PUBLISH channel msg ","page":130,"textblocks":[{"first":[90.552001953125,230.02000427246094,9.782211303710938,21.5],"last":[258.863525390625,230.02000427246094,4.73126220703125,21.5],"length":20,"rects":[[90.552001953125,230.02000427246094,173.04278564453125,21.5]],"start":173,"text":"PUBLISH channel msg "}],"type":5,"uuid":"9a13f5c7b34721d5b293111b05c5c81b"},{"content":"通配符\n？：代表一个字符\n*：一个或者多个字符\n[]：中括号包围的一个字符","date":"2022-05-30 15:27:33","docid":0,"fillcolor":"ffffed99","id":114,"originaltext":"PSUBSCRIBE pattern[pattern]","page":130,"textblocks":[{"first":[90.552001953125,263.4900207519531,9.76751708984375,20.5],"last":[306.8100280761719,263.4900207519531,5.33062744140625,20.5],"length":27,"rects":[[90.552001953125,263.4900207519531,221.58865356445312,20.5]],"start":205,"text":"PSUBSCRIBE pattern[pattern]"}],"type":5,"uuid":"e5b90364e5cec5c1ef59865154c22e68"}],"originaltext":"PubSub（发布订阅）","page":130,"textblocks":[{"first":[63.19200134277344,137.51998901367188,10.501487731933594,19.5],"last":[205.030029296875,137.51998901367188,15.983993530273438,19.5],"length":12,"rects":[[63.19200134277344,137.51998901367188,157.822021484375,19.5]],"start":39,"text":"PubSub（发布订阅）"}],"type":5,"uuid":"2a49047619c64fed0dfbf0b17283852d"},{"date":"2022-05-30 15:31:57","docid":0,"fillcolor":"ffffed99","id":115,"originaltext":"基于PubSub的消息队列有哪些优缺点","page":131,"textblocks":[{"first":[410.92999267578125,177.61000061035156,18,21.5],"last":[693.530029296875,177.61000061035156,18,21.5],"length":19,"rects":[[410.92999267578125,177.61000061035156,300.60003662109375,21.5]],"start":44,"text":"基于PubSub的消息队列有哪些优缺点"}],"type":5,"uuid":"e96e1e539d953ce94a8401d4895df575"}],"originaltext":"基于PubSub的消息队列","page":130,"textblocks":[{"first":[63.215999603271484,87.68998718261719,20.039997100830078,23.5],"last":[257.6200256347656,87.68998718261719,20.040008544921875,23.5],"length":13,"rects":[[63.215999603271484,87.68998718261719,214.44403457641602,23.5]],"start":254,"text":"基于PubSub的消息队列"}],"type":5,"uuid":"c5e657f3e207919807c81293db6f7677"},{"content":"专门用于消息队列是一种新的数据类型","date":"2022-05-30 15:24:54","docid":0,"fillcolor":"ffffed99","folded":true,"id":110,"markups":[{"date":"2022-05-30 15:33:22","docid":0,"fillcolor":"ffffed99","id":116,"originaltext":"一种新数据类型","page":132,"textblocks":[{"first":[259.6300048828125,137.51998901367188,15.9840087890625,19.5],"last":[355.38995361328125,137.51998901367188,15.9840087890625,19.5],"length":7,"rects":[[259.6300048828125,137.51998901367188,111.74395751953125,19.5]],"start":61,"text":"一种新数据类型"}],"type":5,"uuid":"060319d9c843666b17c76a120d3dea0c"},{"content":"设置对应队列名称、队列最大值\n然后后面都是key-value消息\n\n会返回对应的id","date":"2022-05-30 15:34:52","docid":0,"fillcolor":"ffffed99","id":118,"originaltext":"发送消息的命令","page":132,"textblocks":[{"first":[63.19200134277344,170.27999877929688,15.959999084472656,18.5],"last":[158.95201110839844,170.27999877929688,15.960006713867188,18.5],"length":7,"rects":[[63.19200134277344,170.27999877929688,111.72001647949219,18.5]],"start":88,"text":"发送消息的命令"}],"type":5,"uuid":"b489db992cb558456e5878858121aed6"},{"content":"使用xread\n\n一次读多少\n没有的时候是否阻塞\n哪个队列读\n是否从最新的开始读","date":"2022-05-30 15:35:19","docid":0,"fillcolor":"ffffed99","folded":true,"id":119,"markups":[{"content":"会出现漏读的现象","date":"2022-05-30 15:45:57","docid":0,"fillcolor":"ffffed99","id":120,"originaltext":"XREAD阻塞方式，读取最新的消息","page":134,"textblocks":[{"first":[63.19200134277344,137.51998901367188,10.309677124023438,19.5],"last":[291.7900390625,137.51998901367188,15.9840087890625,19.5],"length":17,"rects":[[63.19200134277344,137.51998901367188,244.58204650878906,19.5]],"start":39,"text":"XREAD阻塞方式，读取最新的消息"}],"type":5,"uuid":"5bcd0fb23722f3f98f69709cd6ca91f1"}],"originaltext":"读取消息的方式之一：XREAD","page":133,"textblocks":[{"first":[63.19200134277344,137.51998901367188,15.984001159667969,19.5],"last":[263.75701904296875,137.51998901367188,12.1798095703125,19.5],"length":15,"rects":[[63.19200134277344,137.51998901367188,212.7448272705078,19.5]],"start":39,"text":"读取消息的方式之一：XREAD"}],"type":5,"uuid":"f1c80a350cdb57394b1eb468284e799d"}],"originaltext":"基于Stream的消息队列","page":132,"textblocks":[{"first":[63.215999603271484,87.68998718261719,20.039997100830078,23.5],"last":[250.30001831054688,87.68998718261719,20.040008544921875,23.5],"length":13,"rects":[[63.215999603271484,87.68998718261719,207.12402725219727,23.5]],"start":101,"text":"基于Stream的消息队列"}],"type":5,"uuid":"0830326702a7694ad147e4635841ceec"},{"date":"2022-05-30 15:46:21","docid":0,"fillcolor":"ffffed99","folded":true,"id":121,"markups":[{"date":"2022-05-30 15:47:24","docid":0,"fillcolor":"ffffed99","id":122,"markups":[{"content":"队列名称\n组名称\n从哪里开始读取\n如果没有队列是否创建","date":"2022-05-30 15:47:35","docid":0,"fillcolor":"ffffed99","id":123,"originaltext":"创建消费者组","page":137,"textblocks":[{"first":[63.19200134277344,137.51998901367188,15.984001159667969,19.5],"last":[142.99200439453125,137.51998901367188,15.983993530273438,19.5],"length":6,"rects":[[63.19200134277344,137.51998901367188,95.78399658203125,19.5]],"start":58,"text":"创建消费者组"}],"type":5,"uuid":"ec7d772d43c28e35f5435eacedf2b1bf"},{"content":"组名称\n消费者名称\n查询多少个消息\n阻塞时间\n是否自动应答\n队列名称\n获取的消息起始id\n\n\n\nxack 队列名 组名 消息id","date":"2022-05-30 15:47:41","docid":0,"fillcolor":"ffffed99","id":124,"originaltext":"从消费者组读取消息","page":138,"textblocks":[{"first":[63.19200134277344,136.6199951171875,15.984001159667969,18.5],"last":[190.8720245361328,136.6199951171875,15.983993530273438,18.5],"length":9,"rects":[[63.19200134277344,136.6199951171875,143.6640167236328,18.5]],"start":58,"text":"从消费者组读取消息"}],"type":5,"uuid":"2f5917e54fde4b170b8222bd0bde2aa7"}],"originaltext":"消费者组（Consumer Group）","page":136,"textblocks":[{"first":[63.19200134277344,136.72000122070312,15.984001159667969,20.5],"last":[280.05999755859375,136.72000122070312,15.9840087890625,20.5],"length":20,"rects":[[63.19200134277344,136.72000122070312,232.8520050048828,20.5]],"start":39,"text":"消费者组（Consumer Group）"}],"type":5,"uuid":"4e53505ca901a44b033ea28a73b2e128"}],"originaltext":"基于Stream的消息队列-消费者组","page":136,"textblocks":[{"first":[63.215999603271484,87.68998718261719,20.039997100830078,23.5],"last":[338.9997863769531,87.68998718261719,20.040008544921875,23.5],"length":18,"rects":[[63.215999603271484,87.68998718261719,295.8237953186035,23.5]],"start":90,"text":"基于Stream的消息队列-消费者组"}],"type":5,"uuid":"d49cc53033b3483fac89fbafee5c0d79"},{"date":"2022-05-30 16:30:57","docid":0,"fillcolor":"ffffed99","folded":true,"id":125,"markups":[{"content":"创建一个消息组，直接创建\n（因为创建组有命令如果队列不存在会自动创建）\n参数：\n队列名、组名、队列中消息从哪开始读取、是否自动创建","date":"2022-05-30 16:31:14","docid":0,"fillcolor":"ffffed99","id":126,"originaltext":"①","page":142,"textblocks":[{"first":[180.10000610351562,178.74002075195312,15.983993530273438,20.5],"last":[180.10000610351562,178.74002075195312,15.983993530273438,20.5],"length":1,"rects":[[180.10000610351562,178.74002075195312,15.983993530273438,20.5]],"start":77,"text":"①"}],"type":5,"uuid":"630c363330a6380f19111e3c650e3409"},{"content":"在lua脚本中，发送消息直接发送到Redis中，附带上订单id即可\n","date":"2022-05-30 16:31:16","docid":0,"fillcolor":"ffffed99","id":127,"originaltext":"②","page":142,"textblocks":[{"first":[180.10000610351562,212.30999755859375,15.960006713867188,18.5],"last":[180.10000610351562,212.30999755859375,15.960006713867188,18.5],"length":1,"rects":[[180.10000610351562,212.30999755859375,15.960006713867188,18.5]],"start":113,"text":"②"}],"type":5,"uuid":"d5133f37d072593dbba4ae3ede34a5f9"},{"content":"项目启动直接去阻塞队列中获取消息即可，完成需要ack确认","date":"2022-05-30 16:31:18","docid":0,"fillcolor":"ffffed99","id":128,"originaltext":"③","page":142,"textblocks":[{"first":[180.10000610351562,272.8500061035156,15.983993530273438,20.5],"last":[180.10000610351562,272.8500061035156,15.983993530273438,20.5],"length":1,"rects":[[180.10000610351562,272.8500061035156,15.983993530273438,20.5]],"start":192,"text":"③"}],"type":5,"uuid":"bf13e170b691b18cdea873bd467f1ed1"}],"originaltext":"基于Redis的Stream结构作为消息队列，实现异步秒杀下单","page":142,"textblocks":[{"first":[180.10000610351562,95.14399719238281,20.040008544921875,24.170013427734375],"last":[678.3587036132812,95.14399719238281,20.03997802734375,24.170013427734375],"length":31,"rects":[[180.10000610351562,95.14399719238281,518.2986755371094,24.170013427734375]],"start":41,"text":"基于Redis的Stream结构作为消息队列，实现异步秒杀下单"}],"type":5,"uuid":"52564c42cc6466cced15f4e15bc1659b"}],"originaltext":"Redis消息队列实现异步秒杀","page":126,"textblocks":[{"first":[63.215999603271484,87.68998718261719,13.086124420166016,23.5],"last":[294.6998291015625,87.68998718261719,20.040008544921875,23.5],"length":15,"rects":[[63.215999603271484,87.68998718261719,251.5238380432129,23.5]],"start":168,"text":"Redis消息队列实现异步秒杀"}],"type":5,"uuid":"d26d2cc18f8f41c78cde699c70e281b6"},{"date":"2022-05-31 14:30:20","docid":0,"fillcolor":"ffffed99","folded":false,"id":131,"markups":[{"content":"直接查询信息\n实体类中放入用户信息即可","date":"2022-05-31 15:36:06","docid":0,"fillcolor":"ffffed99","id":132,"originaltext":"发布探店笔记","page":145,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,23.5],"last":[163.416015625,86.989990234375,20.040008544921875,23.5],"length":6,"rects":[[63.215999603271484,86.989990234375,120.24002456665039,23.5]],"start":39,"text":"发布探店笔记"}],"type":5,"uuid":"170d3b357f709dddb18a71303357b456"},{"date":"2022-05-31 15:42:46","docid":0,"fillcolor":"ffffed99","folded":false,"id":133,"markups":[{"content":"跟一人一单一个同一个道理Redis使用set集合\n\n先到set中去判断是否存在\n\n推荐使用lua脚本，比较并替换，一般来说只要遇到比较然后设置值的都会出现并发问题\n\n如果存在，先操作数据库点赞数-1，然后将set集合中对应的用户id去除\n\n设置不存在，去数据库将其点赞数+1，（这里一定要判断数据库是否操作成功）然后将用户id添加到set集合中\n\n\n（由于需要排序所以之后的改造用户ID需要放到sorted_set中，对于是否点点赞就直接查询对应的分数是否存在，不存在就是没有点赞）","date":"2022-05-31 15:45:26","docid":0,"fillcolor":"ffffed99","id":136,"originaltext":"完善点赞功能","page":150,"textblocks":[{"first":[180.10000610351562,94.30999755859375,20.040008544921875,23.5],"last":[280.300048828125,94.30999755859375,20.040008544921875,23.5],"length":6,"rects":[[180.10000610351562,94.30999755859375,120.24005126953125,23.5]],"start":41,"text":"完善点赞功能"}],"type":5,"uuid":"6369f532022d3b188dc7f4d714806c72"}],"originaltext":"点赞","page":149,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,22.5],"last":[83.25599670410156,86.989990234375,20.040000915527344,22.5],"length":2,"rects":[[63.215999603271484,86.989990234375,40.07999801635742,22.5]],"start":39,"text":"点赞"}],"type":5,"uuid":"822870f09f2ec212732d0b0315f289f1"},{"content":"使用sorted_set\n根据键返回分数，没有分数就表示不存在\n\n最后获取排名直接查排名，根据用户id去数据库中查询对应信息。","date":"2022-05-31 15:42:52","docid":0,"fillcolor":"ffffed99","id":134,"originaltext":"点赞排行榜","page":152,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,23.5],"last":[143.37600708007812,86.989990234375,20.040008544921875,23.5],"length":5,"rects":[[63.215999603271484,86.989990234375,100.20001602172852,23.5]],"start":39,"text":"点赞排行榜"}],"type":5,"uuid":"1c5ea916509c8612a6b756a6507cbeb1"}],"originaltext":"达人探店","page":143,"textblocks":[{"first":[423.8399963378906,220.16000366210938,32.063995361328125,33.5],"last":[520.031982421875,220.16000366210938,32.06402587890625,33.5],"length":4,"rects":[[423.8399963378906,220.16000366210938,128.25601196289062,33.5]],"start":0,"text":"达人探店"}],"type":5,"uuid":"4c88c8640060fed60ecbdb40b5a29059"},{"date":"2022-05-31 15:43:02","docid":0,"fillcolor":"ffffed99","folded":false,"id":135,"markups":[{"date":"2022-05-31 16:32:17","docid":0,"fillcolor":"ffffed99","folded":true,"id":137,"markups":[{"content":"多对多只能使用中间表\n\n\n因为接下来需要使用到共同关注的功能所以对于关注一个用户都需要保存到Redis中\n\n使用当前登录用户作为key，关注的人的用户id作为value放到redis中","date":"2022-05-31 16:32:30","docid":0,"fillcolor":"ffffed99","id":138,"originaltext":"实现关注和取关功能","page":157,"textblocks":[{"first":[180.10000610351562,95.30999755859375,20.040008544921875,22.5],"last":[340.4200744628906,95.30999755859375,20.040008544921875,22.5],"length":9,"rects":[[180.10000610351562,95.30999755859375,180.36007690429688,22.5]],"start":41,"text":"实现关注和取关功能"}],"type":5,"uuid":"202a2038c8e0113a048793fd8eca348a"}],"originaltext":"关注和取关","page":156,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,22.5],"last":[143.37600708007812,86.989990234375,20.040008544921875,22.5],"length":5,"rects":[[63.215999603271484,86.989990234375,100.20001602172852,22.5]],"start":39,"text":"关注和取关"}],"type":5,"uuid":"7410c64cbce7d84d6cd28fdcbd88833d"},{"content":"使用set的inter方法求交集即可\n","date":"2022-05-31 16:32:35","docid":0,"fillcolor":"ffffed99","id":139,"originaltext":"共同关注","page":159,"textblocks":[{"first":[63.215999603271484,87.989990234375,20.039997100830078,21.5],"last":[123.33599853515625,87.989990234375,20.040008544921875,21.5],"length":4,"rects":[[63.215999603271484,87.989990234375,80.16000747680664,21.5]],"start":39,"text":"共同关注"}],"type":5,"uuid":"36a1b52e64ccc231b6a114ddb13083be"},{"content":"无限下拉刷新","date":"2022-05-31 16:32:58","docid":0,"fillcolor":"ffffed99","folded":true,"id":141,"markups":[{"date":"2022-05-31 17:21:02","docid":0,"fillcolor":"ffffed99","folded":true,"id":143,"markups":[{"content":"不做内容筛选，直接排序，朋友圈就是一个TimeLine的Feed流","date":"2022-05-31 17:21:08","docid":0,"fillcolor":"ffffed99","id":144,"originaltext":"Timeline","page":164,"textblocks":[{"first":[85.75199890136719,170.27999877929688,9.974998474121094,18.5],"last":[145.0434112548828,170.27999877929688,9.288726806640625,18.5],"length":8,"rects":[[85.75199890136719,170.27999877929688,68.58013916015625,18.5]],"start":66,"text":"Timeline"}],"type":5,"uuid":"fefbfac11dbaa0b7a17215acfb3bba6a"},{"content":"对内容做筛选，只推送用户感兴趣的内容","date":"2022-05-31 17:21:09","docid":0,"fillcolor":"ffffed99","id":145,"originaltext":"智能排序","page":164,"textblocks":[{"first":[85.75199890136719,268.2300109863281,15.959999084472656,18.5],"last":[133.6320037841797,268.2300109863281,15.960006713867188,18.5],"length":4,"rects":[[85.75199890136719,268.2300109863281,63.84001159667969,18.5]],"start":168,"text":"智能排序"}],"type":5,"uuid":"1ff7448f46fd5b71f38008350091e696"}],"originaltext":"Feed流的模式","page":164,"textblocks":[{"first":[63.215999603271484,87.68998718261719,10.641239166259766,23.5],"last":[169.66000366210938,87.68998718261719,20.040008544921875,23.5],"length":8,"rects":[[63.215999603271484,87.68998718261719,126.48401260375977,23.5]],"start":39,"text":"Feed流的模式"}],"type":5,"uuid":"220f0e2b7dae75885f3d6edf31eebe67"},{"date":"2022-05-31 17:21:56","docid":0,"fillcolor":"ffffed99","folded":true,"id":146,"markups":[{"content":"被关注的人：\n有属于自己的发件箱，发送的消息都会到发件箱中\n\n关注的人：\n有属于自己的收件箱，平时是空的，只有取读取收件箱的时候才会，去找关注的人拉取消息，读取完后清空收件箱\n\n缺陷：如果关注的人很多的话，那么一拉取收件箱就直接爆了","date":"2022-05-31 17:22:03","docid":0,"fillcolor":"ffffed99","id":147,"originaltext":"拉模式","page":165,"textblocks":[{"first":[63.19200134277344,136.6199951171875,15.984001159667969,19.5],"last":[95.11199951171875,136.6199951171875,15.984001159667969,19.5],"length":3,"rects":[[63.19200134277344,136.6199951171875,47.90399932861328,19.5]],"start":51,"text":"拉模式"}],"type":5,"uuid":"f61315b219f09d950a56533f1dec20c5"},{"content":"被关注的人没有发件箱，\n当发送消息的时候直接将消息发送到粉丝的收件箱中\n\n缺陷：由于一份消息被发出几份，较高的重复数据","date":"2022-05-31 17:22:09","docid":0,"fillcolor":"ffffed99","id":148,"originaltext":"推模式","page":166,"textblocks":[{"first":[63.19200134277344,136.6199951171875,15.984001159667969,19.5],"last":[95.11199951171875,136.6199951171875,15.984001159667969,19.5],"length":3,"rects":[[63.19200134277344,136.6199951171875,47.90399932861328,19.5]],"start":51,"text":"推模式"}],"type":5,"uuid":"a8911068020501bae01b3bc157e09aa1"},{"content":"对于粉丝少：\n直接使用推模式\n\n对于大V关注他的人很多：\n活跃粉丝使用推模式，对于僵尸粉使用拉模式、\n\n\n总结：\n\n对于普通粉丝和或者粉丝少的人使用拉模式\n\n对于大V使用推模式","date":"2022-05-31 17:22:14","docid":0,"fillcolor":"ffffed99","id":149,"originaltext":"推拉结合模式","page":167,"textblocks":[{"first":[63.19200134277344,136.6199951171875,15.984001159667969,19.5],"last":[142.99200439453125,136.6199951171875,15.983993530273438,19.5],"length":6,"rects":[[63.19200134277344,136.6199951171875,95.78399658203125,19.5]],"start":51,"text":"推拉结合模式"}],"type":5,"uuid":"00a6534857bf5b11152c17b13434d7bb"}],"originaltext":"Timeline的模式","page":164,"textblocks":[{"first":[499.67999267578125,366.16998291015625,9.14508056640625,18.5],"last":[596.6400146484375,366.16998291015625,15.96002197265625,18.5],"length":11,"rects":[[499.67999267578125,366.16998291015625,112.9200439453125,18.5]],"start":288,"text":"Timeline的模式"}],"type":5,"uuid":"aeda2097098eaacc5710d1bfc4db0a65"},{"date":"2022-05-31 17:29:10","docid":0,"fillcolor":"ffffed99","id":150,"originaltext":"Feed流的实现方案","page":168,"textblocks":[{"first":[63.215999603271484,87.68998718261719,10.641239166259766,23.5],"last":[209.74002075195312,87.68998718261719,20.040008544921875,23.5],"length":10,"rects":[[63.215999603271484,87.68998718261719,166.56402969360352,23.5]],"start":39,"text":"Feed流的实现方案"}],"type":5,"uuid":"0e04cb44f7263befe47f26e5c3392ad0"},{"content":"使用Redis作为收件箱\n\n两种结构都可以进行排序\nlist有下标\nsorted_set可以使用排名\n\n由于需要滚动分页的问题：只能使用soted_set进行排序","date":"2022-05-31 17:29:17","docid":0,"fillcolor":"ffffed99","folded":true,"id":151,"markups":[{"content":"因为不断加入新的数据，角标会被带动，所以传统分页模式不适用\n\n因为读取的顺序是从最后面到前面逆序读取，只要有新添加的数据那么角标就会被带动，出现分页问题\n\n因为按时间排名最近的排在最后，所以需要逆序获取，按角标获取信息的话，会被新加入的信息打乱角标","date":"2022-06-01 09:48:55","docid":0,"fillcolor":"ffffed99","id":152,"originaltext":"Feed流的分页问题","page":170,"textblocks":[{"first":[63.215999603271484,87.68998718261719,10.641239166259766,23.5],"last":[209.74002075195312,87.68998718261719,20.040008544921875,23.5],"length":10,"rects":[[63.215999603271484,87.68998718261719,166.56402969360352,23.5]],"start":60,"text":"Feed流的分页问题"}],"type":5,"uuid":"3b53968c796d56d44d35bf5d69463a00"},{"content":"sorted_set按score值进行查询\n\n每一次查询只要记住最后的一个score值即可","date":"2022-06-01 09:52:10","docid":0,"fillcolor":"ffffed99","id":153,"originaltext":"Feed流的滚动分页","page":173,"textblocks":[{"first":[63.215999603271484,87.68998718261719,10.641239166259766,23.5],"last":[209.74002075195312,87.68998718261719,20.040008544921875,23.5],"length":10,"rects":[[63.215999603271484,87.68998718261719,166.56402969360352,23.5]],"start":60,"text":"Feed流的滚动分页"}],"type":5,"uuid":"f89e7868f7c0fa4c0df38e725589fb90"}],"originaltext":"基于推模式实现关注推送功能","page":169,"textblocks":[{"first":[180.10000610351562,94.30999755859375,20.040008544921875,23.5],"last":[420.4598693847656,94.30999755859375,20.040008544921875,23.5],"length":13,"rects":[[180.10000610351562,94.30999755859375,260.3998718261719,23.5]],"start":41,"text":"基于推模式实现关注推送功能"}],"type":5,"uuid":"1d5b4c6ca3930fd39d046436b5e4acec"},{"content":"使用Redis做邮箱\n推送：\n从关注表中找到所有的粉丝\n然后在Redis中创建\n用粉丝id做key，将笔记的id作为value，将时间作为score\n放到sorted_set中\n这样就全部以Reids推送出去了（所以以Redis中id作为key，value作为邮箱）\n使用sorted_set查询的参数\n最大值：一般使用当前时间\n最小值：最小的时间\nlimit后接 \n从最大值之后的第几个开始\n展示多少个\n第一次查询的时候时间戳设置为当下，最后的limit要设置为从0开始\n第二次查询的时候时间戳设置为上一次最后的时间，最后的limit设置从1开始，不包括0也就是自己\n\n如果两个一样的sore值怎么样？\nmax:时间戳 | 或者上一次最小的score值\nmin：0\noffset：一般从0|如果最小的score值有相同的，这是是相同的值的个数","date":"2022-06-01 11:14:10","docid":0,"fillcolor":"ffffed99","id":154,"originaltext":"实现关注推送页面的分页查询","page":176,"textblocks":[{"first":[180.10000610351562,95.30999755859375,20.040008544921875,22.5],"last":[420.4598693847656,95.30999755859375,20.040008544921875,22.5],"length":13,"rects":[[180.10000610351562,95.30999755859375,260.3998718261719,22.5]],"start":41,"text":"实现关注推送页面的分页查询"}],"type":5,"uuid":"be84cfbcb642655b13ca147ce708b6ac"}],"originaltext":"关注推送","page":163,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,22.5],"last":[123.33599853515625,86.989990234375,20.040008544921875,22.5],"length":4,"rects":[[63.215999603271484,86.989990234375,80.16000747680664,22.5]],"start":45,"text":"关注推送"}],"type":5,"uuid":"97c4dab7100366cb3fd812db42ecc1fe"}],"originaltext":"好友关注","page":154,"textblocks":[{"first":[423.8399963378906,219.16000366210938,32.063995361328125,34.5],"last":[520.031982421875,219.16000366210938,32.06402587890625,34.5],"length":4,"rects":[[423.8399963378906,219.16000366210938,128.25601196289062,34.5]],"start":0,"text":"好友关注"}],"type":5,"uuid":"34c01f280009555638c09bb929c559a0"},{"date":"2022-05-31 16:33:16","docid":0,"fillcolor":"ffffed99","folded":false,"id":142,"markups":[{"date":"2022-06-01 15:15:30","docid":0,"fillcolor":"ffffed99","id":155,"markups":[{"date":"2022-06-01 15:26:35","docid":0,"fillcolor":"ffffed99","id":156,"originaltext":"练习Redis的GEO功能","page":180,"textblocks":[{"first":[180.10000610351562,95.14399719238281,20.040008544921875,24.170013427734375],"last":[353.760009765625,95.14399719238281,20.040008544921875,24.170013427734375],"length":13,"rects":[[180.10000610351562,95.14399719238281,193.70001220703125,24.170013427734375]],"start":41,"text":"练习Redis的GEO功能"}],"type":5,"uuid":"53b3300cad81f04d984f0dd43508b4da"}],"originaltext":"GEO数据结构","page":179,"textblocks":[{"first":[63.215999603271484,86.989990234375,14.90976333618164,23.5],"last":[165.58001708984375,86.989990234375,20.040008544921875,23.5],"length":7,"rects":[[63.215999603271484,86.989990234375,122.40402603149414,23.5]],"start":39,"text":"GEO数据结构"}],"type":5,"uuid":"950843448ebb365b4d14985af588a54c"},{"content":"key来做分组，直接存储经纬度，主键当memeber\n\n存储后，直接从Redis获取对应id的商铺信息，解析对应出对应的商铺id，直接进入数据库查询","date":"2022-06-01 15:26:52","docid":0,"fillcolor":"ffffed99","id":157,"originaltext":"附近商户搜索","page":183,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,23.5],"last":[163.416015625,86.989990234375,20.040008544921875,23.5],"length":6,"rects":[[63.215999603271484,86.989990234375,120.24002456665039,23.5]],"start":39,"text":"附近商户搜索"}],"type":5,"uuid":"77aebbed136fe105a01c630ab997eca3"}],"originaltext":"附近商户","page":177,"textblocks":[{"first":[423.8399963378906,219.16000366210938,32.063995361328125,34.5],"last":[520.031982421875,219.16000366210938,32.06402587890625,34.5],"length":4,"rects":[[423.8399963378906,219.16000366210938,128.25601196289062,34.5]],"start":0,"text":"附近商户"}],"type":5,"uuid":"8335f73bfcd9ecf879f65975cf877e52"},{"date":"2022-06-01 15:27:19","docid":0,"fillcolor":"ffffed99","folded":true,"id":158,"markups":[{"content":"使用签到卡的形式做签到","date":"2022-06-01 15:27:26","docid":0,"fillcolor":"ffffed99","folded":true,"id":159,"markups":[{"date":"2022-06-01 16:44:28","docid":0,"fillcolor":"ffffed99","id":163,"originaltext":"位图","page":189,"textblocks":[{"first":[708.239990234375,374.3599853515625,15.9840087890625,18.5],"last":[724.2000122070312,374.3599853515625,15.9840087890625,18.5],"length":2,"rects":[[708.239990234375,374.3599853515625,31.94403076171875,18.5]],"start":203,"text":"位图"}],"type":5,"uuid":"fb39d4bde6a97d62f2981b6550b3b57a"},{"content":"核心思想：\n将一个位与某种业务状态进行映射\n\n将一串二进制位也就是01构成的数字与业务构成映射，最长可以达到512M\n\n\n注意：\n1、一般签到将年月作为key\n2、对于BitMap的操作全部放到String类型的操作中去了\n3、分配内存的时候是一个字节一个字节分配的，如果满了又会分一个字节","date":"2022-06-01 16:44:42","docid":0,"fillcolor":"ffffed99","id":164,"originaltext":"BitMap","page":190,"textblocks":[{"first":[340.20001220703125,123.03001403808594,10.342071533203125,21.5],"last":[387.5213928222656,123.03001403808594,9.783477783203125,21.5],"length":6,"rects":[[340.20001220703125,123.03001403808594,57.1048583984375,21.5]],"start":71,"text":"BitMap"}],"type":5,"uuid":"3c7542eaf41b8fd5d05c09199948d172"}],"originaltext":"BitMap用法","page":187,"textblocks":[{"first":[63.215999603271484,86.0899887084961,12.565082550048828,25.5],"last":[152.01998901367188,86.0899887084961,20.040008544921875,25.5],"length":8,"rects":[[63.215999603271484,86.0899887084961,108.84399795532227,25.5]],"start":39,"text":"BitMap用法"}],"type":5,"uuid":"4a051709c019e78c74e4b3b68b585f4d"},{"date":"2022-06-01 15:27:40","docid":0,"fillcolor":"ffffed99","id":160,"originaltext":"签到功能","page":192,"textblocks":[{"first":[192.88999938964844,95.44000244140625,20.063995361328125,22.5],"last":[253.00997924804688,95.44000244140625,20.063995361328125,22.5],"length":4,"rects":[[192.88999938964844,95.44000244140625,80.18397521972656,22.5]],"start":159,"text":"签到功能"}],"type":5,"uuid":"998a83baff901d8a0b0dd57e0572f4ea"},{"content":"直接拿到对应找个月到当下的签到情况\n获得的数据进行和1进行与运算\n返回的是1就将计数器+1，如果为0，直接返回技术器即可\n\n这样就可以获得最近连续签到次数","date":"2022-06-01 15:27:46","docid":0,"fillcolor":"ffffed99","folded":true,"id":161,"markups":[{"date":"2022-06-01 17:03:11","docid":0,"fillcolor":"ffffed99","id":165,"originaltext":"问题1：什么叫做连续签到天数？","page":194,"textblocks":[{"first":[63.19200134277344,137.6199951171875,15.984001159667969,18.5],"last":[279.7900390625,137.6199951171875,15.9840087890625,18.5],"length":15,"rects":[[63.19200134277344,137.6199951171875,232.58204650878906,18.5]],"start":44,"text":"问题1：什么叫做连续签到天数？"}],"type":5,"uuid":"cbe158de30df9be81c1e054e665a8c4c"},{"date":"2022-06-01 17:03:17","docid":0,"fillcolor":"ffffed99","id":166,"originaltext":"问题2：如何得到本月到今天为止的所有签到数据？","page":194,"textblocks":[{"first":[63.19200134277344,268.2300109863281,15.959999084472656,18.5],"last":[407.69342041015625,268.2300109863281,15.959991455078125,18.5],"length":23,"rects":[[63.19200134277344,268.2300109863281,360.46141052246094,18.5]],"start":106,"text":"问题2：如何得到本月到今天为止的所有签到数据？"}],"type":5,"uuid":"1b2f9f51fb9b5367edd97173de8b44b3"},{"date":"2022-06-01 17:03:21","docid":0,"fillcolor":"ffffed99","id":167,"originaltext":"问题3：如何从后向前遍历每个bit位？","page":194,"textblocks":[{"first":[63.19200134277344,366.16998291015625,15.959999084472656,18.5],"last":[315.3399963378906,366.16998291015625,15.959991455078125,18.5],"length":19,"rects":[[63.19200134277344,366.16998291015625,268.1079864501953,18.5]],"start":163,"text":"问题3：如何从后向前遍历每个bit位？"}],"type":5,"uuid":"d87bfb1b1a4fa07f1ea5b9b2d335d7ec"}],"originaltext":"签到统计","page":194,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,22.5],"last":[123.33599853515625,86.989990234375,20.040008544921875,22.5],"length":4,"rects":[[63.215999603271484,86.989990234375,80.16000747680664,22.5]],"start":39,"text":"签到统计"}],"type":5,"uuid":"c868cb86342ff911a6cd827da7a14c4c"}],"originaltext":"用户签到","page":185,"textblocks":[{"first":[423.8399963378906,221.16000366210938,32.063995361328125,33.5],"last":[520.031982421875,221.16000366210938,32.06402587890625,33.5],"length":4,"rects":[[423.8399963378906,221.16000366210938,128.25601196289062,33.5]],"start":0,"text":"用户签到"}],"type":5,"uuid":"bbcf01d3be855764d93772e534bc4272"},{"date":"2022-06-01 15:27:54","docid":0,"fillcolor":"ffffed99","folded":false,"id":162,"markups":[{"date":"2022-06-01 17:22:20","docid":0,"fillcolor":"ffffed99","folded":false,"id":168,"markups":[{"content":"独立访问量：指一个网页的访问量，如果一个用户一天内多次点击只计算一次","date":"2022-06-01 17:23:33","docid":0,"fillcolor":"ffffed99","id":170,"originaltext":"UV","page":198,"textblocks":[{"first":[85.75199890136719,169.3800048828125,12.384963989257812,20.5],"last":[98.1119613647461,169.3800048828125,11.411399841308594,20.5],"length":2,"rects":[[85.75199890136719,169.3800048828125,23.7713623046875,20.5]],"start":67,"text":"UV"}],"type":5,"uuid":"d60c0e57528a9f53eb9db8a470a1a7de"},{"content":"页面点击量：访问一次页面算一次","date":"2022-06-01 17:23:37","docid":0,"fillcolor":"ffffed99","id":171,"originaltext":"PV","page":198,"textblocks":[{"first":[85.75199890136719,230.02000427246094,10.501487731933594,21.5],"last":[96.19198608398438,230.02000427246094,11.428558349609375,21.5],"length":2,"rects":[[85.75199890136719,230.02000427246094,21.868545532226562,21.5]],"start":142,"text":"PV"}],"type":5,"uuid":"22a0f3bec0767fe7a990d57b9d8c37ef"}],"originaltext":"HyperLogLog用法","page":198,"textblocks":[{"first":[63.215999603271484,86.0899887084961,15.490924835205078,25.5],"last":[212.98001098632812,86.0899887084961,20.040008544921875,25.5],"length":13,"rects":[[63.215999603271484,86.0899887084961,169.80401992797852,25.5]],"start":39,"text":"HyperLogLog用法"}],"type":5,"uuid":"8331c8334fe0444480cfe44542180722"},{"date":"2022-06-01 17:22:25","docid":0,"fillcolor":"ffffed99","id":169,"originaltext":"实现UV统计","page":201,"textblocks":[{"first":[63.215999603271484,86.989990234375,20.039997100830078,23.5],"last":[151.89999389648438,86.989990234375,20.040008544921875,23.5],"length":6,"rects":[[63.215999603271484,86.989990234375,108.72400283813477,23.5]],"start":39,"text":"实现UV统计"}],"type":5,"uuid":"838d53eba1d0808ac02624ce6c70d2b6"},{"content":"存在误差，只有三个命令\n\n对于添加重复元素不会计算，专门用于UV统计","date":"2022-06-01 22:58:41","docid":0,"fillcolor":"ffffed99","id":172,"originaltext":"HyperLogLog用法","page":199,"textblocks":[{"first":[63.215999603271484,86.0899887084961,15.490924835205078,25.5],"last":[212.98001098632812,86.0899887084961,20.040008544921875,25.5],"length":13,"rects":[[63.215999603271484,86.0899887084961,169.80401992797852,25.5]],"start":39,"text":"HyperLogLog用法"}],"type":5,"uuid":"94edd1c6f0e253fc808ece8f3314fd3e"}],"originaltext":"UV统计","page":196,"textblocks":[{"first":[423.8399963378906,219.16000366210938,23.951812744140625,34.5],"last":[501.5,219.16000366210938,32.06402587890625,34.5],"length":4,"rects":[[423.8399963378906,219.16000366210938,109.72402954101562,34.5]],"start":0,"text":"UV统计"}],"type":5,"uuid":"00c11642e2f875267c3e198de1be8e01"}],"maxid":172,"notelinks":[],"title":"02-Redis企业实战","unimportant":[]}